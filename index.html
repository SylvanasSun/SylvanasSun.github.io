<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SylvanasSun Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这里是SylvanasSun的个人博客,与你一起发现更大的世界。">
<meta property="og:type" content="website">
<meta property="og:title" content="SylvanasSun Blog">
<meta property="og:url" content="https://sylvanassun.github.io/index.html">
<meta property="og:site_name" content="SylvanasSun Blog">
<meta property="og:description" content="这里是SylvanasSun的个人博客,与你一起发现更大的世界。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SylvanasSun Blog">
<meta name="twitter:description" content="这里是SylvanasSun的个人博客,与你一起发现更大的世界。">
  
    <link rel="alternate" href="/atom.xml" title="SylvanasSun Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SylvanasSun Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">SylvanasSun的博客 | SylvanasSun Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sylvanassun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-06-27-DynamicProgramming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/27/2017-06-27-DynamicProgramming/" class="article-date">
  <time datetime="2017-06-27T10:00:00.000Z" itemprop="datePublished">2017-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/27/2017-06-27-DynamicProgramming/">什么是动态规划?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>动态规划(Dynamic Programming)是一种分阶段求解决策问题的数学思想,它通过把原问题分解为简单的子问题来解决复杂问题.动态规划在很多领域都有着广泛的应用,例如管理学,经济学,数学,生物学.</p>
<p>动态规划适用于解决带有<code>最优子结构</code>和<code>子问题重叠</code>性质的问题.</p>
<ul>
<li><code>最优子结构</code> : 即是局部最优解能够决定全局最优解(也可以认为是问题可以被分解为子问题来解决),如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有<code>最优子结构</code>性质.</li>
</ul>
<ul>
<li><code>子问题重叠</code> : 即是当使用递归进行自顶向下的求解时,<strong>每次产生的子问题不总是新的问题,而是已经被重复计算过的问题</strong>.动态规划利用了这种性质,使用一个集合将已经计算过的结果放入其中,当再次遇见重复的问题时,只需要从集合中取出对应的结果.</li>
</ul>
<h3 id="动态规划与分治算法的区别"><a href="#动态规划与分治算法的区别" class="headerlink" title="动态规划与分治算法的区别"></a>动态规划与分治算法的区别</h3><hr>
<p>相信了解过分治算法的同学会发现,动态规划与分治算法很相似,下面我们例举出一些它们的相同之处与不同之处.</p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>分治算法与动态规划都是将一个复杂问题分解为简单的子问题.</li>
</ul>
<ul>
<li>分治算法与动态规划都只能解决带有<code>最优子结构</code>性质的问题.</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>分治算法一般都是使用递归自顶向下实现,动态规划使用迭代自底向上实现或带有记忆功能的递归实现.</li>
</ul>
<ul>
<li>动态规划解决带有<code>子问题重叠</code>性质的问题效率更加高效.</li>
</ul>
<ul>
<li>分治算法分解的子问题是相对独立的.</li>
</ul>
<ul>
<li>动态规划分解的子问题是互相带有关联且有重叠的.</li>
</ul>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><hr>
<p>斐波那契数列就很适合使用动态规划来求解,它在数学上是使用递归来定义的,公式为<code>F(n) = F(n-1) + F(n-2)</code>.</p>
<p><img src="http://wx3.sinaimg.cn/mw690/63503acbly1fgzut0a5nuj20lp08xq36.jpg" alt="斐波那契数列求解过程"></p>
<h4 id="普通递归实现"><a href="#普通递归实现" class="headerlink" title="普通递归实现"></a>普通递归实现</h4><p>一个最简单的实现如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这种算法并不高效,它做了很多重复计算,它的时间复杂度为<code>O(2^n)</code>.</p>
<h4 id="动态规划递归实现"><a href="#动态规划递归实现" class="headerlink" title="动态规划递归实现"></a>动态规划递归实现</h4><p>使用动态规划来将重复计算的结果具有”记忆性”,就可以将时间复杂度降低为<code>O(n)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 判断当前n的结果是否已经被计算,如果map存在n则代表该结果已经计算过了</span></div><div class="line">	<span class="keyword">if</span> (map.containsKey(n))</div><div class="line">		<span class="keyword">return</span> map.get(n);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> value = fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">	map.put(n, value);</div><div class="line">	<span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然降低了时间复杂度,但需要维护一个集合用于存放计算结果,导致空间复杂度提升了.</p>
<h4 id="动态规划迭代实现"><a href="#动态规划迭代实现" class="headerlink" title="动态规划迭代实现"></a>动态规划迭代实现</h4><p>通过观察斐波那契数列的规律,发现n只依赖于前2种状态,所以我们可以自底向上地迭代实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 使用变量a,b来保存上次迭代和上上次迭代的结果</span></div><div class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">		temp = a + b;</div><div class="line">		a = b;</div><div class="line">		b = temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样不仅时间复杂度得到了优化,也不需要额外的空间复杂度.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="external">Wikipedia</a></li>
</ul>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun/" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/06/27/2017-06-27-DynamicProgramming/" data-id="cj4z0jkca001puomjgsm4njl8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-06-16-RedBlackTree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/16/2017-06-16-RedBlackTree/" class="article-date">
  <time datetime="2017-06-16T10:00:00.000Z" itemprop="datePublished">2017-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/16/2017-06-16-RedBlackTree/">红黑树那点事儿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>红黑树</code>是一种<code>自平衡二叉查找树</code>,它相对于<code>二叉查找树</code>性能会更加高效(查找、删除、添加等操作需要<code>O(log n)</code>,其中<code>n</code>为树中元素的个数),但实现较为复杂(需要保持自身的平衡).</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_example.svg" alt=""></p>
<p><code>红黑树</code>与<code>二叉查找树</code>不同,它的节点多了一个颜色属性,每个节点非黑即红,这也是它名字的由来.</p>
<p><code>红黑树</code>的节点定义如以下代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> Node root;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> color = RED; <span class="comment">//颜色</span></div><div class="line">    <span class="keyword">private</span> Node parent, left, right;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderStatus = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> K key;</div><div class="line">    <span class="keyword">private</span> V value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.size = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整的代码我已经放在了我的<code>Gist</code>中,<a href="https://gist.github.com/SylvanasSun/147672912cc5bc6da27e15528542877f" target="_blank" rel="external">点击查看完整代码</a>.</p>
<p><code>红黑树</code>需要保证以下性质: </p>
<ol>
<li>每个节点的颜色非黑即红.</li>
</ol>
<ol>
<li><strong>根节点的颜色为黑色.</strong></li>
</ol>
<ol>
<li>所有叶子节点都为黑色(即NIL节点).</li>
</ol>
<ol>
<li><p><strong>每个红色节点的两个子节点都必须为黑色(不能有两个连续的红节点).</strong></p>
</li>
<li><p><strong>从任一节点到其叶子的所有简单路径包含相同数量的黑色节点.</strong></p>
</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><hr>
<p><code>红黑树</code>的查找操作与<code>二叉查找树</code>一致(因为查找不会影响树的结构),而插入与删除操作需要在最后对树进行调整.</p>
<p>我们将新的节点的颜色设为红色(如果设为黑色会使根节点到叶子的一条路径上多了一个黑节点,违反了性质5,这个是很难调整的).</p>
<p>现在我们假设新节点为<code>N</code>,它的父节点为<code>P</code>(且<code>P</code>为<code>G</code>的左节点,如果为右节点则与其操作互为镜像),祖父节点为<code>G</code>,叔叔节点为<code>U</code>.插入一个节点会有以下种情况.</p>
<h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p><strong><code>N</code>位于根,它没有父节点与子节点,这时候只需要把它重新设置为黑色即可</strong>,无需其他调整.</p>
<h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p><strong><code>P</code>的颜色为黑色</strong>,这种情况下保持了性质4(<code>N</code>只有两个叶子节点,它们都为黑色)与性质5(<code>N</code>是一个红色节点,不会对其造成影响)的有效,所以<strong>无需调整</strong>.</p>
<h4 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h4><p>如果<code>P</code>与<code>U</code>都为红色,我们可以将它们两个重新绘制为黑色,然后将<code>G</code>绘制为红色(保持性质5),最后再从<code>G</code>开始继续向上进行调整.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png" alt=""></p>
<h4 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h4><p><strong><code>P</code>为红色,<code>U</code>为黑色,且<code>N</code>为<code>P</code>的左子节点,这种情况下,我们需要在<code>G</code>处进行一次<code>右旋转</code></strong>,结果满足了性质4与性质5,因为通过这三个节点中任何一个的所有路径以前都通过祖父节点<code>G</code>，现在它们都通过以前的父节点<code>P</code>.</p>
<p>关于旋转操作,可以查看这篇文章<a href="http://sylvanassun.github.io/2017/03/30/red_black_binary_search_tree/">《Algorithms,4th Edition》读书笔记-红黑二叉查找树</a>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png" alt=""></p>
<h4 id="情况5"><a href="#情况5" class="headerlink" title="情况5"></a>情况5</h4><p><code>P</code>为红色,<code>U</code>为黑色,且<code>N</code>为<code>P</code>的右子节点,我们需要先在<code>P</code>处进行一次<code>左旋转</code>,这样就又回到了情况4.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png" alt=""></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; colorOf(parentOf(x)) == RED) &#123;</div><div class="line">          <span class="keyword">if</span> (parentOf(x) == grandpaOf(x).left) &#123;</div><div class="line">              x = parentIsLeftNode(x);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              x = parentIsRightNode(x);</div><div class="line">          &#125;</div><div class="line">          fixSize(x);</div><div class="line">      &#125;</div><div class="line">      setColor(root, BLACK);</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">parentIsLeftNode</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      Node xUncle = grandpaOf(x).right;</div><div class="line"><span class="comment">// 情况3</span></div><div class="line">      <span class="keyword">if</span> (colorOf(xUncle) == RED) &#123;</div><div class="line">          x = uncleColorIsRed(x, xUncle);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// 情况5</span></div><div class="line">          <span class="keyword">if</span> (x == parentOf(x).right) &#123;</div><div class="line">              x = parentOf(x);</div><div class="line">              rotateLeft(x);</div><div class="line">          &#125;</div><div class="line">	<span class="comment">// 情况4</span></div><div class="line">          rotateRight(grandpaOf(x));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">parentIsRightNode</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      Node xUncle = grandpaOf(x).left;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (colorOf(xUncle) == RED) &#123;</div><div class="line">          x = uncleColorIsRed(x, xUncle);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">if</span> (x == parentOf(x).left) &#123;</div><div class="line">              x = parentOf(x);</div><div class="line">              rotateRight(x);</div><div class="line">          &#125;</div><div class="line">          rotateLeft(grandpaOf(x));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">uncleColorIsRed</span><span class="params">(Node x, Node xUncle)</span> </span>&#123;</div><div class="line">      setColor(parentOf(x), BLACK);</div><div class="line">      setColor(xUncle, BLACK);</div><div class="line">      setColor(grandpaOf(x), RED);</div><div class="line">      x = grandpaOf(x);</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>我们只考虑删除节点只有一个子节点的情况,且只有后继节点与删除节点都为黑色(如果删除节点为红色,从根节点到叶子节点的每条路径上少了一个红色节点并不会违反<code>红黑树</code>的性质,而如果后继节点为红色,只需要将它重新绘制为黑色即可).</p>
<p>先将删除节点替换为后继节点,且后继节点定义为<code>N</code>,它的兄弟节点为<code>S</code>.</p>
<h4 id="情况1-1"><a href="#情况1-1" class="headerlink" title="情况1"></a>情况1</h4><p><code>N</code>为新的根节点,在这种情况下只需要把根节点保持为黑色即可.</p>
<h4 id="情况2-1"><a href="#情况2-1" class="headerlink" title="情况2"></a>情况2</h4><p><strong><code>S</code>为红色,只需要在<code>P</code>进行一次<code>左旋转</code></strong>,接下来则<strong>继续按以下情况进行处理</strong>(尽管路径上的黑色节点数量没有改变,但<code>N</code>有了一个黑色的兄弟节点与红色的父节点).</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png" alt=""></p>
<h4 id="情况3-1"><a href="#情况3-1" class="headerlink" title="情况3"></a>情况3</h4><p><code>S</code>和它的子节点都是黑色的,而<code>P</code>为红色.这种情况下只需要将<code>S</code>与<code>P</code>的颜色进行交换</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png" alt=""></p>
<h4 id="情况4-1"><a href="#情况4-1" class="headerlink" title="情况4"></a>情况4</h4><p><strong><code>S</code>和它的子节点都是黑色的,这种情况下需要把<code>S</code>重新绘制为红色</strong>.这时不通过<code>N</code>的路径都将少一个黑色节点(通过<code>N</code>的路径因为删除节点是黑色的也都少了一个黑色节点),这让它们平衡了起来.</p>
<p>但现在通过<code>P</code>的路径比不通过<code>P</code>的路径都少了一个黑色节点,所以还需要在<code>P</code>上继续进行调整.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png" alt=""></p>
<h4 id="情况5-1"><a href="#情况5-1" class="headerlink" title="情况5"></a>情况5</h4><p><strong><code>S</code>为黑色,它的左子节点为红色,右子节点为黑色.这种情况下,我们在<code>S</code>上做<code>右旋转</code></strong>,这样<code>S</code>的左儿子成为<code>S</code>的父亲和N的新兄弟。我们接着交换<code>S</code>和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在<code>N</code>有了一个右儿子是红色的黑色兄弟，所以我们进入了情况6。<code>N</code>和<code>P</code>都不受这个变换的影响。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png" alt=""></p>
<h4 id="情况6"><a href="#情况6" class="headerlink" title="情况6"></a>情况6</h4><p><strong><code>S</code>是黑色，它的右子节点是红色,我们在<code>N</code>的父亲<code>P</code>上做<code>左旋转</code></strong>.这样<code>S</code>成为<code>N</code>的父亲和<code>S</code>的右儿子的父亲。我们接着交换<code>N</code>的父亲和<code>S</code>的颜色，<strong>并使<code>S</code>的右儿子为黑色</strong>。子树在它的根上的仍是同样的颜色,但是,<code>N</code>现在增加了一个黑色祖先.所以,通过<code>N</code>的路径都增加了一个黑色节点.此时,如果一个路径不通过<code>N</code>,则有两种可能性:</p>
<ul>
<li>它通过<code>N</code>的新兄弟.那么它以前和现在都必定通过<code>S</code>和<code>N</code>的父亲,而它们只是交换了颜色.所以路径保持了同样数目的黑色节点.</li>
</ul>
<ul>
<li>它通过<code>N</code>的新叔父,<code>S</code>的右儿子.那么它以前通过<code>S</code>、<code>S</code>的父亲和<code>S</code>的右儿子,但是现在只通过<code>S</code>,它被假定为它以前的父亲的颜色,和<code>S</code>的右儿子,它被从红色改变为黑色.合成效果是这个路径通过了同样数目的黑色节点.</li>
</ul>
<p>在任何情况下,在这些路径上的黑色节点数目都没有改变.所以我们恢复了性质4.在示意图中的白色节点可以是红色或黑色,但是在变换前后都必须指定相同的颜色.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png" alt=""></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; colorOf(x) == BLACK) &#123;</div><div class="line">          <span class="keyword">if</span> (x == parentOf(x).left) &#123;</div><div class="line">              x = successorIsLeftNode(x);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              x = successorIsRightNode(x);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      setColor(x, BLACK);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">successorIsLeftNode</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      Node brother = parentOf(x).right;</div><div class="line"><span class="comment">// 情况2</span></div><div class="line">      <span class="keyword">if</span> (colorOf(brother) == RED) &#123;</div><div class="line">          rotateLeft(parentOf(x));</div><div class="line">          brother = parentOf(x).right;</div><div class="line">      &#125;</div><div class="line"><span class="comment">// 情况3,4</span></div><div class="line">      <span class="keyword">if</span> (colorOf(brother.left) == BLACK &amp;&amp; colorOf(brother.right) == BLACK) &#123;</div><div class="line">          x = brotherChildrenColorIsBlack(x, brother);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// 情况5</span></div><div class="line">          <span class="keyword">if</span> (colorOf(brother.right) == BLACK) &#123;</div><div class="line">              rotateRight(brother);</div><div class="line">              brother = parentOf(x).right;</div><div class="line">          &#125;</div><div class="line">	<span class="comment">// 情况6</span></div><div class="line">          setColor(brother.right, BLACK);</div><div class="line">          rotateLeft(parentOf(x));</div><div class="line">          x = root;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">brotherChildrenColorIsBlack</span><span class="params">(Node x, Node brother)</span> </span>&#123;</div><div class="line">      setColor(brother, RED);</div><div class="line">      x = parentOf(x);</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">Wikipedia</a></li>
</ul>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun/" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/06/16/2017-06-16-RedBlackTree/" data-id="cj4z0jkcc001ruomjjbmzkrn2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-06-14-sort_algorithms_qucikSort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/14/2017-06-14-sort_algorithms_qucikSort/" class="article-date">
  <time datetime="2017-06-14T08:30:00.000Z" itemprop="datePublished">2017-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/14/2017-06-14-sort_algorithms_qucikSort/">深入浅出排序算法(3)-快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>快速排序</code>与<code>归并排序</code>一样也是基于分治算法的排序算法.所以它的实现方法也与其他的分治算法一样,需要进行分解子任务,处理子任务,归并子任务这些步骤.</p>
<p>但<code>快速排序</code>与<code>归并排序</code>不同,它是一种<code>原地排序</code>算法(不需要额外的辅助数组),且<code>快速排序</code>不使用中间值来分解任务,而是使用<code>划分函数</code>.</p>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""></p>
<ul>
<li>从数组中挑选出一个值,作为<code>基准值 k</code>.</li>
</ul>
<ul>
<li>重新排序序列,<strong>将所有小于<code>k</code>的值放到<code>k</code>前面,所有大于<code>k</code>的值放到<code>k</code>后面</strong>(也可以理解为将数组<code>a</code>切分为两个子数组<code>a[begin...k-1],a[k+1...end]</code>,其中前一个子数组都小于<code>k</code>,后一个子数组都大于<code>k</code>).</li>
</ul>
<ul>
<li>递归地将两个子数组进行快速排序(递归到最底部时,子数组的大小是零或一,也就是已经排序好了.).</li>
</ul>
<h3 id="划分函数"><a href="#划分函数" class="headerlink" title="划分函数"></a>划分函数</h3><hr>
<p><code>划分函数</code>就是上述步骤中的第二步,它将数组根据<code>基准值</code>进行重排序.根据<code>基准值</code>选择的位置不同,<code>划分函数</code>也有不同的实现方法,不过其根本思想都是将小于<code>基准值</code>的值放到前面,大于<code>基准值</code>的值放到后面.</p>
<h4 id="使用末尾元素作为基准值"><a href="#使用末尾元素作为基准值" class="headerlink" title="使用末尾元素作为基准值"></a>使用末尾元素作为基准值</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用末尾元素作为基准值来进行切分</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionUseEnd</span><span class="params">(Comparable[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    Comparable pivot = a[end]; <span class="comment">// 基准值,切分后的数组应满足左边都小于基准,右边都大于基准</span></div><div class="line">    <span class="keyword">int</span> i = begin - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end; j++) &#123;</div><div class="line">        <span class="comment">// 如果j小于基准值则与i交换</span></div><div class="line">        <span class="keyword">if</span> (less(a[j], pivot)) &#123;</div><div class="line">            i++;</div><div class="line">            swap(a, i, j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将基准值交换到正确的位置上</span></div><div class="line">    <span class="keyword">int</span> pivotLocation = i + <span class="number">1</span>;</div><div class="line">    swap(a, pivotLocation, end);</div><div class="line">    <span class="keyword">return</span> pivotLocation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用首元素作为基准值"><a href="#使用首元素作为基准值" class="headerlink" title="使用首元素作为基准值"></a>使用首元素作为基准值</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用首元素作为基准值来进行切分</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionUseBegin</span><span class="params">(Comparable[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    Comparable pivot = a[begin];</div><div class="line">    <span class="keyword">int</span> i = begin;</div><div class="line">    <span class="keyword">int</span> j = end + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 从左向右扫描,直到找出一个大于等于基准的值</span></div><div class="line">        <span class="keyword">while</span> (less(a[++i], pivot)) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= end)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从右向左扫描,直到找出一个小于等于基准的值</span></div><div class="line">        <span class="keyword">while</span> (less(pivot, a[--j])) &#123;</div><div class="line">            <span class="keyword">if</span> (j &lt;= begin)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果指针i与j发生碰撞则结束循环</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= j)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 将左边大于小于基准的值与右边小于等于基准的值进行交换</span></div><div class="line">        swap(a, i, j);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将基准值交换到正确的位置上</span></div><div class="line">    swap(a, begin, j);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<p>了解了<code>划分函数</code>的实现,剩下就只需要递归地调用<code>快速排序</code>不断地分解子任务即可.</p>
<p>注意,<code>快速排序</code>与<code>归并排序</code>不同,它不需要进行<code>归并</code>(划分后就已经是有序的了),并且是先进行<code>划分函数</code>,再分解任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (begin &gt;= end)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> k = partitionUseEnd(a, begin, end);</div><div class="line">    sort(a, begin, k - <span class="number">1</span>);</div><div class="line">    sort(a, k + <span class="number">1</span>, end);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun/" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/06/14/2017-06-14-sort_algorithms_qucikSort/" data-id="cj4z0jkc4001kuomj0b5b2zhy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-06-12-sort_algorithmes_mergeSort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/2017-06-12-sort_algorithmes_mergeSort/" class="article-date">
  <time datetime="2017-06-12T07:00:00.000Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/2017-06-12-sort_algorithmes_mergeSort/">深入浅出排序算法(2)-归并排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>归并排序</code>是基于分治算法实现的一种排序算法,它将数组分割为两个子数组,然后对子数组进行排序,最终将子数组<code>归并</code>为有序的数组.</p>
<p><code>归并排序</code>的时间复杂度为<code>O(n log n)</code>,空间复杂度为<code>O(1)</code>,并且它是稳定的排序算法(所谓稳定即是不影响值相等元素的相对次序).</p>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt=""></p>
<ul>
<li>首先,<code>归并排序</code>需要将一个大小为<code>n</code>个元素的数组分解为各包含<code>n/2</code>个元素的子数组(这个分解的过程会不断进行,直到子数组元素个数为<code>1</code>).</li>
</ul>
<ul>
<li>当子数组的元素个数为<code>1</code>时,代表这个子数组已经有序,开始两两归并(将两个个数为<code>1</code>的子数组归并为一个个数为<code>2</code>的子数组,不断归并,直到所有子数组个数为<code>2</code>,然后继续将两个个数为<code>2</code>的子数组归并为一个个数为<code>4</code>的子数组….以此类推).</li>
</ul>
<ul>
<li>不断重复步骤2,直到整个数组有序.</li>
</ul>
<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><hr>
<p>通过以上的了解,我们发现<code>归并排序</code>中最重要的步骤就是<code>归并</code>.</p>
<p>采用类似<code>洗牌</code>的方式来理解这个过程.想象辅助数组为一个空牌堆,两个子数组为两堆牌<code>a</code>和<code>b</code>.我们从<code>a</code>堆与<code>b</code>堆中<strong>各取出一张牌进行比较,然后将较小的牌放入空牌堆中</strong>,不断重复比较直到任一牌堆为空.最后,再将未空的牌堆全部放入空牌堆中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将两个子序列进行归并</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[a.length]; <span class="comment">// 辅助数组</span></div><div class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> count = lo;</div><div class="line">    <span class="comment">// 对[lo...mid] 与 [mid+1...hi] 两个子序列的首元素进行比较,将较小的元素放入辅助数组</span></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</div><div class="line">        <span class="keyword">if</span> (less(a[i], a[j]))</div><div class="line">            aux[count++] = a[i++];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            aux[count++] = a[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//将[lo...mid] 与 [mid+1...hi] 两个子序列中剩余的元素放入辅助数组</span></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">        aux[count++] = a[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt;= hi) &#123;</div><div class="line">        aux[count++] = a[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将辅助数组中的元素复制到源数组中</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">        a[k] = aux[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><hr>
<p>只要理解了<code>归并</code>的过程,剩下就很容易实现了.<code>归并排序</code>的递归实现如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">      sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">  <span class="comment">// 递归实现归并排序</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (lo &gt;= hi)</div><div class="line">          <span class="keyword">return</span>;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// (lo + hi) / 2</span></div><div class="line"><span class="comment">// 分解数组</span></div><div class="line">      sort(a, lo, mid);</div><div class="line">      sort(a, mid + <span class="number">1</span>, hi);</div><div class="line"><span class="comment">// 归并</span></div><div class="line">      merge(a, lo, mid, hi);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><hr>
<p>我们已经知道了<code>归并排序</code>中最小子数组的元素个数为<code>1</code>,非递归实现只需要从<code>1</code>开始自底向上地归并即可(递归实现的真实计算过程也是如此,这是由于递归调用是后进先出的).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 非递归实现归并排序</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortUnRecursive</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">1</span>; <span class="comment">// 自底向上实现归并排序,子序列的最小粒度为1</span></div><div class="line">       <span class="keyword">while</span> (len &lt; a.length) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i += len &lt;&lt; <span class="number">1</span>) &#123;</div><div class="line">               merge(a, i, len);</div><div class="line">           &#125;</div><div class="line">           len = len &lt;&lt; <span class="number">1</span>; <span class="comment">// 子序列规模每次迭代时乘2</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// 与递归实现的归并函数不同,需要注意边界检查</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> length = a.length;</div><div class="line">       Comparable[] aux = <span class="keyword">new</span> Comparable[length];</div><div class="line">       <span class="keyword">int</span> count = lo;</div><div class="line">       <span class="comment">// 子数组1</span></div><div class="line">       <span class="keyword">int</span> i = lo;</div><div class="line">       <span class="keyword">int</span> i_bound = lo + hi;</div><div class="line">       <span class="comment">// 子数组2</span></div><div class="line">       <span class="keyword">int</span> j = i_bound;</div><div class="line">       <span class="keyword">int</span> j_bound = j + hi;</div><div class="line"></div><div class="line">       <span class="comment">// 注意j的边界检查</span></div><div class="line">       <span class="keyword">while</span> (i &lt; i_bound &amp;&amp; j &lt; j_bound &amp;&amp; j &lt; length) &#123;</div><div class="line">           <span class="keyword">if</span> (less(a[i], a[j]))</div><div class="line">               aux[count++] = a[i++];</div><div class="line">           <span class="keyword">else</span></div><div class="line">               aux[count++] = a[j++];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// i和j都有可能越界</span></div><div class="line">       <span class="keyword">while</span> (i &lt; i_bound &amp;&amp; i &lt; length) &#123;</div><div class="line">           aux[count++] = a[i++];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (j &lt; j_bound &amp;&amp; j &lt; length) &#123;</div><div class="line">           aux[count++] = a[j++];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> k = lo;</div><div class="line">       <span class="keyword">while</span> (k &lt; j &amp;&amp; k &lt; length) &#123;</div><div class="line">           a[k] = aux[k];</div><div class="line">           k++;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/06/12/2017-06-12-sort_algorithmes_mergeSort/" data-id="cj4z0jkc6001muomjbf2n0ze6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-06-09-sort_algorithms_heapSort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/09/2017-06-09-sort_algorithms_heapSort/" class="article-date">
  <time datetime="2017-06-09T10:00:00.000Z" itemprop="datePublished">2017-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/09/2017-06-09-sort_algorithms_heapSort/">深入浅出排序算法(1)-堆排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>堆排序</code>即是利用<code>堆</code>这个数据结构来完成排序的.所以,要想理解<code>堆排序</code>就要先了解<code>堆</code>.</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><hr>
<p><code>堆(Heap)</code>是一种数据结构,它可以被看做是一棵树的数组对象.一个<code>二叉堆</code>拥有以下性质.</p>
<ul>
<li>父节点<code>k</code>的左子节点在数组中的索引位置为<code>2 * k + 1</code>.</li>
</ul>
<ul>
<li>父节点<code>k</code>的右子节点在数组中的索引位置为<code>2 * k + 2</code>.</li>
</ul>
<ul>
<li>子节点<code>i</code>的父节点在数组中的索引位置为<code>(i - 1) / 2</code>.</li>
</ul>
<ul>
<li>父节点<code>k</code>的任意子节点都必须小于(或大于)<code>k</code>.</li>
</ul>
<ul>
<li>根节点必须是最大节点(或最小节点).</li>
</ul>
<h4 id="最大堆代码实现"><a href="#最大堆代码实现" class="headerlink" title="最大堆代码实现"></a>最大堆代码实现</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    T[] heap;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MaxHeap</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(T[] heap)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.heap = heap;</div><div class="line">        buildHeap();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自底向上构建堆</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = heap.length;</div><div class="line">        <span class="comment">// 当堆为空或者长度为1时不需要任何操作</span></div><div class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> root = (length - <span class="number">2</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// (i - 1) / 2</span></div><div class="line">        <span class="keyword">while</span> (root &gt;= <span class="number">0</span>) &#123;</div><div class="line">            heapify(heap, length, root);</div><div class="line">            root--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调整堆的结构</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> heap   堆</div><div class="line">     * <span class="doctag">@param</span> length 堆的长度</div><div class="line">     * <span class="doctag">@param</span> root   根节点索引</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(T[] heap, <span class="keyword">int</span> length, <span class="keyword">int</span> root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root &gt;= length)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> largest = root; <span class="comment">// 表示root,left,right中最大值的变量</span></div><div class="line">        <span class="keyword">int</span> left = (root &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点,root * 2 + 1</span></div><div class="line">        <span class="keyword">int</span> right = left + <span class="number">1</span>; <span class="comment">// 右子节点,root * 2 + 2</span></div><div class="line"></div><div class="line">        <span class="comment">// 找出最大值</span></div><div class="line">        <span class="keyword">if</span> (left &lt; length &amp;&amp; greater(heap[left], heap[largest]))</div><div class="line">            largest = left;</div><div class="line">        <span class="keyword">if</span> (right &lt; length &amp;&amp; greater(heap[right], heap[largest]))</div><div class="line">            largest = right;</div><div class="line"></div><div class="line">        <span class="comment">// 如果largest发生变化,将largest与root交换</span></div><div class="line">        <span class="keyword">if</span> (largest != root) &#123;</div><div class="line">            T t = heap[root];</div><div class="line">            heap[root] = heap[largest];</div><div class="line">            heap[largest] = t;</div><div class="line">            <span class="comment">// 继续向下调整堆</span></div><div class="line">            heapify(heap, length, largest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable a, Comparable b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><hr>
<p>普通的队列是基于<code>先进先出</code>的,也就是说最先入队的元素永远是在第一位,而<code>优先队列</code>中的每一个元素都是拥有<code>优先级</code>的,<code>优先级</code>最高的元素永远在第一位.</p>
<p><code>优先队列</code>也是<code>贪心算法</code>的体现,所谓的<code>贪心算法</code>即是在问题求解的每一步中总是选择当前最好的结果.</p>
<p><code>堆</code>就是用于实现<code>优先队列</code>的,因为<code>堆</code>的性质与<code>优先队列</code>十分吻合.</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><hr>
<p>往<code>优先队列</code>中添加元素时,我们只需要将元素添加到数组末尾并调整堆(以下例子均是以最大堆为例).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">       <span class="keyword">if</span> (size == queue.length)</div><div class="line">           resize(queue.length * <span class="number">2</span>);</div><div class="line">       <span class="keyword">int</span> i = size;</div><div class="line">	<span class="comment">// 如果当前队列为空,则不需要进行堆调整直接插入元素即可</span></div><div class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">           queue[<span class="number">0</span>] = t;</div><div class="line">       <span class="keyword">else</span></div><div class="line">           swim(i, t);</div><div class="line">       size++;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// 上浮调整</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</div><div class="line">       Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable) t;</div><div class="line">       <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">int</span> parent = (i - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">           T p = (T) queue[parent];</div><div class="line">		<span class="comment">// 如果key小于他的父节点(符合最大堆规则)则结束调整</span></div><div class="line">           <span class="keyword">if</span> (key.compareTo(p) &lt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           queue[i] = p;</div><div class="line">           i = parent;</div><div class="line">       &#125;</div><div class="line">       queue[i] = key;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><hr>
<p>删除操作要稍微麻烦一点,将<code>优先队列</code>中末尾的元素放到队头并进行堆调整.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isEmpty())</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">int</span> s = --size;</div><div class="line">       Object result = queue[<span class="number">0</span>];</div><div class="line">       Object end = queue[s];</div><div class="line">       queue[s] = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">           sink(<span class="number">0</span>, (T) end);</div><div class="line">       <span class="keyword">if</span> (size &lt;= queue.length / <span class="number">4</span>)</div><div class="line">           resize(queue.length / <span class="number">2</span>);</div><div class="line">       <span class="keyword">return</span> (T) result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// 下沉调整</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</div><div class="line">       Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) t;</div><div class="line">       <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (i &lt; half) &#123;</div><div class="line">           <span class="keyword">int</span> child = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点</span></div><div class="line">           <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 右子节点</span></div><div class="line">           T max = (T) queue[child];</div><div class="line">           <span class="comment">// find maximum element</span></div><div class="line">           <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">                   ((Comparable&lt;? <span class="keyword">super</span> T&gt;) max).compareTo((T) queue[right]) &lt; <span class="number">0</span>)</div><div class="line">               max = (T) queue[child = right];</div><div class="line">		<span class="comment">// key大于它的最大子节点(符合最大堆规则)则结束调整	</span></div><div class="line">           <span class="keyword">if</span> (key.compareTo(max) &gt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           queue[i] = max;</div><div class="line">           i = child;</div><div class="line">       &#125;</div><div class="line">       queue[i] = key;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/SylvanasSun/test-demo/blob/master/src/main/java/com/sun/sylvanas/data_struct/heap/MaxPriorityQueue.java" target="_blank" rel="external">点击查看优先队列完整代码</a></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p>实现<code>堆排序</code>有两种方法,一种是使用<code>优先队列</code>,另一种是直接使用<code>堆</code>.</p>
<h4 id="直接使用堆实现堆排序"><a href="#直接使用堆实现堆排序" class="headerlink" title="直接使用堆实现堆排序"></a>直接使用堆实现堆排序</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用最大堆实现堆排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    MaxHeap&lt;Comparable&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;(a);</div><div class="line">    <span class="comment">//不断地将最大堆中顶端元素(最大值)与最底部的元素(最小值)交换</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        Comparable largest = a[<span class="number">0</span>];</div><div class="line">        a[<span class="number">0</span>] = a[i];</div><div class="line">        a[i] = largest;</div><div class="line">        <span class="comment">// 堆减少,并调整新的堆</span></div><div class="line">        maxHeap.heapify(a, i, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用优先队列实现堆排序"><a href="#使用优先队列实现堆排序" class="headerlink" title="使用优先队列实现堆排序"></a>使用优先队列实现堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用优先队列实现堆排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pqSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    MinPriorityQueue&lt;Comparable&gt; priorityQueue = <span class="keyword">new</span> MinPriorityQueue&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">        priorityQueue.add(a[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">        a[i] = priorityQueue.poll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/06/09/2017-06-09-sort_algorithms_heapSort/" data-id="cj4z0jkc3001iuomjpxtmiv2g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-06-07-IoC&amp;AOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/07/2017-06-07-IoC&AOP/" class="article-date">
  <time datetime="2017-06-07T08:00:00.000Z" itemprop="datePublished">2017-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/07/2017-06-07-IoC&AOP/">IoC与AOP的那点事儿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><hr>
<p>控制反转(Inversion of Control)是<code>OOP</code>中的一种设计原则,也是<code>Spring</code>框架的核心.大多数应用程序的业务逻辑代码都需要两个或多个类进行合作完成的,<strong>通过<code>IoC</code>则可以减少它们之间的耦合度</strong>.</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><hr>
<p><code>IoC</code>的主要实现方法有两种,<code>依赖注入</code>与<code>依赖查找</code>.</p>
<p> <strong>依赖注入 :</strong>  应用程序被动的接收对象,<code>IoC</code>容器通过类型或名称等信息来判断将不同的对象注入到不同的属性中.</p>
<p>依赖注入主要有以下的方式: </p>
<ul>
<li>基于<code>set</code>方法 : 实现特定属性的public set()方法,来让<code>IoC</code>容器调用注入所依赖类型的对象.</li>
</ul>
<ul>
<li>基于接口 : 实现特定接口以供<code>IoC</code>容器注入所依赖类型的对象.</li>
</ul>
<ul>
<li><p>基于构造函数 : 实现特定参数的构造函数,在创建对象时来让<code>IoC</code>容器注入所依赖类型的对象.</p>
</li>
<li><p>基于注解 : 通过<code>Java</code>的注解机制来让<code>IoC</code>容器注入所依赖类型的对象,例如<code>Spring</code>框架中的<code>@Autowired</code>.</p>
</li>
</ul>
<p><strong>依赖查找 :</strong> 它相对于<code>依赖注入</code>而言是一种更为主动的方法,它会在需要的时候通过调用框架提供的方法来获取对象,获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态.</p>
<h4 id="IoC的思想"><a href="#IoC的思想" class="headerlink" title="IoC的思想"></a>IoC的思想</h4><hr>
<p>在传统实现中,我们都是通过应用程序自己来管理依赖的创建,例如下代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 由Person自己管理Food类的创建</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">		Food food = <span class="keyword">new</span> Chicken();</div><div class="line">		System.out.println(<span class="string">"I am eating "</span> + food.getName() + <span class="string">"..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>IoC</code>则是通过一个<strong>第三方容器来管理并维护这些被依赖对象,应用程序只需要接收并使用<code>IoC容器</code>注入的对象而不需要关注其他事情</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Food food;</div><div class="line"></div><div class="line">	<span class="comment">// 通过set注入</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFood</span><span class="params">(Food food)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.food = food;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Person不需要关注Food,只管使用即可</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"I am eating "</span> + <span class="keyword">this</span>.food.getName() + <span class="string">"..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上的例子我们能够发现,控制反转其实就是对象控制权的转移,<strong>应用程序将对象的控制权转移给了第三方容器并通过它来管理这些被依赖对象,完成了应用程序与被依赖对象的解耦.</strong></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><hr>
<p><code>AOP(Aspect-Oriented Programming)</code>即面向方面编程.<strong>它是一种在运行时,动态地将代码切入到类的指定方法、指定位置上的编程思想.</strong>用于<strong>切入到指定类指定方法的代码片段叫做<code>切面</code></strong>,而<strong>切入到哪些类中的哪些方法叫做<code>切入点</code>.</strong></p>
<p><code>AOP</code>是<code>OOP</code>的有益补充,<code>OOP</code>从横向上区分出了一个个类,<code>AOP</code>则从纵向上向指定类的指定方法中动态地切入代码.它使<code>OOP</code>变得更加立体.</p>
<p><code>Java</code>中的动态代理或<code>CGLib</code>就是<code>AOP</code>的体现.</p>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><hr>
<p>在<code>OOP</code>中,我们使用封装的特性来将不同职责的代码抽象到不同的类中.但是在分散代码的同时,也增加了代码的重复性.</p>
<p>例如,我们需要在两个或多个类中的方法都记录日志或执行时间,可能这些代码是完全一致的,但因为类与类无法联系造成代码重复.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		recordLog();	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 记录日志...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		recordLog();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 记录日志...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来,我们采取两种不同方案来改进这段代码.</p>
<h4 id="将重复代码抽离到一个类中"><a href="#将重复代码抽离到一个类中" class="headerlink" title="将重复代码抽离到一个类中"></a>将重复代码抽离到一个类中</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		Report.recordLog();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		Report.recordLog();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordLog</span> <span class="params">(String ...messages)</span> </span>&#123;</div><div class="line">		<span class="comment">// 记录日志...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看似解决了问题,但类之间已经耦合了.并且当这些外围业务代码(日志,权限校验等)越来越多时,它们的侵入(与核心业务代码混在一起)会使代码的整洁度变得混乱不堪.</p>
<h4 id="使用AOP分离外围业务代码"><a href="#使用AOP分离外围业务代码" class="headerlink" title="使用AOP分离外围业务代码"></a>使用AOP分离外围业务代码</h4><hr>
<p>我们使用<code>AspectJ</code>,它是一个<code>AOP</code>框架,扩展了Java语言,并定义了<code>AOP</code>语法(通过它实现的编译器).</p>
<p>使用<code>AspectJ</code>需要先安装并将lib中aspectjrt.jar添加进入classpath,<a href="http://www.eclipse.org/aspectj/downloads.php" target="_blank" rel="external">下载地址</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Say something..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Something something = <span class="keyword">new</span> Something();</div><div class="line">        something.say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> aspect SomethingAspect &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 切入点,切入到Something.say()</div><div class="line">     */</div><div class="line">    <span class="function">pointcut <span class="title">recordLog</span><span class="params">()</span>:<span class="title">call</span><span class="params">(* com.sun.sylvanas.application.hello_aop.Something.say(..)</span>)</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在方法执行后执行</div><div class="line">     */</div><div class="line">    after():recordLog() &#123;</div><div class="line">        System.out.println(<span class="string">"[AFTER] Record log..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AOP</code>解决了代码的重复并将这些外围业务代码抽离到一个切面中,我们可以动态地将切面切入到切入点.</p>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/06/07/2017-06-07-IoC&AOP/" data-id="cj4z0jkby001duomjudwacfk4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程思想/">编程思想</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-5-29-cas_concurrent_stack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/29/2017-5-29-cas_concurrent_stack/" class="article-date">
  <time datetime="2017-05-29T10:00:00.000Z" itemprop="datePublished">2017-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/29/2017-5-29-cas_concurrent_stack/">谈谈如何实现一个非阻塞的线程安全的集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>众所周知,想要在<code>java</code>中要实现一个线程安全的类有很多方法.最简单直接的即是使用<code>synchronized</code>关键字或<code>ReentrantLock</code>.</p>
<p>但是,这两种同步方法都是基于锁的,基于锁的同步方法是阻塞的,即未争夺到锁的线程需要阻塞等待(或挂起)直到锁可用.</p>
<p>这种方法具有一些明显的缺点:</p>
<ul>
<li>被阻塞的线程无法去做任何其他事情,如果这个线程是优先级较高的线程甚至会发生非常不好的结果(优先级倒置).</li>
</ul>
<ul>
<li>由于<code>java</code>的线程模型是基于内核线程实现的,挂起恢复线程需要来回地切换到内核态,性能开销很大.</li>
</ul>
<ul>
<li>当两个(或多个)线程都阻塞着等待另一方释放锁时,将会引发死锁.</li>
</ul>
<p>那么有非阻塞的方法来实现同步吗?(<code>volatile</code>关键字也是非阻塞的,但它只保证了数据的可见性与有序性,并不保证原子性)</p>
<p>有!在<code>jdk5</code>中,java增加了大量的原子类来保证无锁下的操作原子性,可以说<code>java.util.concurrent</code>包下的所有类都几乎用到了这些原子类.</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><hr>
<p>这些原子类都是基于<code>CAS</code>实现的,<code>CAS</code>即是<strong>Compare And Swap</strong>,它的原理简单来讲就是<strong>在更新新值之前先去比较原值有没有发生变化,如果没发生变化则进行更新</strong>.</p>
<p><code>java</code>中的<code>CAS</code>是通过<code>Unsafe</code>类中的本地方法实现的,而这些本地方法需要通过现代处理器提供的<code>CAS</code>指令实现(在<code>Intel</code>处理器中该指令为<code>cmpxchg</code>).</p>
<p>所以我们发现,<strong><code>CAS</code>操作的原子性是由处理器来保证的</strong>.</p>
<h4 id="比较的过程"><a href="#比较的过程" class="headerlink" title="比较的过程"></a>比较的过程</h4><p>在<code>CAS</code>操作中包含了三个数,<code>V(内存位置)</code>,<code>A(预期值)</code>,<code>B(新值)</code>.</p>
<ul>
<li>首先会将<code>V</code>与<code>A</code>进行匹配.</li>
</ul>
<ul>
<li>如果两个值相等,则使用<code>B</code>作为新值进行更新.</li>
</ul>
<ul>
<li>如果不相等,则不进行更新操作(一般的补救措施是继续进行请求).</li>
</ul>
<h4 id="与锁相比的优点"><a href="#与锁相比的优点" class="headerlink" title="与锁相比的优点"></a>与锁相比的优点</h4><ul>
<li><p><code>CAS</code>操作是无锁的实现,所以它不会发生死锁情况.</p>
</li>
<li><p>虽然<code>CAS</code>操作失败需要不断的进行请求重试,但相对于不断地挂起或恢复线程来说,性能开销要低得多.</p>
</li>
<li><p><code>CAS</code>的粒度更细,操作也更加轻量与灵活.</p>
</li>
</ul>
<h3 id="ConcurrentStack"><a href="#ConcurrentStack" class="headerlink" title="ConcurrentStack"></a>ConcurrentStack</h3><hr>
<p>我们通过实现一个简单的<code>ConcurentStack</code>来看看<code>CAS</code>操作是如何保证线程安全的.</p>
<p><a href="https://gist.github.com/SylvanasSun/15353e5567e1890b45f516f7fe6a187d" target="_blank" rel="external">完整代码请从作者的Gist中获取</a></p>
<h4 id="节点的实现"><a href="#节点的实现" class="headerlink" title="节点的实现"></a>节点的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&lt;E&gt;&gt; head = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</div><div class="line">    <span class="keyword">private</span> AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This internal static class represents the nodes in the stack.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E value;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>push函数主要是通过观察头节点(这里的头节点即是<code>V</code>),然后构建一个新的节点(它代表<code>B</code>)放于栈顶,如果<code>V</code>没有发生变化,则进行更新.如果发生了变化(被其他线程修改),就重新尝试进行<code>CAS</code>操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Insert a new element to the this stack.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> if &#123;<span class="doctag">@code</span> true&#125; insert success,&#123;<span class="doctag">@code</span> false&#125; otherwise</div><div class="line"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> value&#125; is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">return</span> putAndReturnResult(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putAndReturnResult</span><span class="params">(E value)</span> </span>&#123;</div><div class="line">    Node&lt;E&gt; oldNode;</div><div class="line">    Node&lt;E&gt; newNode;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        oldNode = head.get();</div><div class="line">        newNode = <span class="keyword">new</span> Node&lt;E&gt;(value, oldNode);</div><div class="line">    &#125; <span class="keyword">while</span> (!head.compareAndSet(oldNode, newNode));</div><div class="line">    sizePlusOne();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop函数中的<code>CAS</code>操作的思想基本与push函数一致.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the element of stack top and remove this element.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if this stack is empty</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">return</span> removeAndReturnElement();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAndReturnElement</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;E&gt; oldNode;</div><div class="line">    Node&lt;E&gt; newNode;</div><div class="line">    E result;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        oldNode = head.get();</div><div class="line">        newNode = oldNode.next;</div><div class="line">        result = oldNode.value;</div><div class="line">    &#125; <span class="keyword">while</span> (!head.compareAndSet(oldNode, newNode));</div><div class="line">    sizeMinusOne();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<p>非阻塞的算法实现的复杂度要比阻塞算法复杂的多,但它能带来更少的性能开销,在<code>jdk</code>中,很多线程安全类都是在尽量地避免使用锁的基础上来实现线程安全.</p>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/05/29/2017-5-29-cas_concurrent_stack/" data-id="cj4z0jkcn0028uomjp4g1hgw8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-4-13-hash_table" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/13/2017-4-13-hash_table/" class="article-date">
  <time datetime="2017-04-13T10:00:00.000Z" itemprop="datePublished">2017-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/13/2017-4-13-hash_table/">《Algorithms,4th Edition》读书笔记-散列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>散列表</code>(<code>Hash Table</code>,也叫<code>哈希表</code>),它是根据键而直接访问在内存存储位置的数据结构.也可以说是用一个数组来实现的<strong>无序的符号表</strong>,将键作为数组的索引而数组中键<code>i</code>处存储的就是它对应的值.</p>
<p><code>散列表</code>通过<code>散列函数</code>将键转化为数组的索引来访问数组中的键值对.</p>
<p>在<code>散列表</code>的算法中,最重要的两个操作如下.</p>
<ol>
<li>使用<code>散列函数</code>将被查找的键转化为数组的一个索引.</li>
</ol>
<ol>
<li>处理散列表中的<code>碰撞冲突</code>问题.</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/hashing-crux.png" alt=""></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><hr>
<ul>
<li>若关键字为<code>k</code>,则其值存放于<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c36f16f5357aeb5b0fa2fe3040e74282d62f8881">的存储位置上.由此,不需要比较便可直接取得所查记录.称这个对应关系<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/132e57acb643253e7810ee9702d9581f159a1c61">为<code>散列函数</code>,按照这个思想建立的符合表为<code>散列表</code>.</li>
</ul>
<ul>
<li>对不同的键可能会得到同一个<code>散列地址</code>,即<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f2b910a452063a4769272110d8d22cab053d433d">,而<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fa1d43b27a17bf57baf12626ad7cfbf8ee9bb96d">,这种现象被称为<code>碰撞冲突</code>.具有相同函数值的键对该<code>散列函数</code>来说称做同义词.综上所述,根据散列函数<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c36f16f5357aeb5b0fa2fe3040e74282d62f8881">和处理<code>碰撞冲突</code>的方法将一组键映射到一个有限的连续的地址集(区间)上,这种表称为<code>散列表</code>,这一映射过程称为<code>散列</code>,所得的存储位置称为<code>散列地址</code>.</li>
</ul>
<ul>
<li>若对于键集合中的任一个键,经<code>散列函数</code>映射到地址集合中任何一个地址的概率是相等的,则这个<code>散列函数</code>被称为<code>均匀散列函数</code>,它可以减少<code>碰撞冲突</code>.</li>
</ul>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><hr>
<p><code>散列函数</code>用于将键转化为数组的索引.如果我们有一个能够保存M个键值对的数组,那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1]范围内的整数)的<code>散列函数</code></p>
<p><code>散列函数</code>与键的类型有关,对于每种类型的键都需要一个与之对应的<code>散列函数</code>.</p>
<h4 id="实现散列函数的几种方法"><a href="#实现散列函数的几种方法" class="headerlink" title="实现散列函数的几种方法"></a>实现散列函数的几种方法</h4><ul>
<li>直接定址法 : 取<code>key</code>或者<code>key</code>的某个线性函数值为<code>散列地址</code>.即<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/989ebc7db55ece5d29e2a8baa005e876ef486e4e">或<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/989ebc7db55ece5d29e2a8baa005e876ef486e4e">其中a,b为常数(这种<code>散列函数</code>叫做自身函数).</li>
</ul>
<ul>
<li>数字分析法 : 假设<code>key</code>是以<code>r</code>为基的数,并且<code>散列表</code>中可能出现的<code>key</code>都是事先知道的,则可取<code>key</code>的若干数位组成<code>散列地址</code>.</li>
</ul>
<ul>
<li>平方取中法 : 取<code>key</code>平方后的中间几位为<code>散列地址</code>.通常在选定<code>散列函数</code>时不一定能知道<code>key</code>的全部情况,取其中的哪几位也不一定合适,而一个数平方后的中间几位数和数的每一位都相关,由此使随机分布的<code>key</code>得到的<code>散列地址</code>也是随机的.取的位数由表长决定.</li>
</ul>
<ul>
<li>折叠法 : 将<code>key</code>分割成位数相同的几部分(最后一部分的位数可以不同),然后取这几部分的叠加和(舍去进位)作为<code>散列地址</code>.</li>
</ul>
<ul>
<li>除留余数法 : 取<code>key</code>被某个不大于<code>散列表</code>长度<code>m</code>的数<code>p</code>除后所得的余数为<code>散列地址</code>.即<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bc04a0c2f72156976761fa24dd4ba098855b7dca">,<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3aad2b022083cbc8aef0745526f3a448e7d96160">.不仅可以对<code>key</code>直接取模，也可在<code>折叠法</code>、<code>平方取中法</code>等运算之后取模。对<code>p</code>的选择很重要，一般取<code>素数</code>或<code>m</code>，若<code>p</code>选择不好，容易产生<code>碰撞冲突</code>.</li>
</ul>
<h4 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h4><p>将正整数<code>散列</code>一般使用的是<code>除留余数法</code>.我们选择大小为<strong>素数</strong><code>M</code>的数组,对于任意正整数<code>k</code>,计算<code>k</code>除以<code>M</code>的余数(即<code>k%M</code>).它能够有效地将<code>key</code>散布在0到M-1的范围内.</p>
<p>如果<code>M</code>不是<strong>素数</strong>,可能无法利用<code>key</code>中包含的所有信息,这<strong>可能导致无法均匀地散列散列值</strong>.</p>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/modular-hashing.png" alt=""></p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>对浮点数进行散列一般是将<code>key</code>表示为二进制数然后再使用<code>除留余数法</code>.</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>除留余数法</code>也可以处理较长的<code>key</code>,例如字符串,我们只需将它们当成大整数即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">   	hash = (R * hash + s.charAt(i)) % M;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java的<code>charAt()</code>函数能够返回一个char值,即一个非负16位整数.如果<code>R</code>比任何字符的值都大,这种计算相当于将字符串当作一个N位的<code>R</code>进制值,将它除以<code>M</code>并取余.只要<code>R</code>足够小,不造成溢出,那么结果就能够落在0至M-1之间.可以使用一个较小的素数,例如31.</p>
<h4 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h4><p>如果<code>key</code>的类型含有多个整型变量,我们可以和字符串类型一样将它们混合起来.</p>
<p>例如,<code>key</code>的类型为Date,其中含有几个整型的域 : day(两个数字表示的日),month(两个数字表示的月),year(四个数字表示的年).我们可以这样计算它的散列值: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = (((day * R + month) % M) * R + year) % M;</div></pre></td></tr></table></figure>
<h4 id="Java中的约定"><a href="#Java中的约定" class="headerlink" title="Java中的约定"></a>Java中的约定</h4><p>在Java中如果要为自定义的数据类型定义散列函数,需要同时重写<code>hashCode()</code>和<code>equals()</code>两个函数,并要遵守以下规则.</p>
<ul>
<li><code>hashCode()</code>与<code>equals()</code>的结果必须保持一致性.即<code>a.equals(b)</code>返回true,则<code>a.hashCode()</code>的返回值也必然和<code>b.hashCode()</code>的返回值相同.</li>
</ul>
<ul>
<li>但如果两个对象的<code>hashCode()</code>函数的返回值相同,这两个对象也有可能不同,还需要用<code>equals()</code>函数进行判断.</li>
</ul>
<p>一个使用<code>除留余数法</code>的简单<code>散列函数</code>如下,它会将符号位屏蔽(将一个32位整数变为一个31位非负整数).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h4><p>由于<code>散列函数</code>的计算有可能会很耗时,我们可以进行缓存优化,将每个<code>key</code>的散列值缓存起来(可以在每个<code>key</code>中使用一个hash变量来保存它的<code>hashCode()</code>的返回值).</p>
<p>当第一次调用<code>hashCode()</code>时,需要计算对象的散列值,但之后对<code>hashCode()</code>方法的调用会直接返回hash变量的值.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总之,要想实现一个优秀的<code>散列函数</code>需要满足以下的条件.</p>
<ol>
<li>一致性,等价的<code>key</code>必然产生相等的散列值.</li>
</ol>
<ol>
<li>.高效性,计算简便.</li>
</ol>
<ol>
<li>均匀性,均匀地散列所有的<code>key</code>.</li>
</ol>
<h3 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h3><hr>
<p>拉链法是解决<code>碰撞冲突</code>的一种策略,它的核心思想是 : 将大小为<code>M</code>的<strong>数组中的每个元素指向一条链表</strong>,链表中的每个节点都存储了散列值为该元素的索引的键值对.</p>
<p>拉链法的实现一般分为以下两种: </p>
<ol>
<li>使用一个原始的链表数据类型来表示数组中的每个元素.</li>
</ol>
<ol>
<li>使用一个符号表实现来表示数组中的每个元素(这个方法实现简单但效率偏低).</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/separate-chaining.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPACITY = <span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// the number of key-value pairs in the symbol table</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">// the number of size of separate chaining table</span></div><div class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table; <span class="comment">// array of linked-list symbol tables</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> K key;</div><div class="line">        <span class="keyword">private</span> V value;</div><div class="line">        <span class="keyword">private</span> Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ((key.hashCode()) &amp; <span class="number">0x7fffffff</span>) % m;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="查找、插入、删除"><a href="#查找、插入、删除" class="headerlink" title="查找、插入、删除"></a>查找、插入、删除</h4><p>基于拉链法的<code>散列表</code>的查找、插入、删除算法基本分为两步:</p>
<ol>
<li>首先根据散列值找到对应的链表.</li>
</ol>
<ol>
<li>然后沿着这条链表进行相应的操作.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called get() with key is null."</span>);</div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    Node x = table[i];</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (key.equals(x.key))</div><div class="line">            <span class="keyword">return</span> (V) x.value;</div><div class="line">        x = x.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with key is null."</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        remove(key);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// double table size if average length of list &gt;= 10</span></div><div class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">10</span> * m)</div><div class="line">        resize(<span class="number">2</span> * m);</div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    Node x = table[i];</div><div class="line">    Node p = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">            x.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        p = x;</div><div class="line">        x = x.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">        table[i] = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>);</div><div class="line">        n++;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p.next = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called remove() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called remove() with empty symbol table."</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!contains(key))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    Node x = table[i];</div><div class="line">    Node p = <span class="keyword">null</span>;</div><div class="line">    V oldValue = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">            oldValue = (V) x.value;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                table[i] = x.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                p.next = x.next;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        p = x;</div><div class="line">        x = x.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// halve table size if average length of list &lt;= 2</span></div><div class="line">    <span class="keyword">if</span> (m &gt; INIT_CAPACITY &amp;&amp; n &lt;= <span class="number">2</span> * m)</div><div class="line">        resize(m / <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于线性探测法的散列表"><a href="#基于线性探测法的散列表" class="headerlink" title="基于线性探测法的散列表"></a>基于线性探测法的散列表</h3><hr>
<p>解决<code>碰撞冲突</code>的另一种策略是使用线性探测法.它的核心思想是: 使用大小为<code>M</code>的数组保存<code>N</code>个键值对,其中<code>M&gt;N</code>.这种方法<strong>需要依靠数组中的空位来解决<code>碰撞冲突</code></strong>,基于这种策略的所有方法被统称为<code>开放地址散列表</code>.</p>
<p><code>开放地址散列表</code>中最简单的方法就是线性探测法: 当发生<code>碰撞冲突</code>时,我们直接检查<code>散列表</code>中的下一个位置(将索引值加1).它可能会产生三种结果: </p>
<ol>
<li>命中,该位置的<code>key</code>和被查找的<code>key</code>相同.</li>
</ol>
<ol>
<li>未命中,<code>key</code>为空(该位置没有<code>key</code>).</li>
</ol>
<ol>
<li>继续查找,该位置的<code>key</code>和被查找的<code>key</code>不同.</li>
</ol>
<p>我们使用<code>散列函数</code>找到<code>key</code>在数组中的索引,检查其中的<code>key</code>和被查找的<code>key</code>是否相同.如果不同则继续查找(将索引值加1,到达数组结尾时折回数组的开头),直到找到该<code>key</code>或者遇到一个空元素.</p>
<p><code>开放地址散列表</code>的核心思想是: 与其将内存用作链表,不如将它们作为在<code>散列表</code>的空元素(这些空元素可以作为查找结束的标识).</p>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/linear-probing.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPACITY = <span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// the number of key-value pairs in the symbol table</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">// the number of size of linear probing table</span></div><div class="line">    <span class="keyword">private</span> K[] keys; <span class="comment">// the keys</span></div><div class="line">    <span class="keyword">private</span> V[] vals; <span class="comment">// the values</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initializes an empty symbol table.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(INIT_CAPACITY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initializes an empty symbol table with the specified initial capacity.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> capacity the initial capacity</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        m = capacity;</div><div class="line">        n = <span class="number">0</span>;</div><div class="line">        keys = (K[]) <span class="keyword">new</span> Object[m];</div><div class="line">        vals = (V[]) <span class="keyword">new</span> Object[m];</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called get() with key is null."</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % m) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key))</div><div class="line">                <span class="keyword">return</span> vals[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with key is null."</span>);</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            delete(key);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// double table size if 50% full</span></div><div class="line">        <span class="keyword">if</span> (n &gt;= m / <span class="number">2</span>) resize(<span class="number">2</span> * m);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % m) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key)) &#123;</div><div class="line">                vals[i] = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        keys[i] = key;</div><div class="line">        vals[i] = value;</div><div class="line">        n++;</div><div class="line">    &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>基于线性探测法的<code>散列表</code>的删除操作较为复杂,我们不能直接将<code>key</code>所在的位置设为<code>null</code>,这样会使在此位置之后的元素无法被查找到.</p>
<p>因此,我们需要<strong>将被删除键的右侧的所有键重新插入到<code>散列表</code>中</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called delete() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called delete() with empty symbol table."</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!contains(key))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// find position i of key</span></div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    <span class="keyword">while</span> (!key.equals(keys[i])) &#123;</div><div class="line">        i = (i + <span class="number">1</span>) % m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    V oldValue = vals[i];</div><div class="line">    <span class="comment">// delete key and associated value</span></div><div class="line">    keys[i] = <span class="keyword">null</span>;</div><div class="line">    vals[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// rehash all keys in same cluster</span></div><div class="line">    i = (i + <span class="number">1</span>) % m;</div><div class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// delete keys[i] an vals[i] and reinsert</span></div><div class="line">        K keyToRehash = keys[i];</div><div class="line">        V valToRehash = vals[i];</div><div class="line">        keys[i] = <span class="keyword">null</span>;</div><div class="line">        vals[i] = <span class="keyword">null</span>;</div><div class="line">        n--;</div><div class="line">        put(keyToRehash, valToRehash);</div><div class="line">        i = (i + <span class="number">1</span>) % m;</div><div class="line">    &#125;</div><div class="line">    n--;</div><div class="line"></div><div class="line">    <span class="comment">// halves size of array if it's 12.5% full or less</span></div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= m / <span class="number">8</span>) resize(m / <span class="number">2</span>);</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="键簇"><a href="#键簇" class="headerlink" title="键簇"></a>键簇</h4><p>线性探测法的平均成本取决于元素在插入数组后聚集成的一组连续的条目,也叫作<code>键簇</code>.</p>
<p>显然,短小的<code>键簇</code>才能保证较高的效率.随着插入的<code>key</code>越来越多,这个要求会很难满足,较长的<code>键簇</code>会越来越多.<code>长键簇</code>的可能性要比<code>短键簇</code>更大,因为新键的散列值无论落在<code>键簇</code>的任何位置都会使它的长度加1.</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><hr>
<p><code>散列表</code>使用了适度的空间和时间并在这两个极端之间找到了一种平衡,所以它可以在一般应用中实现拥有(均摊后)常数级别的查找和插入操作的<code>符号表</code>.</p>
<p>但<code>散列表</code>是很难实现有序操作的,这是因为散列最主要的目的在于均匀地将键散布开来,因此在计算散列后键的顺序信息就已经丢失了.</p>
<p>同时,<code>散列表</code>的性能也依赖于<code>α=N/M</code>的比值,其中<code>α</code>称为<code>散列表</code>的使用率.对于<code>拉链法</code>来说,<code>α</code>是每条链表的长度,因此一般大于1.对于<code>线性探测法</code>来说,<code>α</code>是表中已被占用的空间的比例,它是不可能大于1的.</p>
<p><code>散列表</code>的性能虽然高效,但它也有以下的局限性: </p>
<ul>
<li>每种类型的键都需要一个优秀的<code>散列函数</code>.</li>
</ul>
<ul>
<li>性能保证来自于<code>散列函数</code>的质量.</li>
</ul>
<ul>
<li><code>散列函数</code>的计算可能复杂而且昂贵.</li>
</ul>
<ul>
<li>难以支持有序性相关的操作.</li>
</ul>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/6872abd0fad061de28466cb775a84cea" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>文中参考资料引用自<a href="http://algs4.cs.princeton.edu/34hash/" target="_blank" rel="external">&lt;<algorithms,4th edition="">&gt;</algorithms,4th></a> &amp; <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="external">Wikepedia</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/04/13/2017-4-13-hash_table/" data-id="cj4z0jkcl0023uomj6r6f98ya" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/符号表/">符号表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-4-08-avl_tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/08/2017-4-08-avl_tree/" class="article-date">
  <time datetime="2017-04-08T10:00:00.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/08/2017-4-08-avl_tree/">平衡查找树之AVL树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p><code>AVL树</code>得名于它的发明者G.M. Adelson-Velsky和E.M. Landis,它是最先发明的<code>自平衡二叉查找树</code>.</p>
<p>在<code>AVL树</code>中<strong>任何节点的两个子树的高度最大差别为一</strong>.并且,查找、插入、删除等操作在平均和最坏情况下都是<code>O(log n)</code>.</p>
<p><code>AVL树</code>的基本操作都与<code>二叉查找树</code>的算法一致,只有在插入、删除等这种会<strong>改变树的平衡性的操作需要使用一些<code>旋转操作</code>来修正树的平衡性</strong>.</p>
<h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><hr>
<p>节点的<code>平衡因子</code>一般是它的<code>左子树</code>的高度减去它的<code>右子树</code>的高度(相反也可以).带有<code>平衡因子</code>为1、0或-1的节点被认为是平衡的.带有<code>平衡因子</code>为-2或2的节点被认为是不平衡的.</p>
<p>计算树的高度与平衡因子的代码如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// calculate node x depth</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcDepth</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</div><div class="line">        depth = x.left.depth;</div><div class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span> &amp;&amp; x.right.depth &gt; depth)</div><div class="line">        depth = x.right.depth;</div><div class="line">    <span class="comment">// parent + left or right depth</span></div><div class="line">    depth++;</div><div class="line">    <span class="keyword">return</span> depth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// calculate node x balance(left.depth - right.depth)</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcBalance</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> leftDepth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> rightDepth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</div><div class="line">        leftDepth = x.left.depth;</div><div class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</div><div class="line">        rightDepth = x.right.depth;</div><div class="line">    <span class="keyword">return</span> leftDepth - rightDepth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><hr>
<p><code>旋转操作</code>是用于修复树的平衡性的,它保证了树的有序性与平衡性(旋转操作的具体讲解可以参考<a href="http://sylvanassun.github.io/2017/03/30/red_black_binary_search_tree/">《Algorithms,4th Edition》读书笔记-红黑二叉查找树</a>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    Node t = x.right;</div><div class="line">    x.right = t.left;</div><div class="line">    t.left = x;</div><div class="line">    <span class="keyword">if</span> (x.parent != <span class="keyword">null</span>) &#123;</div><div class="line">        t.parent = x.parent;</div><div class="line">        <span class="keyword">if</span> (x.parent.left == x)</div><div class="line">            x.parent.left = t;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            x.parent.right = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t.parent = <span class="keyword">null</span>;</div><div class="line">        root = t;</div><div class="line">    &#125;</div><div class="line">    x.parent = t;</div><div class="line">    <span class="comment">// calculate depth and balance</span></div><div class="line">    x.depth = calcDepth(x);</div><div class="line">    x.balance = calcBalance(x);</div><div class="line">    t.depth = calcDepth(t);</div><div class="line">    t.balance = calcBalance(t);</div><div class="line">    <span class="comment">// calculate size</span></div><div class="line">    t.size = x.size;</div><div class="line">    x.size = <span class="number">1</span> + size(x.left) + size(x.right);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    Node t = x.left;</div><div class="line">    x.left = t.right;</div><div class="line">    t.right = x;</div><div class="line">    <span class="keyword">if</span> (x.parent != <span class="keyword">null</span>) &#123;</div><div class="line">        t.parent = x.parent;</div><div class="line">        <span class="keyword">if</span> (x.parent.left == x)</div><div class="line">            x.parent.left = t;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            x.parent.right = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t.parent = <span class="keyword">null</span>;</div><div class="line">        root = t;</div><div class="line">    &#125;</div><div class="line">    x.parent = t;</div><div class="line">    <span class="comment">// calculate depth and balance</span></div><div class="line">    x.depth = calcDepth(x);</div><div class="line">    x.balance = calcBalance(x);</div><div class="line">    t.depth = calcDepth(t);</div><div class="line">    t.balance = calcBalance(t);</div><div class="line">    <span class="comment">// calculate size</span></div><div class="line">    t.size = x.size;</div><div class="line">    x.size = <span class="number">1</span> + size(x.left) + size(x.right);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="平衡修正"><a href="#平衡修正" class="headerlink" title="平衡修正"></a>平衡修正</h2><hr>
<p>当一个节点被认为是不平衡的时候,我们需要使用一些<code>旋转操作</code>来修正树的平衡,一般有以下情况需要进行<code>旋转</code>.</p>
<ul>
<li>例如当前节点为<code>x</code>,对<code>x</code>进行平衡修正需要进行以下判断.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>平衡因子</code>大于等于2时(左子树高度偏高),对其进行<code>右旋转</code>.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>左子树</code>的<code>平衡因子</code>等于-1时(左子树的右子节点高度偏高),对<code>x</code>的<code>左子树</code>进行<code>左旋转</code>.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>平衡因子</code>小于等于-2时(右子树高度偏高),对其进行<code>左旋转</code>.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>右子树</code>的<code>平衡因子</code>等于1时(右子树的左子节点高度偏高),对<code>x</code>的<code>右子树</code>进行<code>右旋转</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">balance</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        x.depth = calcDepth(x);</div><div class="line">        x.balance = calcBalance(x);</div><div class="line">        <span class="comment">// if x left subtree high,rotateRight</span></div><div class="line">        <span class="keyword">if</span> (x.balance &gt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">// if x.left.right high,rotateLeft</span></div><div class="line">            <span class="keyword">if</span> (x.left != <span class="keyword">null</span> &amp;&amp; x.left.balance == -<span class="number">1</span>) &#123;</div><div class="line">                x.left = rotateLeft(x.left);</div><div class="line">            &#125;</div><div class="line">            x = rotateRight(x);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// if x right subtree high,rotateLeft</span></div><div class="line">        <span class="keyword">if</span> (x.balance &lt;= -<span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">// if x.right.left high,rotateRight</span></div><div class="line">            <span class="keyword">if</span> (x.right != <span class="keyword">null</span> &amp;&amp; x.right.balance == <span class="number">1</span>) &#123;</div><div class="line">                x.right = rotateRight(x.right);</div><div class="line">            &#125;</div><div class="line">            x = rotateLeft(x);</div><div class="line">        &#125;</div><div class="line">        x.size = <span class="number">1</span> + size(x.left) + size(x.right);</div><div class="line">        x = x.parent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><hr>
<p><code>AVL树</code>的插入和删除与<code>二分查找树</code>的算法一致,只不过在完成插入后需要自底向上的修复平衡性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        remove(key);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    put(root, key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Node x, K key, V value)</span> </span>&#123;</div><div class="line">    Node parent = x;</div><div class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        parent = x;</div><div class="line">        cmp = key.compareTo(x.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</div><div class="line">            x = x.left;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</div><div class="line">            x = x.right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            x.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// if not find key,create new node</span></div><div class="line">    x = <span class="keyword">new</span> Node(key, value, <span class="number">1</span>, parent);</div><div class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            parent.left = x;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            parent.right = x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        root = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// fixup balance</span></div><div class="line">    balance(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/780045c5b8705ef225eb83c58a013949" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>本文参考资料引用自<a href="https://en.wikipedia.org/wiki/AVL_tree" target="_blank" rel="external">Wikipedia</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/04/08/2017-4-08-avl_tree/" data-id="cj4z0jkcm0026uomj1t85hngh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/符号表/">符号表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-3-30-red_black_binary_search_tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/30/2017-3-30-red_black_binary_search_tree/" class="article-date">
  <time datetime="2017-03-30T10:00:00.000Z" itemprop="datePublished">2017-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/30/2017-3-30-red_black_binary_search_tree/">《Algorithms,4th Edition》读书笔记-红黑二叉查找树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><code>红黑二叉查找树</code>是<code>2-3查找树</code>的简单表示方式,它的代码量并不大,并且保证了平衡性.<br>阅读本文前需先了解 <a href="http://sylvanassun.github.io/2017/03/28/2_3tree/">《Algorithms,4th Edition》读书笔记-2-3查找树</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p><code>红黑树</code>是一种自平衡的<code>二叉查找树</code>,它的基本思想是<strong>用标准的<code>二叉查找树</code>(完全由<code>2-节点</code>构成)和一些额外的信息(替换<code>3-节点</code>)来表示<code>2-3树</code>.</strong> 可以说<code>红黑树</code>是<code>2-3树</code>的一种等同.</p>
<p><code>红黑树</code>中的链接可以分为两种类型: </p>
<ul>
<li><strong>红链接</strong> : 它将两个<code>2-节点</code>连接起来构成一个<code>3-节点</code>(也可以说是将<code>3-节点</code>表示为由一条<strong>红色左链接</strong>(两个<code>2-节点</code>其中之一是另一个的左子节点)相连的两个<code>2-节点</code>).</li>
</ul>
<ul>
<li><strong>黑链接</strong> : 表示<code>2-3树</code>中的普通链接.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-encoding.png" alt=""></p>
<p>这种表示方式带来的优点如下: </p>
<ol>
<li>无需修改就可以直接使用标准的<code>二叉查找树</code>中的查找方法(其他与链接颜色不关联的方法也可以直接使用).</li>
</ol>
<ol>
<li>对于任意的<code>2-3树</code>,只要对节点进行转换,我们都可以立即派生出一棵对应的<code>二叉查找树</code>.</li>
</ol>
<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><hr>
<p><code>红黑树</code>是含有红黑链接并满足下列条件的<code>二叉查找树</code>(满足这些条件的<code>红黑树</code>才是与相应的<code>2-3树</code>一一对应的).</p>
<ul>
<li>红链接均为左链接(这条仅限于偏向左红链接实现的<code>红黑树</code>).</li>
</ul>
<ul>
<li>每个节点不是红色就是黑色的.</li>
</ul>
<ul>
<li>没有任何一个节点同时和两条红链接相连(不可以有两条连续的红链接).</li>
</ul>
<ul>
<li>该树是完美黑色平衡的,即<strong>任意空链接到根节点的路径上的黑链接数量相同.</strong></li>
</ul>
<ul>
<li><code>根节点</code>是黑色的.</li>
</ul>
<ul>
<li>所有<code>叶子节点</code>(即null节点)的颜色是黑色的.</li>
</ul>
<h2 id="与2-3树的对应关系"><a href="#与2-3树的对应关系" class="headerlink" title="与2-3树的对应关系"></a>与2-3树的对应关系</h2><hr>
<p>假如我们将一棵<code>红黑树</code>中的红链接画平,我们会发现所有的空链接到根节点的距离都将是相同的.如果再把由红链接相连的节点合并,得到的就是一棵<code>2-3树</code>.</p>
<p>相对的,如果将一棵<code>2-3树</code>中的<code>3-节点</code>画作由红色左链接相连的两个<code>2-节点</code>,那么不会存在能够和两条红链接相连的节点,且树必然是完美黑色平衡的,因为黑链接就是<code>2-3树</code>中的普通链接,根据定义这些链接必然是完美平衡的.</p>
<p>通过这些结论,我们<strong>可以发现<code>红黑树</code>即是<code>二叉查找树</code>,也是<code>2-3树</code>.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-1-1.png" alt=""></p>
<h2 id="节点的实现"><a href="#节点的实现" class="headerlink" title="节点的实现"></a>节点的实现</h2><hr>
<p>我们使用<code>boolean</code>类型的变量<code>color</code>来表示链接的颜色.如果指向它的链接为红色,则<code>color</code>变量为<code>true</code>,黑色则为<code>false</code>(空链接也为黑色).</p>
<p>并且定义了一个<code>isRed()</code>函数用于判断链接的颜色.</p>
<p>这里节点的<strong>颜色指的是指向该节点的链接的颜色.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-color.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Node root; <span class="comment">// root node</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> K key;</div><div class="line">      <span class="keyword">private</span> V value;</div><div class="line">      <span class="keyword">private</span> Node left, right; <span class="comment">// links to left and right subtress</span></div><div class="line">      <span class="keyword">private</span> <span class="keyword">boolean</span> color; <span class="comment">// color of parent link</span></div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// subtree count</span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, <span class="keyword">boolean</span> color, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.key = key;</div><div class="line">          <span class="keyword">this</span>.value = value;</div><div class="line">          <span class="keyword">this</span>.color = color;</div><div class="line">          <span class="keyword">this</span>.size = size;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">	</div><div class="line"><span class="comment">// node x is red? if x is null return false.</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> x.color == RED;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><hr>
<p>当我们在实现某些操作时,可能会产生一些红色右链接或者两条连续的红色左链接.这时就需要在操作完成前进行旋转操作来修复<code>红黑树</code>的平衡性(<strong>旋转操作会改变红链接的指向</strong>).</p>
<p>旋转操作保证了<code>红黑树</code>的两个重要性质 : <strong>有序性</strong>和<strong>完美平衡性</strong>. </p>
<h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><p>假设当前有一条红色右链接需要被修正旋转为左链接.这个操作叫做<code>左旋转</code>.</p>
<p><code>左旋转</code>函数接受一条指向<code>红黑树</code>中的某个节点的链接作为参数.然后<strong>会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根节点的链接.</strong></p>
<p>也可以认为是<strong>将用两个键中的较小者作为根节点变为将较大者作为根节点</strong>(右旋转中逻辑相反).</p>
<p>旋转操作返回的链接可能是左链接也可能是右链接,这个链接可能是红色也可能是黑色的(在实现中我们使用<code>x.color = h.color</code>保留了它原本的颜色).这<strong>可能会产生两条连续的红链接,但算法会在后续操作中继续使用旋转操作修正这种情况.</strong></p>
<p><strong>旋转操作只影响了根节点</strong>(返回的节点的子树中的所有键和旋转前都相同,只有根节点发生了变化).</p>
<p>具体的实现如下图: </p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-left-rotate.png" alt=""></p>
<h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><p>实现<code>右旋转</code>的逻辑基本与<code>左旋转</code>相同,只需要将<code>left</code>和<code>right</code>互换即可.</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-right-rotate.png" alt=""></p>
<h2 id="颜色转换"><a href="#颜色转换" class="headerlink" title="颜色转换"></a>颜色转换</h2><hr>
<p>颜色转换操作也是用于保证<code>红黑树</code>的性质的.<strong>它将<code>父节点</code>的颜色由黑变红,将<code>子节点</code>的颜色由红变黑.</strong></p>
<p>这项操作与旋转操作一样是局部变换,<strong>不会影响整棵树的黑色平衡性.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/color-flip.png" alt=""></p>
<h4 id="根节点总是为黑"><a href="#根节点总是为黑" class="headerlink" title="根节点总是为黑"></a>根节点总是为黑</h4><p>颜色转换可能会使<code>根节点</code>变为红色,但红色的<code>根节点</code>说明<code>根节点</code>是一个<code>3-节点</code>的一部分,实际情况并不是这样的.所以我们需要将<code>根节点</code>设为黑色.</p>
<p><strong>每当<code>根节点</code>由红变黑时,树的黑链接高度就会加1.</strong></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><hr>
<p>在<code>红黑树</code>中实现插入操作是比较复杂的,因为需要保持<code>红黑树</code>的平衡性.但只要利用好<code>左旋转</code>、<code>右旋转</code>、<code>颜色转换</code>这三个辅助操作,就能够保证插入操作后树的平衡性.</p>
<h4 id="向单个2-节点中插入新键"><a href="#向单个2-节点中插入新键" class="headerlink" title="向单个2-节点中插入新键"></a>向单个2-节点中插入新键</h4><p>当一棵只含有一个键的<code>红黑树</code>只含有一个<code>2-节点</code>时,插入另一个键后需要马上进行<code>旋转</code>操作修正树的平衡性.</p>
<ul>
<li>如果新键小于老键,只需要新增一个红色的节点即可(这时,新的<code>红黑树</code>等价于一个<code>3-节点</code>).</li>
</ul>
<ul>
<li>如果新键大于老键,那么新增的红色节点将会产生一条红色的右链接,这时就需要使用<code>左旋转</code>修正根节点的链接.</li>
</ul>
<ul>
<li>以上两种情况最终的结果均为一棵等价于单个<code>3-节点</code>的<code>红黑树</code>,它含有两个键,一条红链接,树的黑链接高度为1.</li>
</ul>
<h4 id="向树底部的2-节点插入新键"><a href="#向树底部的2-节点插入新键" class="headerlink" title="向树底部的2-节点插入新键"></a>向树底部的2-节点插入新键</h4><p>和<code>二叉查找树</code>一样,向<code>红黑树</code>中插入一个新键会在树的底部新增一个节点,但<strong>在<code>红黑树</code>中总是用红链接将新节点和它的父节点相连.</strong></p>
<p>如果它的父节点是一个<code>2-节点</code>,那么上一节讨论的方法依然适用.</p>
<ul>
<li>如果指向新节点的是父节点的左链接,那么父节点就直接成为一个<code>3-节点</code>.</li>
</ul>
<ul>
<li>如果指向新节点的是父节点的右链接,那么就需要一次<code>左旋转</code>进行修正.</li>
</ul>
<h4 id="向一棵双键树-一个3-节点-中插入新键"><a href="#向一棵双键树-一个3-节点-中插入新键" class="headerlink" title="向一棵双键树(一个3-节点)中插入新键"></a>向一棵双键树(一个3-节点)中插入新键</h4><p>当向一个<code>3-节点</code>中插入新键时,会发生以下三种情况且每种情况都会产生一个同时连接到两条红链接的节点,我们需要修正这一点.</p>
<ul>
<li>如果<code>新键大于原树中的两个键</code> : 这是最容易处理的一种情况,这个<strong>键会被连接到<code>3-节点</code>的右链接</strong>.此时树是平衡的,<strong>根节点为中间大小的键</strong>,它有<strong>两条红链接分别和较小和较大的节点相连</strong>.只需要<strong>把这两条链接的颜色都由红变黑,那么就可以得到一棵由三个节点组成、高度为2的平衡树</strong>(其他两种情况最终也会转化为这样的树).</li>
</ul>
<ul>
<li>如果<code>新键小于原树中的两个键</code> : 这个<strong>键会被连接到最左边的空链接,这样就产生了两条连续的红链接.</strong>此时<strong>只需要将上层的红链接<code>右旋转</code>即可得到第一种情况</strong>(中值键为根节点并和其他两个节点用红链接相连).</li>
</ul>
<ul>
<li>如果<code>新键介于原树中的两个键之间</code> : 这种情况依然<strong>会产生两条连续的红链接:一条红色左链接接一条红色右链接.</strong>此时<strong>只需要将下层的红链接<code>左旋转</code>即可得到第二种情况</strong>(两条连续的红色左链接).</li>
</ul>
<p>通过以上这三种情况可以总结出 : 我们只需要通过0次、1次、2次旋转以及颜色转换就可以完成对<code>红黑树</code>的修正.</p>
<h4 id="将红链接向上传递"><a href="#将红链接向上传递" class="headerlink" title="将红链接向上传递"></a>将红链接向上传递</h4><p>当每次旋转操作之后都会进行<code>颜色转换</code>,它会使得中间节点变为红色.<strong>从父节点的角度来看,处理这样一个红色节点的方式和处理一个新插入的红色节点完全相同</strong>(继续将红链接转移到中间节点).</p>
<p>这个操作对应于<code>2-3树</code>中向<code>3-节点</code>进行插入的操作 : 即在一个<code>3-节点</code>下插入新键,需要创建一个临时的<code>4-节点</code>,将其分解并将中间键插入父节点(在<code>红黑树</code>中,是将红链接由中间键传递给它的父节点).重复这个过程,直至遇到一个<code>2-节点</code>或者根节点.</p>
<p>当根节点变为红色时需要将根节点的颜色转换为黑色(对应<code>2-3树</code>中的根节点分解).</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>插入操作的实现除了每次递归调用之后的对平衡性修正的操作,其他与<code>二叉查找树</code>中的插入操作没什么不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to put() is null"</span>);</div><div class="line">    <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</div><div class="line">        delete(key);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    root = put(root, key, val);</div><div class="line">    root.color = BLACK;</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// insert the key-value pair in the subtree rooted at h</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, K key, V val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cmp = key.compareTo(h.key);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) h.left = put(h.left, key, val);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right, key, val);</div><div class="line">    <span class="keyword">else</span> h.value = val;</div><div class="line"></div><div class="line">    <span class="comment">// fix-up any right-leaning links</span></div><div class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);</div><div class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</div><div class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);</div><div class="line">    h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>只要在沿着插入点到根节点的路径向上移动时<strong>在所经过的每个节点中顺序完成以下操作</strong>,就能够实现<code>红黑树</code>的插入操作.</p>
<ul>
<li>如果<code>右子节点</code>是红色的而<code>左子节点</code>是黑色的,那么进行<code>左旋转</code>.</li>
</ul>
<ul>
<li>如果<code>左子节点</code>是红色的而且它的<code>左子节点</code>也是红色的,那么进行<code>右旋转</code>.</li>
</ul>
<ul>
<li>如果<code>左右子节点</code>都是红色的,那么进行<code>颜色转换</code>.</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><hr>
<p>删除操作也需要定义一系列<code>局部变换</code>来在<strong>删除一个节点的同时保持树的完美平衡性</strong>.然而,这个过程要比插入操作还要复杂,它<strong>不仅要在(为了删除一个节点而)构造临时<code>4-节点</code>时沿着查找路径向下进行变换,还要在分解遗留的<code>4-节点</code>时沿着查找路径向上进行变换(同插入操作)</strong>.</p>
<h4 id="自顶向下的2-3-4树"><a href="#自顶向下的2-3-4树" class="headerlink" title="自顶向下的2-3-4树"></a>自顶向下的2-3-4树</h4><p><code>2-3-4树</code>是一种允许存在<code>4-节点</code>的树.它的插入算法就是一种沿着查找路径既能向上也能向下进行变换的算法.</p>
<ul>
<li>沿查找路径向下进行变换(向下变换与<code>2-3树</code>中分解<code>4-节点</code>所进行的变换完全相同)是为了保证当前节点不是<code>4-节点</code>(这样树的底部才有足够的空间插入新的键).</li>
</ul>
<ul>
<li>沿查找路径向上进行变换是为了将之前创建的<code>4-节点</code>配平.</li>
</ul>
<ul>
<li>如果<code>根节点</code>是一个<code>4-节点</code>,就将它分解成三个<code>2-节点</code>,树的高度加1.</li>
</ul>
<ul>
<li>如果在向下查找的过程中,遇到了一个<code>父节点</code>为<code>2-节点</code>的<code>4-节点</code>,就将<code>4-节点</code>分解为两个<code>2-节点</code>并将<code>中间键</code>传递给它的<code>父节点</code>(这时<code>父节点</code>变为了一个<code>3-节点</code>).</li>
</ul>
<ul>
<li>如果遇到了一个<code>父节点</code>为<code>3-节点</code>的<code>4-节点</code>,将<code>4-节点</code>分解为两个<code>2-节点</code>并将<code>中间键</code>传递给它的<code>父节点</code>(这时<code>父节点</code>变为了一个<code>4-节点</code>).</li>
</ul>
<ul>
<li>不必担心遇见<code>父节点</code>为<code>4-节点</code>的<code>4-节点</code>,算法本身保证了不会出现这种情况,到达树的底部之后,只会遇到<code>2-节点</code>或者<code>3-节点</code>.</li>
</ul>
<p>如果要使用<code>红黑树</code>来实现这个算法,需要以下步骤 : </p>
<ul>
<li>将<code>4-节点</code>表示为由三个<code>2-节点</code>组成的一棵平衡的子树,<code>根节点</code>和两个子节点都用红链接相连.</li>
</ul>
<ul>
<li>在向下的过程中分解所有<code>4-节点</code>并进行<code>颜色转换</code>.</li>
</ul>
<ul>
<li>在向上的过程中使用<code>旋转</code>将<code>4-节点</code>配平.</li>
</ul>
<p>只需要将插入一节中的<code>put()</code>实现方法里的<code>flipColors</code>语句(及其if语句)移动到递归调用之前(null判断和比较操作之间)就能实现<code>2-3-4树</code>的插入操作.</p>
<h4 id="删除最小键"><a href="#删除最小键" class="headerlink" title="删除最小键"></a>删除最小键</h4><p>从<code>2-节点</code>中删除一个键会留下一个空节点,一般会将它替换为一个空链接,但这样会破坏树的完美平衡性.所以在删除操作中,<strong>为了避免删除一个<code>2-节点</code>,我们沿着<code>左链接</code>向下进行变换时,需要确保当前节点不是<code>2-节点</code></strong>.</p>
<p><code>根节点</code>可能有以下两种情况:</p>
<ol>
<li>如果<code>根节点</code>是一个<code>2-节点</code>且它的两个子节点都是<code>2-节点</code>,可以直接将这三个节点变成一个<code>4-节点</code>.</li>
</ol>
<ol>
<li>否则,需要保证<code>根节点</code>的左子节点不是<code>2-节点</code>,必要时可以从它右侧的兄弟节点借走一个键.</li>
</ol>
<p>在沿着<code>左链接</code>向下的过程中,保证以下情况之一成立: </p>
<ul>
<li>如果当前节点的左子节点不是<code>2-节点</code>.</li>
</ul>
<ul>
<li>如果当前节点的左子节点是<code>2-节点</code>而它的兄弟节点不是<code>2-节点</code>,将左子节点的兄弟节点中的一个键移动到左子节点中</li>
</ul>
<ul>
<li>如果当前节点的左子节点和它的兄弟节点都是<code>2-节点</code>,将左子节点、父节点中的最小键和左子节点最近的兄弟节点合并为一个<code>4-节点</code>,使父节点由<code>3-节点</code>变为<code>2-节点</code>(或是从<code>4-节点</code>变为<code>3-节点</code>).</li>
</ul>
<p>只要保证了以上的条件,我们最终能够得到一个含有最小键的<code>3-节点</code>或<code>4-节点</code>(然后进行删除即可),之后再不断向上分解所有临时的<code>4-节点</code>.</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>在删除操作中,<code>颜色转换</code>的操作与插入操作中的实现略微有些不同(需要将父节点设为黑,而将两个子节点设为红).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       h.color = !h.color;</div><div class="line">       h.left.color = !h.left.color;</div><div class="line">       h.right.color = !h.right.color;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// restore red-black tree invariant</span></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">balance</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isRed(h.right)) h = rotateLeft(h);</div><div class="line">       <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</div><div class="line">       <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);</div><div class="line"></div><div class="line">       h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</div><div class="line">       <span class="keyword">return</span> h;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Assuming that h is red and both h.left and h.left.left</span></div><div class="line">   <span class="comment">// are black, make h.left or one of its children red.</span></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">moveRedLeft</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       flipColors(h);</div><div class="line">       <span class="keyword">if</span> (isRed(h.right.left)) &#123;</div><div class="line">           h.right = rotateRight(h.right);</div><div class="line">           h = rotateLeft(h);</div><div class="line">           flipColors(h);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> h;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"RedBlackBST underflow."</span>);</div><div class="line"></div><div class="line">       <span class="comment">// if both children of root are black, set root to red</span></div><div class="line">       <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</div><div class="line">           root.color = RED;</div><div class="line"></div><div class="line">       root = deleteMin(root);</div><div class="line">       <span class="keyword">if</span> (!isEmpty())</div><div class="line">           root.color = BLACK;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// delete the key-value pair with the minimum key rooted at h</span></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (h.left == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</div><div class="line">           h = moveRedLeft(h);</div><div class="line"></div><div class="line">       h.left = deleteMin(h.left);</div><div class="line">       <span class="keyword">return</span> balance(h);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="删除最大键"><a href="#删除最大键" class="headerlink" title="删除最大键"></a>删除最大键</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Assuming that h is red and both h.right and h.right.left</span></div><div class="line"><span class="comment">// are black, make h.right or one of its children red.</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">moveRedRight</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">    flipColors(h);</div><div class="line">    <span class="keyword">if</span> (isRed(h.left.left)) &#123;</div><div class="line">        h = rotateRight(h);</div><div class="line">        flipColors(h);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"RedBlackBST underflow."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// if both children of root are black, set root to red</span></div><div class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</div><div class="line">        root.color = RED;</div><div class="line"></div><div class="line">    root = deleteMax(root);</div><div class="line">    <span class="keyword">if</span> (!isEmpty())</div><div class="line">        root.color = BLACK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// delete the key-value pair with the maximum key rooted at h</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isRed(h.left))</div><div class="line">        h = rotateRight(h);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (h.right == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</div><div class="line">        h = moveRedRight(h);</div><div class="line"></div><div class="line">    h.right = deleteMax(h.right);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> balance(h);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>同样也需要像删除最小键那样在查找路径上进行变换来保证查找过程中任意当前节点均不是<code>2-节点</code>.如果目标键在树的底部,可以直接删除它;如果不在,则需要将它和它的后继节点交换.</p>
<p>在删除操作之后需要向上变换分解余下的<code>4-节点</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called delete() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (!contains(key)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// if both children of root are black, set root to red</span></div><div class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</div><div class="line">        root.color = RED;</div><div class="line"></div><div class="line">    root = delete(root, key);</div><div class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// delete the key-value pair with the given key rooted at h</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node h, K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key.compareTo(h.key) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</div><div class="line">            h = moveRedLeft(h);</div><div class="line">        h.left = delete(h.left, key);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (isRed(h.left))</div><div class="line">            h = rotateRight(h);</div><div class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span> &amp;&amp; (h.right == <span class="keyword">null</span>))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</div><div class="line">            h = moveRedRight(h);</div><div class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span>) &#123;</div><div class="line">            Node x = min(h.right);</div><div class="line">            h.key = x.key;</div><div class="line">            h.value = x.value;</div><div class="line">            h.right = deleteMin(h.right);</div><div class="line">        &#125; <span class="keyword">else</span> h.right = delete(h.right, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> balance(h);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><hr>
<p>无论键的插入顺序如何,<code>红黑树</code>都几乎是完美平衡的,基于它实现的有序符号表操作的运行时间均为对数级别(除了范围查询).</p>
<p>在<code>红黑树</code>的实现中复杂的代码仅限于<code>put()</code>和<code>delete()</code>方法,像<code>get()</code>这些不会涉及检查颜色的方法与<code>二叉查找树</code>中的实现一致(因为这些操作与平衡性无关).</p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/731a1438c61492628cfaa1e9e618ecfb" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>本文参考资料引用自<a href="http://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="external">《Algorithms,4th Editio》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sylvanassun.github.io/2017/03/30/2017-3-30-red_black_binary_search_tree/" data-id="cj4z0jkcp002buomje9t6b7s4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2017/">2017</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/符号表/">符号表</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2017/">2017</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lucene/">Lucene</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyCat/">MyCat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solr/">solr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全文检索引擎/">全文检索引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端开发/">后端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/符号表/">符号表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程思想/">编程思想</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/2017/" style="font-size: 17.78px;">2017</a> <a href="/tags/ActiveMQ/" style="font-size: 10px;">ActiveMQ</a> <a href="/tags/Hadoop/" style="font-size: 14.44px;">Hadoop</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 18.89px;">Java</a> <a href="/tags/Lucene/" style="font-size: 10px;">Lucene</a> <a href="/tags/MyBatis/" style="font-size: 12.22px;">MyBatis</a> <a href="/tags/MyCat/" style="font-size: 10px;">MyCat</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Spring/" style="font-size: 15.56px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 11.11px;">SpringMVC</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/全文检索引擎/" style="font-size: 11.11px;">全文检索引擎</a> <a href="/tags/后端开发/" style="font-size: 20px;">后端开发</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/大数据/" style="font-size: 14.44px;">大数据</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/符号表/" style="font-size: 13.33px;">符号表</a> <a href="/tags/算法/" style="font-size: 13.33px;">算法</a> <a href="/tags/编程思想/" style="font-size: 10px;">编程思想</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/27/2017-06-27-DynamicProgramming/">什么是动态规划?</a>
          </li>
        
          <li>
            <a href="/2017/06/16/2017-06-16-RedBlackTree/">红黑树那点事儿</a>
          </li>
        
          <li>
            <a href="/2017/06/14/2017-06-14-sort_algorithms_qucikSort/">深入浅出排序算法(3)-快速排序</a>
          </li>
        
          <li>
            <a href="/2017/06/12/2017-06-12-sort_algorithmes_mergeSort/">深入浅出排序算法(2)-归并排序</a>
          </li>
        
          <li>
            <a href="/2017/06/09/2017-06-09-sort_algorithms_heapSort/">深入浅出排序算法(1)-堆排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 SylvanasSun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>