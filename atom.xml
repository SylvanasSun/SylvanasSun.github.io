<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SylvanasSun Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sylvanassun.github.io/"/>
  <updated>2017-07-30T11:33:20.418Z</updated>
  <id>https://sylvanassun.github.io/</id>
  
  <author>
    <name>SylvanasSun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/"/>
    <id>https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/</id>
    <published>2017-07-30T11:34:09.681Z</published>
    <updated>2017-07-30T11:33:20.418Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Java中的闭包之争<br>date: 2017-07-30 18:00<br>author: “Sylvanas Sun”<br>catalog: true<br>categories: [“后端”,”Java”]<br>tags: [“Java”,”2017”]</p>
<h2 id="notebook-Blog-Note"><a href="#notebook-Blog-Note" class="headerlink" title="notebook: Blog Note"></a>notebook: Blog Note</h2><blockquote>
<p>闭包一直都是<code>Java</code>社区中争论不断的话题,很多语言例如<code>JavaScript</code>,<code>Ruby</code>,<code>Python</code>等都支持闭包这个语言特性,闭包功能强大且灵活,<code>Java</code>并没有显式地支持它,但其实<code>Java</code>中也存在着所谓的”闭包”.</p>
</blockquote>
<hr>
<blockquote>
<p>本文作者为: <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a>.转载请务必将下面这段话置于文章开头处(保留超链接).<br>本文转发自<a href="https:/sylvanassun.github.io" target="_blank" rel="external">SylvanasSun Blog</a>,原文链接: <a href="https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/">https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/</a></p>
</blockquote>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><hr>
<p>定义一个闭包的要点如下: </p>
<ul>
<li>一个依赖于外部环境的<code>自由变量</code>的函数.</li>
</ul>
<ul>
<li>这个函数能够访问外部环境的<code>自由变量</code>.</li>
</ul>
<p>也就是说,<strong>外部环境持有内部函数所依赖的<code>自由变量</code>,由此对内部函数形成了闭包.</strong></p>
<h4 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h4><hr>
<p>那么什么是<code>自由变量</code>呢?<strong><code>自由变量</code>就是在函数自身作用域之外的变量</strong>,一个函数$f(x) = x + y$,其中<code>y</code>就是<code>自由变量</code>,它并不是这个函数自身的自变量,而是通过外部环境提供的.</p>
<p>下面以<code>JavaScript</code>的一个闭包为例: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> x + y;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于内部函数<code>function(x)</code>来说,<code>y</code>就是<code>自由变量</code>.而<code>y</code>是函数<code>Add(y)</code>内的参数,所以<code>Add(y)</code>对内部函数<code>function(x)</code>形成了一个闭包.</p>
<p>这个闭包将<code>自由变量y</code>与内部函数绑定在了一起,也就是说,当<code>Add(y)</code>函数执行完毕后,它不会随着函数调用结束后被回收(不能在栈上分配空间).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add_function = Add(<span class="number">5</span>); <span class="comment">// 这时y=5,并且与返回的内部函数绑定在了一起</span></div><div class="line"><span class="keyword">var</span> result = add_function(<span class="number">10</span>); <span class="comment">// x=10,返回最终的结果 10 + 5 = 15</span></div></pre></td></tr></table></figure>
<h3 id="Java中的闭包"><a href="#Java中的闭包" class="headerlink" title="Java中的闭包"></a>Java中的闭包</h3><hr>
<p><code>Java</code>与<code>JavaScript</code>又或者其他支持闭包的语言不同,它是一个基于类的面向对象语言,也就是说<strong>一个方法所用到的<code>自由变量</code>永远都来自于其所在类的实例的.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddUtils</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">5</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	retrun x + y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个方法<code>add(x)</code>拥有一个参数<code>x</code>与一个<code>自由变量y</code>,它的返回值也依赖于这个<code>自由变量y</code>.<code>add(x)</code>想要正常工作的话,就必须依赖于<code>AddUtils</code>类的一个实例,不然它无法知道<code>自由变量y</code>的值是多少,也就是<code>自由变量</code>未与<code>add(x)</code>进行绑定.</p>
<p>严格上来说,<code>add(x)</code>中的<code>自由变量</code>应该为<code>this</code>,这是因为<code>y</code>也是通过<code>this</code>关键字来访问的.</p>
<p>所以说,在<code>Java</code>中闭包其实无处不在,只不过我们难以发现而已.但面向对象的语言一般都不把类叫成闭包,这是一种习惯.</p>
<p><code>Java</code>中的内部类就是一种典型的闭包结构.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">5</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> x + y;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部类通过一个指向外部类的引用来访问外部环境中的<code>自由变量</code>,由此形成了一个闭包.</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">AnonInner</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> AnonInner <span class="title">getAnonInner</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">5</span>;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnonInner() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> x + y;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getAnonInner(x)</code>方法返回了一个匿名内部类<code>AnonInner</code>,匿名内部类不能显式地声明构造函数,也不能对构造函数传参,且返回的是一个<code>AnonInner</code>接口,但它的<code>add()</code>方法实现中用到了两个<code>自由变量</code>(<code>x</code>与<code>y</code>),也就是说外部方法<code>getAnonInner(x)</code>对这个匿名内部类构成了闭包.</p>
<p>但我们发现<code>自由变量</code>都被加上了<code>final</code>修饰符,这是因为<code>Java</code>对闭包支持的不完整导致的.</p>
<p>对于<code>自由变量</code>的捕获策略有以下两种: </p>
<ul>
<li>capture-by-value: 只需要在创建闭包的地方把捕获的值拷贝一份到对象里即可.<code>Java</code>的匿名内部类和<code>Java 8</code>新的<code>lambda</code>表达式都是这样实现的.</li>
</ul>
<ul>
<li>capture-by-reference: 把被捕获的局部变量“提升”（hoist）到对象里.<code>C#</code>的匿名函数(匿名委托/lambda表达式)就是这样实现的.</li>
</ul>
<p><code>Java</code>只实现了<code>capture-by-value</code>,但又没有对外说明这一点,为了以后能进一步扩展成支持<code>capture-by-reference</code>留后路,所以干脆就不允许向被捕获的变量赋值,所以这些<code>自由变量</code>需要强制加上<code>final</code>修饰符(在<code>Jdk8</code>中似乎已经没有这种强制限制了).</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><hr>
<ul>
<li><a href="https://www.ibm.com/developerworks/java/library/j-jtp04247/index.html" target="_blank" rel="external">Java theory and practice: The closures debate</a></li>
</ul>
<ul>
<li><a href="http://rednaxelafx.iteye.com/blog/245022" target="_blank" rel="external">关于对象与闭包的关系的一个有趣小故事</a></li>
</ul>
<ul>
<li><a href="https://www.zhihu.com/question/27416568/answer/36565794" target="_blank" rel="external">JVM的规范中允许编程语言语义中创建闭包(closure)吗？ - 知乎</a></li>
</ul>
<ul>
<li><a href="https://www.zhihu.com/question/28190927/answer/39786939" target="_blank" rel="external">为什么Java闭包不能通过返回值之外的方式向外传递值？ - 知乎</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Java中的闭包之争&lt;br&gt;date: 2017-07-30 18:00&lt;br&gt;author: “Sylvanas Sun”&lt;br&gt;catalog: true&lt;br&gt;categories: [“后端”,”Java”]&lt;br&gt;tags: [“Java”
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图的那点事儿(4)-加权有向图</title>
    <link href="https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph/"/>
    <id>https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph/</id>
    <published>2017-07-27T04:00:00.000Z</published>
    <updated>2017-07-29T08:08:06.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文作者为: <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a>.转载请务必将下面这段话置于文章开头处(保留超链接).<br>本文转发自<a href="https:/sylvanassun.github.io" target="_blank" rel="external">SylvanasSun Blog</a>,原文链接: <a href="https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph">https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph</a></p>
</blockquote>
<h3 id="加权有向图"><a href="#加权有向图" class="headerlink" title="加权有向图"></a>加权有向图</h3><hr>
<p><code>有向图</code>的实现比<code>无向图</code>更加简单,要实现<code>加权有向图</code>只需要在上一章讲到的<code>加权无向图</code>的实现修改一下即可.</p>
<h4 id="DirectedEdge"><a href="#DirectedEdge" class="headerlink" title="DirectedEdge"></a>DirectedEdge</h4><hr>
<p>由于<code>有向图</code>的边都是带有方向的,所以下面这个实现提供了<code>from()</code>与<code>to()</code>函数,用于获取代表<code>v-&gt;w</code>的两个<code>顶点</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedEdge</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> w;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</div><div class="line">        validateVertexes(v, w);</div><div class="line">        <span class="keyword">if</span> (Double.isNaN(weight)) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Weight "</span> + weight + <span class="string">" is  NaN!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.v = v;</div><div class="line">        <span class="keyword">this</span>.w = w;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">from</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> w;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> v + <span class="string">"-&gt;"</span> + w + <span class="string">" "</span> + String.format(<span class="string">"%5.2f"</span>, weight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertexes</span><span class="params">(<span class="keyword">int</span>... vertexes)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (vertexes[i] &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Vertex "</span> + vertexes[i] + <span class="string">" must be positive number!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="EdgeWeightedDigraph"><a href="#EdgeWeightedDigraph" class="headerlink" title="EdgeWeightedDigraph"></a>EdgeWeightedDigraph</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDigraph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEWLINE = System.getProperty(<span class="string">"line.separator"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// number of vertices in this digraph</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vertex;</div><div class="line"></div><div class="line">    <span class="comment">// number of edges in this digraph</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edge;</div><div class="line"></div><div class="line">    <span class="comment">// adj[v] = adjacency list for vertex v</span></div><div class="line">    <span class="keyword">private</span> Bag&lt;DirectedEdge&gt;[] adj;</div><div class="line"></div><div class="line">    <span class="comment">// indegree[v] = indegree of vertex v</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indegree;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        String message = String.format(<span class="string">"Vertex %d must be positive number!"</span>, vertex);</div><div class="line">        validatePositiveNumber(message, vertex);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.vertex = vertex;</div><div class="line">        <span class="keyword">this</span>.edge = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.indegree = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.adj = (Bag&lt;DirectedEdge&gt;[]) <span class="keyword">new</span> Bag[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span><span class="params">(Scanner scanner)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(scanner.nextInt());</div><div class="line">        <span class="keyword">int</span> edge = scanner.nextInt();</div><div class="line">        String message = String.format(<span class="string">"Edge %d must be positive number!"</span>, edge);</div><div class="line">        validatePositiveNumber(message, edge);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; i++) &#123;</div><div class="line">            <span class="keyword">int</span> v = scanner.nextInt();</div><div class="line">            <span class="keyword">int</span> w = scanner.nextInt();</div><div class="line">            validateVertex(v);</div><div class="line">            validateVertex(w);</div><div class="line">            <span class="keyword">double</span> weight = scanner.nextDouble();</div><div class="line">            addEdge(<span class="keyword">new</span> DirectedEdge(v, w, weight));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">vertex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vertex;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">edge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> edge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(DirectedEdge e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> v = e.from();</div><div class="line">        <span class="keyword">int</span> w = e.to();</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        adj[v].add(e);</div><div class="line">        indegree[w]++;</div><div class="line">        edge++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outdegree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v].size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indegree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> indegree[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在有向图中每条边只会出现一次</span></div><div class="line">	<span class="comment">// 遍历边集不需要在无向图里那样为了消除重复边而进行复杂的判断</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bag&lt;DirectedEdge&gt; list = <span class="keyword">new</span> Bag&lt;DirectedEdge&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            <span class="keyword">for</span> (DirectedEdge e : adj(v)) &#123;</div><div class="line">                list.add(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</div><div class="line">        s.append(vertex + <span class="string">" "</span> + edge + NEWLINE);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            s.append(v + <span class="string">": "</span>);</div><div class="line">            <span class="keyword">for</span> (DirectedEdge e : adj[v]) &#123;</div><div class="line">                s.append(e + <span class="string">"  "</span>);</div><div class="line">            &#125;</div><div class="line">            s.append(NEWLINE);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validatePositiveNumber</span><span class="params">(String message, <span class="keyword">int</span>... numbers)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>加权有向图</code>的实现与<code>加权无向图</code>区别不大,而且因为<code>有向图</code>中的边只会出现一次,实现代码要比<code>无向图</code>更简单.</p>
<p><a href="https://github.com/SylvanasSun/algs4-study/tree/master/src/main/java/chapter4_graphs/C4_4_ShortestPaths" target="_blank" rel="external">本文中的所有完整代码请到我的GitHub中查看</a></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><hr>
<p>“找到一个<code>顶点</code>到达另一个<code>顶点</code>之间的<code>最短路径</code>“是<code>图论</code>研究中的经典算法问题.在<code>加权有向图</code>中,每条<code>有向路径</code>都有一个与之对应的<code>路径权重</code>(路径中所有边的<code>权重</code>之和),要找到一条<code>最短路径</code>其实就是找到<code>路径权重</code>最小的那条路径.</p>
<p><img src="http://algs4.cs.princeton.edu/44sp/images/shortest-path.png" alt="加权有向图中的最短路径"></p>
<h4 id="单点最短路径"><a href="#单点最短路径" class="headerlink" title="单点最短路径"></a>单点最短路径</h4><hr>
<p>“从<code>s</code>到目的地<code>v</code>是否存在一条<code>有向路径</code>,如果有,找出最短的那条路径”.类似这样的问题就是<code>单点最短路径</code>问题,它是我们主要研究的问题.</p>
<p><code>单点最短路径</code>的结果是一棵<code>最短路径树</code>,它是<code>图</code>的一幅<code>子图</code>,<strong>包含了从起点到所有可达顶点的<code>最短路径</code>.</strong></p>
<p>从起点到一个顶点可能存在两条长度相等的路径,如果出现这种情况,可以删除其中一条路径的最后一条边,直到从起点到每个顶点都只有一条路径相连.</p>
<h4 id="最短路径的数据结构"><a href="#最短路径的数据结构" class="headerlink" title="最短路径的数据结构"></a>最短路径的数据结构</h4><hr>
<p><img src="http://algs4.cs.princeton.edu/44sp/images/spt.png" alt=""></p>
<p>要实现<code>最短路径</code>的算法还需要借助以下数据结构: </p>
<ul>
<li>edgeTo[]: 一个<code>由顶点索引</code>的<code>DirectedEdge</code>对象的父链接数组,其中<code>edgeTo[v]</code>的值为树中连接<code>v</code>和它的父节点的边.</li>
</ul>
<ul>
<li>distTo[]: 一个<code>由顶点索引</code>的<code>double</code>数组,其中<code>distTo[v]</code>代表从<code>起点</code>到<code>v</code>的已知最短路径的长度.</li>
</ul>
<ul>
<li>初始化时,<code>edgeTo[s]</code>的值为<code>null</code>(<code>s</code>为起点),<code>distTo[s]</code>的值为<code>0.0</code>,从<code>s</code>到不可达的顶点距离为<code>Double.POSITIVE_INFINITY</code>.</li>
</ul>
<h4 id="让边松弛"><a href="#让边松弛" class="headerlink" title="让边松弛"></a>让边松弛</h4><hr>
<p><code>最短路径</code>算法都基于<code>松弛(Relaxation)</code>操作,<strong>它在遇到新的边时,通过更新这些信息就可以得到新的最短路径.</strong></p>
<p>假设对边<code>v-&gt;w</code>进行松弛操作,意味着要先检查从<code>s</code>到<code>w</code>的<code>最短路径</code>是否是先从<code>s</code>到<code>v</code>,然后再由<code>v</code>到<code>w</code>(也就是说<code>v-&gt;w</code>是更短的一条路径),如果是,那么就进行更新.由<code>v</code>到达<code>w</code>的<code>最短路径</code>是<code>distTo[v]</code>与<code>e.weight()</code>之和,如果这个值大于<code>distTo[w]</code>,称这条边松弛失败,并将它忽略.</p>
<p>松弛操作就像用一根橡皮筋沿着连续两个<code>顶点</code>的路径紧紧展开,放松一条边就像将这条橡皮筋转移到另一条更短的路径上,从而缓解橡皮筋的压力.</p>
<p><img src="http://algs4.cs.princeton.edu/44sp/images/relaxation-edge.png" alt="松弛操作的两种情况(失败与成功)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 松弛一条边</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> v = e.from(), w = e.to();</div><div class="line">	<span class="comment">// 如果s-&gt;v-&gt;w的路径更小则进行更新</span></div><div class="line">    <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</div><div class="line">        distTo[w] = distTo[v] + e.weight();</div><div class="line">        edgeTo[w] = e;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 松弛一个顶点的所有邻接边</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;</div><div class="line">        <span class="keyword">int</span> w = e.to();</div><div class="line">        <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</div><div class="line">            distTo[w] = distTo[v] + e.weight();</div><div class="line">            edgeTo[w] = e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><hr>
<p><code>Dijkstra算法</code>类似于<code>Prim算法</code>,它将<code>distTo[s]</code>初始化为<code>0.0</code>,<code>distTo[]</code>中的其他元素初始化为<code>Double.POSITIVE_INFINITY</code>.然后将<code>distTo[]</code>中最小的<code>非树顶点</code>放松并加入树中,一直重复直到所有的顶点都在树中或者所有的<code>非树顶点</code>的<code>distTo[]</code>值均为<code>Double.POSITIVE_INFINITY</code>.</p>
<p><code>Dijkstra算法</code>与<code>Prim算法</code>都是用添加边的方式构造一棵树:</p>
<ul>
<li><code>Prim算法</code>每次添加的是距离<code>树</code>最近的<code>非树顶点</code>.</li>
</ul>
<ul>
<li><code>Dijkstra算法</code>每次添加的都是<strong>离<code>起点</code>最近的<code>非树顶点</code></strong>.</li>
</ul>
<p>从上述的步骤我们就能看出,<code>Dijkstra算法</code>需要一个优先队列(也可以用<code>斐波那契堆</code>)来保存需要被放松的<code>顶点</code>并确认下一个被放松的<code>顶点</code>(也就是取出最小的).</p>
<p>如此简单的<code>Dijkstra算法</code>也有其缺点,那就是它<strong>只适用于解决<code>权重非负</code>的<code>图</code>.</strong></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" alt="Dijkstra算法的运行轨迹"></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e4/DijkstraDemo.gif" alt=""></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// distTo[v] = distance of  shortest s -&gt; v path</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</div><div class="line"></div><div class="line">    <span class="comment">// edgeTo[v] = last edge on shortest s - &gt; v path</span></div><div class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</div><div class="line"></div><div class="line">    <span class="comment">// priority queue of vertices</span></div><div class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph digraph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">        validateNegativeWeight(digraph);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> vertex = digraph.vertex();</div><div class="line">        <span class="keyword">this</span>.distTo = <span class="keyword">new</span> <span class="keyword">double</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> DirectedEdge[vertex];</div><div class="line"></div><div class="line">        validateVertex(s);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            distTo[v] = Double.POSITIVE_INFINITY;</div><div class="line">        distTo[s] = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 将起点放入索引优先队列,并不断地进行松弛</span></div><div class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;&gt;(vertex);</div><div class="line">        pq.insert(s, distTo[s]);</div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> v = pq.delMin();</div><div class="line">			<span class="comment">// 对权值最小的非树顶点的所有邻接边集进行松弛操作</span></div><div class="line">            <span class="keyword">for</span> (DirectedEdge e : digraph.adj(v))</div><div class="line">                relax(e);</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// relax edge e and update pq if changed</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> v = e.from(), w = e.to();</div><div class="line">		<span class="comment">// s -&gt; v -&gt; w的权重</span></div><div class="line">        <span class="keyword">double</span> weight = distTo[v] + e.weight();</div><div class="line">        <span class="keyword">if</span> (distTo[w] &gt; weight) &#123;</div><div class="line">            distTo[w] = weight;</div><div class="line">            edgeTo[w] = e;</div><div class="line">            <span class="keyword">if</span> (pq.contains(w))</div><div class="line">                pq.decreaseKey(w, weight);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                pq.insert(w, weight);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateNegativeWeight</span><span class="params">(EdgeWeightedDigraph digraph)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (DirectedEdge e : digraph.edges()) &#123;</div><div class="line">            <span class="keyword">if</span> (e.weight() &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Edge "</span> + e + <span class="string">" has negative weight."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> distTo[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> Stack&lt;DirectedEdge&gt;();</div><div class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from()]) &#123;</div><div class="line">            path.push(e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> V = distTo.length;</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述的代码也可以用于处理<code>加权无向图</code>,但需要修改传入的对象类型.不管是<code>无向图</code>还是<code>有向图</code>它们对于<code>最短路径</code>问题是等价的.</p>
<h3 id="无环加权有向图中的最短路径算法"><a href="#无环加权有向图中的最短路径算法" class="headerlink" title="无环加权有向图中的最短路径算法"></a>无环加权有向图中的最短路径算法</h3><hr>
<p>如果是处理<code>无环图</code>的情况下,还会有一种比<code>Dijkstra算法</code>更快、更简单的算法.它的特点如下:</p>
<ul>
<li>能够处理<code>负权重</code>的边.</li>
</ul>
<ul>
<li>能够在线性时间内解决单点最短路径问题.</li>
</ul>
<ul>
<li><p>在已知是一张<code>无环图</code>的情况下,它是找出<code>最短路径</code>效率最高的方法.</p>
<ul>
<li>实现比<code>Dijkstra算法</code>更简单.</li>
</ul>
</li>
</ul>
<p>只需要将所有<code>顶点</code><strong>按照<code>拓扑排序</code>的顺序</strong>来<code>松弛边</code>,就可以得到这个简单高效的算法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcyclicSP</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// distTo[v] = distance  of shortest s-&gt;v path</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</div><div class="line"></div><div class="line">    <span class="comment">// edgeTo[v] = last edge on shortest s-&gt;v path</span></div><div class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcyclicSP</span><span class="params">(EdgeWeightedDigraph digraph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> vertex = digraph.vertex();</div><div class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[vertex];</div><div class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[vertex];</div><div class="line"></div><div class="line">        validateVertex(s);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            distTo[v] = Double.POSITIVE_INFINITY;</div><div class="line">        distTo[s] = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">        </div><div class="line">        Topological topological = <span class="keyword">new</span> Topological(digraph);</div><div class="line">        <span class="keyword">if</span> (!topological.hasOrder())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Digraph is not acyclic."</span>);</div><div class="line">		<span class="comment">// 按照拓扑排序的顺序进行放松操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : topological.order()) &#123;</div><div class="line">            <span class="keyword">for</span> (DirectedEdge e : digraph.adj(v))</div><div class="line">                relax(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> v = e.from(), w = e.to();</div><div class="line">        <span class="keyword">double</span> weight = distTo[v] + e.weight();</div><div class="line">        <span class="keyword">if</span> (distTo[w] &gt; weight) &#123;</div><div class="line">            distTo[w] = weight;</div><div class="line">            edgeTo[w] = e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最长路径"><a href="#最长路径" class="headerlink" title="最长路径"></a>最长路径</h4><hr>
<p>要想找出一条<code>最长路径</code>,只需要把<code>distTo[]</code>的初始化变为<code>Double.NEGATIVE_INFINITY</code>,并更改<code>relax()</code>函数中的不等式的方向.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AcyclicLP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">      distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.vertex()];</div><div class="line">      edgeTo = <span class="keyword">new</span> DirectedEdge[G.vertex()];</div><div class="line"></div><div class="line">      validateVertex(s);</div><div class="line"></div><div class="line"><span class="comment">// 全部初始化为负无穷</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vertex(); v++)</div><div class="line">          distTo[v] = Double.NEGATIVE_INFINITY;</div><div class="line">      distTo[s] = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">      Topological topological = <span class="keyword">new</span> Topological(G);</div><div class="line">      <span class="keyword">if</span> (!topological.hasOrder())</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Digraph is not acyclic."</span>);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v : topological.order()) &#123;</div><div class="line">          <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</div><div class="line">              relax(e);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> v = e.from(), w = e.to();</div><div class="line"><span class="comment">// 改变不等式的方向</span></div><div class="line">      <span class="keyword">if</span> (distTo[w] &lt; distTo[v] + e.weight()) &#123;</div><div class="line">          distTo[w] = distTo[v] + e.weight();</div><div class="line">          edgeTo[w] = e;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><hr>
<p>我们已经知道了处理<code>权重</code>非负图的<code>Dijkstra算法</code>与处理<code>无环图</code>的算法,但如果遇见既含有环,<code>权重</code>也是负数的<code>加权有向图</code>该怎么办?</p>
<p><code>Bellman-Ford算法</code>就是用于处理<code>有环</code>且含有<code>负权重</code>的<code>加权有向图</code>的,它的原理是对图进行<code>V-1</code>次松弛操作,得到所有可能的最短路径.</p>
<p>要实现<code>Bellman-Ford算法</code>还需要以下数据结构: </p>
<ul>
<li>队列: 用于保存即将被松弛的顶点.</li>
</ul>
<ul>
<li>布尔值数组: 用来标记该顶点是否已经存在于队列中,以防止重复插入.</li>
</ul>
<p>我们将起点放入队列中,然后进入一个循环,每次循环都会从队列中取出一个顶点并对其进行松弛.为了保证算法在<code>V</code>轮后能够终止,需要能够动态地检测是否存在<code>负权重环</code>,如果找到了这个环则结束运行(也可以用一个变量动态记录轮数).</p>
<h4 id="负权重环的检测"><a href="#负权重环的检测" class="headerlink" title="负权重环的检测"></a>负权重环的检测</h4><hr>
<p>如果存在了一个从起点可达的<code>负权重环</code>,那么队列就永远不可能为空,为了从这个无尽的循环中解脱出来,算法需要能够动态地检测<code>负权重环</code>.</p>
<p><code>Bellman-Ford算法</code>也使用了<code>edgeTo[]</code>来存放<code>最短路径树</code>中的每一条边,我们根据<code>edgeTo[]</code>来复制一幅图并在该图中检测环.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findNegativeCycle</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> V = edgeTo.length;</div><div class="line"><span class="comment">// 根据edgeTo[]来创建一幅加权有向图</span></div><div class="line">      EdgeWeightedDigraph spt = <span class="keyword">new</span> EdgeWeightedDigraph(V);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</div><div class="line">          <span class="keyword">if</span> (edgeTo[v] != <span class="keyword">null</span>)</div><div class="line">              spt.addEdge(edgeTo[v]);</div><div class="line"><span class="comment">// 判断该图有没有环</span></div><div class="line">      EdgeWeightedDirectedCycle finder = <span class="keyword">new</span> EdgeWeightedDirectedCycle(spt);</div><div class="line">      cycle = finder.cycle();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFordSP</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</div><div class="line"></div><div class="line">    <span class="comment">// 用于标记顶点是否在队列中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onQueue;</div><div class="line"></div><div class="line">    <span class="comment">// 存放下次进行松弛操作的顶点的队列</span></div><div class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</div><div class="line"></div><div class="line">    <span class="comment">// 计算松弛操作的轮数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;</div><div class="line"></div><div class="line">    <span class="comment">// 负权重环</span></div><div class="line">    <span class="keyword">private</span> Iterable&lt;DirectedEdge&gt; cycle;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BellmanFordSP</span><span class="params">(EdgeWeightedDigraph digraph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> vertex = digraph.vertex();</div><div class="line">        <span class="keyword">this</span>.distTo = <span class="keyword">new</span> <span class="keyword">double</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> DirectedEdge[vertex];</div><div class="line">        <span class="keyword">this</span>.onQueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            distTo[v] = Double.POSITIVE_INFINITY;</div><div class="line">        distTo[s] = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Bellman-Ford algorithm</span></div><div class="line">        queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        queue.add(s); <span class="comment">// 将起点放入队列</span></div><div class="line">        onQueue[s] = <span class="keyword">true</span>; <span class="comment">// 标记起点已在队列中</span></div><div class="line">		<span class="comment">// 当队列为空时或者发现负权重环时结束循环</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) &#123;</div><div class="line">            <span class="keyword">int</span> v = queue.poll();</div><div class="line">            onQueue[v] = <span class="keyword">false</span>;</div><div class="line">            relax(digraph, v);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;</div><div class="line">            <span class="keyword">int</span> w = e.to();</div><div class="line">            <span class="keyword">double</span> weight = distTo[v] + e.weight();</div><div class="line">            <span class="keyword">if</span> (distTo[w] &gt; weight) &#123;</div><div class="line">                distTo[w] = weight;</div><div class="line">                edgeTo[w] = e;</div><div class="line">				<span class="comment">// 将不在队列中的顶点w加到队列</span></div><div class="line">                <span class="keyword">if</span> (!onQueue[w]) &#123;</div><div class="line">                    queue.add(w);</div><div class="line">                    onQueue[w] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 动态检测负权重环,</span></div><div class="line">            <span class="keyword">if</span> (cost++ % G.vertex() == <span class="number">0</span>) &#123;</div><div class="line">                findNegativeCycle();</div><div class="line">                <span class="keyword">if</span> (hasNegativeCycle()) <span class="keyword">return</span>;  <span class="comment">// found a negative cycle</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>解决<code>最短路径</code>问题一直都是<code>图论</code>的经典问题,本文中介绍的算法适用于不同的环境,在应用中应该根据不同的环境选择不同的算法.</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>局限性</th>
<th>路径长度的比较次数(增长的数量级)</th>
<th>空间复杂度</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dijkstra</td>
<td>只能处理正权重</td>
<td>ElogV</td>
<td>V</td>
<td>最坏情况下仍有较好的性能</td>
</tr>
<tr>
<td>拓扑排序</td>
<td>只适用于无环图</td>
<td>E+V</td>
<td>V</td>
<td>实现简单,是无环图情况下的最优算法</td>
</tr>
<tr>
<td>Bellman-Ford</td>
<td>不能存在负权重环</td>
<td>E+V,最坏情况为VE</td>
<td>V</td>
<td>适用广泛</td>
</tr>
</tbody>
</table>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><hr>
<ul>
<li><a href="http://algs4.cs.princeton.edu/44sp/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="external">Dijkstra’s algorithm - Wikipedia</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm" target="_blank" rel="external">Bellman–Ford algorithm - Wikipedia</a></li>
</ul>
<h3 id="图的那点事儿"><a href="#图的那点事儿" class="headerlink" title="图的那点事儿"></a>图的那点事儿</h3><hr>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/">图的那点事儿(1)-无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/">图的那点事儿(2)-有向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/">图的那点事儿(3)-加权无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph">图的那点事儿(4)-加权有向图</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文作者为: &lt;a href=&quot;https://github.com/SylvanasSun&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SylvanasSun&lt;/a&gt;.转载请务必将下面这段话置于文章开头处(保留超链接).&lt;br
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/categories/Algorithms/Graph/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>图的那点事儿(3)-加权无向图</title>
    <link href="https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/"/>
    <id>https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/</id>
    <published>2017-07-25T10:00:00.000Z</published>
    <updated>2017-07-30T08:15:44.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文作者为: <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a>.转载请务必将下面这段话置于文章开头处(保留超链接).<br>本文转发自<a href="https://sylvanassun.github.io">SylvanasSun Blog</a>,原文链接: <a href="https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/">https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/</a></p>
</blockquote>
<h3 id="加权无向图"><a href="#加权无向图" class="headerlink" title="加权无向图"></a>加权无向图</h3><hr>
<p>所谓<code>加权图</code>,即每条<code>边</code>上都有着对应的<code>权重</code>,这个<code>权重</code>是正数也可以是负数,也不一定会和距离成正比.<code>加权无向图</code>的表示方法只需要对<code>无向图</code>的实现进行一下扩展.</p>
<ul>
<li>在使用<code>邻接矩阵</code>的方法中,可以用<code>边</code>的<code>权重</code>代替布尔值来作为矩阵的元素.</li>
</ul>
<ul>
<li>在使用<code>邻接表</code> 的方法中,可以在<code>链表</code>的<code>节点</code>中添加一个权重域.</li>
</ul>
<ul>
<li>在使用<code>邻接表</code>的方法中,将<code>边</code>抽象为一个<code>Edge</code>类,它包含了相连的两个<code>顶点</code>和它们的<code>权重</code>,<code>链表</code>中的每个元素都是一个<code>Edge</code>.</li>
</ul>
<p>我们使用第三种方法来实现<code>加权无向图</code>,它的数据表示如下图:</p>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/edge-weighted-graph-representation.png" alt="加权无向图的表示"></p>
<h4 id="Edge的实现"><a href="#Edge的实现" class="headerlink" title="Edge的实现"></a>Edge的实现</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> w;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</div><div class="line">        validateVertexes(v, w);</div><div class="line">        <span class="keyword">if</span> (Double.isNaN(weight)) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Weight is NaN."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.v = v;</div><div class="line">        <span class="keyword">this</span>.w = w;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertexes</span><span class="params">(<span class="keyword">int</span>... vertexes)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (vertexes[i] &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                        String.format(<span class="string">"Vertex %d must be a nonnegative integer."</span>, vertexes[i]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">either</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex == v)</div><div class="line">            <span class="keyword">return</span> w;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w)</div><div class="line">            <span class="keyword">return</span> v;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal endpoint."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge that)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.weight, that.weight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(<span class="string">"%d-%d %.5f"</span>, v, w, weight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Edge</code>类提供了<code>either()</code>与<code>other()</code>两个函数,在两个<code>顶点</code>都未知的情况下,可以调用<code>either()</code>获得<code>顶点v</code>,然后再调用<code>other(v)</code>来获得另一个<code>顶点</code>.</p>
<blockquote>
<p><a href="https://github.com/SylvanasSun/algs4-study/tree/master/src/main/java/chapter4_graphs/C4_3_MinimumSpanningTrees" target="_blank" rel="external">本文中的所有完整代码点我查看</a></p>
</blockquote>
<h4 id="加权无向图的实现"><a href="#加权无向图的实现" class="headerlink" title="加权无向图的实现"></a>加权无向图的实现</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEWLINE = System.getProperty(<span class="string">"line.separator"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vertexes;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edges;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Bag&lt;Edge&gt;[] adj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span><span class="params">(<span class="keyword">int</span> vertexes)</span> </span>&#123;</div><div class="line">        validateVertexes(vertexes);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.vertexes = vertexes;</div><div class="line">        <span class="keyword">this</span>.edges = <span class="number">0</span>;</div><div class="line">        adj = (Bag&lt;Edge&gt;[]) <span class="keyword">new</span> Bag[vertexes];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexes; i++)</div><div class="line">            adj[i] = <span class="keyword">new</span> Bag&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span><span class="params">(Scanner scanner)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(scanner.nextInt());</div><div class="line">        <span class="keyword">int</span> edges = scanner.nextInt();</div><div class="line">        validateEdges(edges);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges; i++) &#123;</div><div class="line">            <span class="keyword">int</span> v = scanner.nextInt();</div><div class="line">            <span class="keyword">int</span> w = scanner.nextInt();</div><div class="line">            <span class="keyword">double</span> weight = scanner.nextDouble();</div><div class="line">            addEdge(<span class="keyword">new</span> Edge(v, w, weight));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">vertex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vertexes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">edge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> edges;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> v = e.either();</div><div class="line">        <span class="keyword">int</span> w = e.other(v);</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        adj[v].add(e);</div><div class="line">        adj[w].add(e);</div><div class="line">        edges++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v].size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bag&lt;Edge&gt; list = <span class="keyword">new</span> Bag&lt;Edge&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertexes; v++) &#123;</div><div class="line">            <span class="keyword">int</span> selfLoops = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (Edge e : adj(v)) &#123;</div><div class="line">				<span class="comment">// 只添加一条边</span></div><div class="line">                <span class="keyword">if</span> (e.other(v) &gt; v) &#123;</div><div class="line">                    list.add(e);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 只添加一条自环的边</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e.other(v) == v) &#123;</div><div class="line">                    <span class="keyword">if</span> (selfLoops % <span class="number">2</span> == <span class="number">0</span>) list.add(e);</div><div class="line">                    selfLoops++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</div><div class="line">        s.append(vertexes + <span class="string">" "</span> + edges + NEWLINE);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertexes; v++) &#123;</div><div class="line">            s.append(v + <span class="string">": "</span>);</div><div class="line">            <span class="keyword">for</span> (Edge e : adj[v]) &#123;</div><div class="line">                s.append(e + <span class="string">"  "</span>);</div><div class="line">            &#125;</div><div class="line">            s.append(NEWLINE);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertexes</span><span class="params">(<span class="keyword">int</span>... vertexes)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (vertexes[i] &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                        String.format(<span class="string">"Vertex %d must be a nonnegative integer."</span>, vertexes[i]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateEdges</span><span class="params">(<span class="keyword">int</span> edges)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (edges &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of edges must be nonnegative."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= vertexes)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (vertexes - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码是对<code>无向图</code>的扩展,它将<code>邻接表</code>中的元素从<code>整数</code>变为了<code>Edge</code>,函数<code>edges()</code>返回了<code>边</code>的集合,由于是<code>无向图</code>所以每条<code>边</code>会出现两次,需要注意处理.</p>
<p><code>加权无向图</code>的实现还拥有以下特点: </p>
<ul>
<li>边的比较: <code>Edge</code>类实现了<code>Comparable</code>接口,它使用了<code>权重</code>来比较两条<code>边</code>的大小,所以<code>加权无向图</code>的自然次序就是权重次序.</li>
</ul>
<ul>
<li>自环: 该实现允许存在自环,并且<code>edges()</code>函数中对自环边进行了记录.</li>
</ul>
<ul>
<li>平行边: 该实现允许存在平行边,但可以用更复杂的方法来消除平行边,例如只保留平行边中的权重最小者.</li>
</ul>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><hr>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/mst.png" alt="加权无向图的最小生成树"></p>
<p><code>最小生成树</code>是<code>加权无向图</code>的重要应用.<strong><code>图</code>的<code>生成树</code>是它的一棵含有其所有<code>顶点</code>的<code>无环连通子图</code>,<code>最小生成树</code>是它的一棵<code>权值</code>(所有边的权值之和)最小的<code>生成树</code>.</strong></p>
<p>在给定的一幅<code>加权无向图</code>$G = (V,E)$中,$(u,v)$代表连接<code>顶点u</code>与<code>顶点v</code>的<code>边</code>,也就是$(u,v) \in E$,而$w(u,v)$代表这条边的<code>权重</code>,若存在<code>T</code>为<code>E</code>的子集,也就是$T \subseteq E$,且为<code>无环图</code>,使得$w(T) = \sum_{(u,v) \in T}w(u,v)$ 的 $w(T)$ 最小,则<code>T</code>为<code>G</code>的<code>最小生成树</code>.</p>
<p><code>最小生成树</code>在一些情况下可能会存在多个,例如,给定一幅图<code>G</code>,当它的所有边的<code>权重</code>都相同时,那么<code>G</code>的所有<code>生成树</code>都是<code>最小生成树</code>,当所有边的<code>权重</code>互不相同时,将会只有一个<code>最小生成树</code>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Multiple_minimum_spanning_trees.svg/316px-Multiple_minimum_spanning_trees.svg.png" alt="多个最小生成树的情况"></p>
<h3 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h3><hr>
<p><strong><code>切分定理</code>将图中的所有<code>顶点</code>切分为两个集合(两个非空且不重叠的集合),检查两个集合的所有边并识别哪条边应属于图的<code>最小生成树</code>.</strong></p>
<p>一种比较简单的切分方法即通过<strong>指定一个顶点集并隐式地认为它的补集为另一个顶点集来指定一个切分.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/cut-property.png" alt="白色与灰色顶点代表了不同的顶点集"></p>
<p><code>切分定理</code>也表明了对于每一种切分,<code>权重</code>最小的<code>横切边(一条连接两个属于不同集合的顶点的边)</code>必然属于<code>最小生成树</code>.</p>
<p><code>切分定理</code>是解决<code>最小生成树</code>问题的所有算法的基础,<strong>使用<code>切分定理</code>找到<code>最小生成树</code>的一条边,不断重复直到找到<code>最小生成树</code>的所有边.</strong></p>
<p>这些算法可以说都是<code>贪心算法</code>,算法的每一步都是在找最优解(<code>权值</code>最小的<code>横切边</code>),而<strong>解决<code>最小生成树</code>的各种算法不同之处仅在于保存切分和判定<code>权重</code>最小的<code>横切边</code>的方式.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/mst-greedy.png" alt="生成最小生成树的过程,权值最小的横切边将会被标记为黑色"></p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><hr>
<p><code>Prim算法</code>是用于解决<code>最小生成树</code>的算法之一,算法的每一步都会为一棵生长中的<code>树</code>添加一条边.一开始这棵树只有一个<code>顶点</code>,然后会一直添加到$V - 1$条边,<strong>每次总是将下一条连接<code>树</code>中的<code>顶点</code>与不在<code>树</code>中的<code>顶点</code>且<code>权重</code>最小的边加入到<code>树</code>中(也就是由<code>树</code>中<code>顶点</code>所定义的切分中的一条<code>横切边</code>).</strong></p>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/prim.png" alt=""></p>
<p>实现<code>Prim算法</code>还需要借助以下数据结构: </p>
<ul>
<li>布尔值数组: 用于记录<code>顶点</code>是否已在<code>树</code>中.</li>
</ul>
<ul>
<li>队列: 使用一条队列来保存<code>最小生成树</code>中的边,也可以使用一个由<code>顶点</code>索引的<code>Edge</code>对象的数组.</li>
</ul>
<ul>
<li>优先队列: 优先队列用于保存<code>横切边</code>,优先队列的性质可以每次取出<code>权值</code>最小的<code>横切边</code>.</li>
</ul>
<h4 id="延时实现"><a href="#延时实现" class="headerlink" title="延时实现"></a>延时实现</h4><hr>
<p>当我们连接新加入<code>树</code>中的<code>顶点</code>与其他已经在<code>树</code>中<code>顶点</code>的所有边都失效了(由于两个<code>顶点</code>都已在<code>树</code>中,所以这是一条失效的<code>横切边</code>).我们需要处理这种情况,<strong>即使实现对无效边采取忽略(不加入到优先队列中),而延时实现会把无效边留在优先队列中,等到要删除优先队列中的数据时再进行有效性检查.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/prim-lazy.png" alt="Prim延时实现的运行轨迹"></p>
<p>上图为<code>Prim算法</code>延时实现的轨迹图,它的步骤如下: </p>
<ul>
<li>将<code>顶点0</code>添加到<code>最小生成树</code>中,将它的<code>邻接表</code>中的所有边添加到优先队列中(将<code>横切边</code>添加到优先队列).</li>
</ul>
<ul>
<li>将<code>顶点7</code>和边<code>0-7</code>添加到<code>最小生成树</code>中,将<code>顶点</code>的<code>邻接表</code>中的所有边添加到优先队列中.</li>
</ul>
<ul>
<li>将<code>顶点1</code>和边<code>1-7</code>添加到<code>最小生成树</code>中,将<code>顶点</code>的<code>邻接表</code>中的所有边添加到优先队列中.</li>
</ul>
<ul>
<li>将<code>顶点2</code>和边<code>0-2</code>添加到<code>最小生成树</code>中,将边<code>2-3</code>和<code>6-2</code>添加到优先队列中,边<code>2-7</code>和<code>1-2</code>失效.</li>
</ul>
<ul>
<li>将<code>顶点3</code>和边<code>2-3</code>添加到<code>最小生成树</code>中,将边<code>3-6</code>添加到优先队列之中,边<code>1-3</code>失效.</li>
</ul>
<ul>
<li>将<code>顶点5</code>和边<code>5-7</code>添加到<code>最小生成树</code>中,将边<code>4-5</code>添加到优先队列中,边<code>1-5</code>失效.</li>
</ul>
<ul>
<li>从优先队列中删除失效边<code>1-3</code>,<code>1-5</code>,<code>2-7</code>.</li>
</ul>
<ul>
<li>将<code>顶点4</code>和边<code>4-5</code>添加到<code>最小生成树</code>中,将边<code>6-4</code>添加到优先队列中,边<code>4-7</code>,<code>0-4</code>失效.</li>
</ul>
<ul>
<li>从优先队列中删除失效边<code>1-2</code>,<code>4-7</code>,<code>0-4</code>.</li>
</ul>
<ul>
<li>将<code>顶点6</code>和边<code>6-2</code>添加到<code>最小生成树</code>中,和<code>顶点6</code>关联的其他边失效.</li>
</ul>
<ul>
<li>在添加<code>V</code>个顶点与<code>V - 1</code>条边之后,<code>最小生成树</code>就构造完成了,优先队列中剩余的边都为失效边.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EdgeWeightedGraph graph;</div><div class="line"></div><div class="line">    <span class="comment">// 记录最小生成树的总权重</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</div><div class="line"></div><div class="line">    <span class="comment">// 存储最小生成树的边</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Edge&gt; mst;</div><div class="line"></div><div class="line">    <span class="comment">// 标记这个顶点在树中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="comment">// 存储横切边的优先队列</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Edge&gt; pq;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        mst = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            <span class="keyword">if</span> (!marked[v]) prim(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">        scanAndPushPQ(s);</div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</div><div class="line">            Edge edge = pq.poll();  <span class="comment">// 取出权重最小的横切边</span></div><div class="line">            <span class="keyword">int</span> v = edge.either(), w = edge.other(v);  </div><div class="line">            <span class="keyword">assert</span> marked[v] || marked[w];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w])</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// 忽略失效边</span></div><div class="line"></div><div class="line">            mst.add(edge); <span class="comment">// 添加边到最小生成树中</span></div><div class="line">            weight += edge.weight(); <span class="comment">// 更新总权重</span></div><div class="line">			<span class="comment">// 继续将非树顶点加入到树中并更新横切边</span></div><div class="line">            <span class="keyword">if</span> (!marked[v]) scanAndPushPQ(v); </div><div class="line">            <span class="keyword">if</span> (!marked[w]) scanAndPushPQ(w); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记顶点到树中,并且添加横切边到优先队列</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanAndPushPQ</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> !marked[v];</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (Edge e : graph.adj(v))</div><div class="line">            <span class="keyword">if</span> (!marked[e.other(v)]) pq.add(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mst;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="即时实现"><a href="#即时实现" class="headerlink" title="即时实现"></a>即时实现</h4><hr>
<p>在即时实现中,将<code>v</code>添加到树中时,对于每个<code>非树顶点w</code>,<strong>不需要在优先队列中保存所有从<code>w</code>到<code>树顶点</code>的边,而只需要保存其中<code>权重</code>最小的边,所以在将<code>v</code>添加到<code>树</code>中后,要检查是否需要更新这条<code>权重</code>最小的边(如果<code>v-w</code>的<code>权重</code>更小的话).</strong></p>
<p>也可以认为只会在优先队列中保存每个<code>非树顶点w</code>的一条边(也是<code>权重</code>最小的那条边),将<code>w</code>和<code>树顶点</code>连接起来的其他<code>权重</code>较大的边迟早都会失效,所以没必要在优先队列中保存它们.</p>
<p>要实现即时版的<code>Prim算法</code>,需要使用两个顶点索引的数组<code>edgeTo[]</code>和<code>distTo[]</code>与一个索引优先队列,它们具有以下性质: </p>
<ul>
<li>如果<code>顶点v</code>不在树中但至少含有一条边和树相连,那么<code>edgeTo[v]</code>是将<code>v</code>和树连接的最短边,<code>distTo[v]</code>为这条边的<code>权重</code>.</li>
</ul>
<ul>
<li>所有这类<code>顶点v</code>都保存在索引优先队列中,索引<code>v</code>关联的值是<code>edgeTo[v]</code>的边的<code>权重</code>.</li>
</ul>
<ul>
<li>索引优先队列中的最小键即是<code>权重</code>最小的<code>横切边</code>的<code>权重</code>,而和它相关联的顶点<code>v</code>就是下一个将要被添加到<code>树</code>中的<code>顶点</code>.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/prim-eager.png" alt="即时实现Prim算法的运行轨迹"></p>
<ul>
<li>将<code>顶点0</code>添加到<code>最小生成树</code>之中,将它的<code>邻接表</code>中的所有边添加到优先队列中(这些边是目前唯一已知的横切边).</li>
</ul>
<ul>
<li>将<code>顶点7</code>和边<code>0-7</code>添加到<code>最小生成树</code>,将边<code>1-7</code>和<code>5-7</code>添加到优先队列中,将连接<code>顶点4</code>与树的最小边由<code>0-4</code>替换为<code>4-7</code>.</li>
</ul>
<ul>
<li>将<code>顶点1</code>和边<code>1-7</code>添加到<code>最小生成树</code>,将边<code>1-3</code>添加到优先队列.</li>
</ul>
<ul>
<li>将<code>顶点2</code>和边<code>0-2</code>添加到最小生成树,将连接<code>顶点6</code>与树的最小边由<code>0-6</code>替换为<code>6-2</code>,将连接<code>顶点3</code>与树的最小边由<code>1-3</code>替换为<code>2-3</code>.</li>
</ul>
<ul>
<li>将<code>顶点3</code>和边<code>2-3</code>添加到<code>最小生成树</code>.</li>
</ul>
<ul>
<li>将<code>顶点5</code>和边<code>5-7</code>添加到<code>最小生成树</code>,将连接<code>顶点4</code>与树的最小边<code>4-7</code>替换为<code>4-5</code>.</li>
</ul>
<ul>
<li>将<code>顶点4</code>和边<code>4-5</code>添加到<code>最小生成树</code>.</li>
</ul>
<ul>
<li>将<code>顶点6</code>和边<code>6-2</code>添加到<code>最小生成树</code>.</li>
</ul>
<ul>
<li>在添加了<code>V - 1</code>条边之后,<code>最小生成树</code>构造完成并且优先队列为空.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EdgeWeightedGraph graph;</div><div class="line"></div><div class="line">    <span class="comment">// 存放最小生成树中的边</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Edge[] edgeTo;</div><div class="line"></div><div class="line">    <span class="comment">// 每条边对应的权重</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] distTo;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IndexMinPQ&lt;Double&gt; pq;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> Edge[vertex];</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.pq = <span class="keyword">new</span> IndexMinPQ&lt;&gt;(vertex);</div><div class="line">        <span class="keyword">this</span>.distTo = <span class="keyword">new</span> <span class="keyword">double</span>[vertex];</div><div class="line">		<span class="comment">// 将权重数组初始化为无穷大</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex; i++)</div><div class="line">            distTo[i] = Double.POSITIVE_INFINITY;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            <span class="keyword">if</span> (!marked[v]) prim(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">		<span class="comment">// 将起点设为0.0并加入到优先队列</span></div><div class="line">        distTo[s] = <span class="number">0.0</span>;</div><div class="line">        pq.insert(s, distTo[s]);</div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</div><div class="line">			<span class="comment">// 取出权重最小的边,优先队列中存的顶点是与树相连的非树顶点,</span></div><div class="line">			<span class="comment">// 同时它也是下一次要加入到树中的顶点</span></div><div class="line">            <span class="keyword">int</span> v = pq.delMin();</div><div class="line">            scan(v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">		<span class="comment">// 将顶点加入到树中</span></div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Edge e : graph.adj(v)) &#123;</div><div class="line">            <span class="keyword">int</span> w = e.other(v);</div><div class="line">			<span class="comment">// 忽略失效边</span></div><div class="line">            <span class="keyword">if</span> (marked[w]) <span class="keyword">continue</span>;</div><div class="line">			<span class="comment">// 如果w与连接树顶点的边的权重小于其他w连接树顶点的边</span></div><div class="line">			<span class="comment">// 则进行替换更新</span></div><div class="line">            <span class="keyword">if</span> (e.weight() &lt; distTo[w]) &#123;</div><div class="line">                distTo[w] = e.weight();</div><div class="line">                edgeTo[w] = e;</div><div class="line">                <span class="keyword">if</span> (pq.contains(w))</div><div class="line">                    pq.decreaseKey(w, distTo[w]);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    pq.insert(w, distTo[w]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</div><div class="line">        Queue&lt;Edge&gt; mst = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; edgeTo.length; v++) &#123;</div><div class="line">            Edge e = edgeTo[v];</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                mst.add(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mst;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> weight = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">for</span> (Edge e : edges())</div><div class="line">            weight += e.weight();</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是<code>延迟实现</code>还是<code>即时实现</code>,<code>Prim算法</code>的规律就是: <strong>在<code>树</code>的生长过程中,都是通过连接一个和新加入的<code>顶点</code>相邻的<code>顶点</code>.当新加入的<code>顶点</code>周围没有<code>非树顶点</code>时,树的生长又会从另一部分开始.</strong></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><hr>
<p><code>Kruskal算法</code>的思想是<strong>按照边的<code>权重</code>顺序由小到大处理它们</strong>,将边添加到<code>最小生成树</code>,加入的边不会与已经在<code>树</code>中的边构成环,直到<code>树</code>中含有<code>V - 1</code>条边为止.<strong>这些边会逐渐由一片<code>森林</code>合并为一棵<code>树</code></strong>,也就是我们需要的<code>最小生成树</code>.</p>
<p><img src="http://algs4.cs.princeton.edu/43mst/images/kruskal.png" alt="Kruskal算法的运行轨迹"></p>
<h4 id="与Prim算法的区别"><a href="#与Prim算法的区别" class="headerlink" title="与Prim算法的区别"></a>与Prim算法的区别</h4><hr>
<ul>
<li><code>Prim算法</code>是一条边一条边地来构造<code>最小生成树</code>,每一步都会为<code>树</code>中添加一条边.</li>
</ul>
<ul>
<li><code>Kruskal算法</code>构造<code>最小生成树</code>也是一条边一条边地添加,但不同的是它寻找的边会连接一片<code>森林</code>中的两棵<code>树</code>.从一片由<code>V</code>棵单<code>顶点</code>的树构成的<code>森林</code>开始并不断地将两棵<code>树</code>合并(可以找到的最短边)直到只剩下一棵<code>树</code>,它就是<code>最小生成树</code>.</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr>
<p>要实现<code>Kruskal算法</code>需要借助<code>Union-Find</code>数据结构,它是一种树型的数据结构,用于处理一些不相交集合的合并与查询问题.</p>
<p>关于<code>Union-Find</code>的更多资料可以参考下面的链接: </p>
<ul>
<li><a href="https://github.com/SylvanasSun/algs4-study/blob/15ae228a1bc6a75465a96681caaa93eff3462327/src/main/java/chapter1_fundamentals/C1_5_UnionFind/UF.java" target="_blank" rel="external">Union-Find简单实现</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">Disjoint-set data structure - Wikipedia</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 这条队列用于记录最小生成树中的边集</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Edge&gt; mst;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mst = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="comment">// 创建一个优先队列,并将图的所有边添加到优先队列中</span></div><div class="line">        PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Edge e : graph.edges()) &#123;</div><div class="line">            pq.add(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">		<span class="comment">// 创建一个Union-Find</span></div><div class="line">        UF uf = <span class="keyword">new</span> UF(vertex);</div><div class="line">		<span class="comment">// 一条一条地添加边到最小生成树,直到添加了 V - 1条边</span></div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; vertex - <span class="number">1</span>) &#123;</div><div class="line">			<span class="comment">// 取出权重最小的边</span></div><div class="line">            Edge e = pq.poll();</div><div class="line">            <span class="keyword">int</span> v = e.either();</div><div class="line">            <span class="keyword">int</span> w = e.other(v);</div><div class="line">            <span class="comment">// 如果这条边的两个顶点不在一个分量中(对于union-find数据结构中而言)</span></div><div class="line">            <span class="keyword">if</span> (!uf.connected(v, w)) &#123;</div><div class="line">				<span class="comment">// 将v和w归并(对于union-find数据结构中而言),然后将边添加进树中,并计算更新权重</span></div><div class="line">                uf.union(v, w); </div><div class="line">                mst.add(e);</div><div class="line">                weight += e.weight();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mst;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码实现的<code>Kruskal算法</code>使用了一条队列来保存<code>最小生成树</code>的边集,一条优先队列来保存还未检查的边,一个<code>Union-Find</code>来判断失效边.</p>
<h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><hr>
<table>
<thead>
<tr>
<th>算法</th>
<th>空间复杂度</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prim(延时)</td>
<td>E</td>
<td>ElogE</td>
</tr>
<tr>
<td>Prim(即时)</td>
<td>V</td>
<td>ElogV</td>
</tr>
<tr>
<td>Kruskal</td>
<td>E</td>
<td>ElogE</td>
</tr>
</tbody>
</table>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><hr>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree" target="_blank" rel="external">Minimum spanning tree - Wikipedia</a></li>
</ul>
<ul>
<li><a href="http://algs4.cs.princeton.edu/43mst/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></li>
</ul>
<h3 id="图的那点事儿"><a href="#图的那点事儿" class="headerlink" title="图的那点事儿"></a>图的那点事儿</h3><hr>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/">图的那点事儿(1)-无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/">图的那点事儿(2)-有向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/">图的那点事儿(3)-加权无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph">图的那点事儿(4)-加权有向图</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文作者为: &lt;a href=&quot;https://github.com/SylvanasSun&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SylvanasSun&lt;/a&gt;.转载请务必将下面这段话置于文章开头处(保留超链接).&lt;br
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/categories/Algorithms/Graph/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>图的那点事儿(2)-有向图</title>
    <link href="https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/"/>
    <id>https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/</id>
    <published>2017-07-23T03:00:00.000Z</published>
    <updated>2017-07-30T08:15:33.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文作者为: <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a>.转载请务必将下面这段话置于文章开头处(保留超链接).<br>本文转发自<a href="https://sylvanassun.github.io/">SylvanasSun Blog</a>,原文链接: <a href="https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/">https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/</a></p>
</blockquote>
<h3 id="有向图的性质"><a href="#有向图的性质" class="headerlink" title="有向图的性质"></a>有向图的性质</h3><hr>
<p><code>有向图</code>与<code>无向图</code>不同,<strong>它的<code>边</code>是单向的,每条边所连接的两个顶点都是一个有序对,它们的邻接性是单向的.</strong></p>
<p>在<code>有向图</code>中,一条<code>有向边</code><strong>由第一个<code>顶点</code>指出并指向第二个<code>顶点</code></strong>,<strong>一个<code>顶点</code>的<code>出度</code>为由该<code>顶点</code>指出的<code>边</code>的总数;一个<code>顶点</code>的<code>入度</code>为指向该<code>顶点</code>的边的总数</strong>.</p>
<p><img src="http://algs4.cs.princeton.edu/42digraph/images/digraph-anatomy.png" alt="有向图的解析"></p>
<p><code>v-&gt;w</code>表示一条由<code>v</code>指向<code>w</code>的边,在一幅<code>有向图</code>中,两个<code>顶点</code>的关系可能有以下四种(特殊图除外): </p>
<ol>
<li>没有<code>边</code>相连.</li>
</ol>
<ol>
<li>存在一条从<code>v</code>到<code>w</code>的<code>边</code>: <code>v-&gt;w</code>.</li>
</ol>
<ol>
<li>存在一条从<code>w</code>到<code>v</code>的<code>边</code>: <code>w-&gt;v</code>.</li>
</ol>
<ol>
<li>既存在<code>v-&gt;w</code>,也存在<code>w-&gt;v</code>,也就是一条<code>双向边</code>.</li>
</ol>
<p>当存在从<code>v</code>到<code>w</code>的<code>有向路径</code>时,称<code>顶点w</code>能够由<code>顶点v</code>达到.但在<code>有向图</code>中,由<code>v</code>能够到达<code>w</code>并不意味着由<code>w</code>也能到达<code>v</code>(但每个<code>顶点</code>都是能够到达它自己的).</p>
<h3 id="有向图的实现"><a href="#有向图的实现" class="headerlink" title="有向图的实现"></a>有向图的实现</h3><hr>
<p><code>有向图</code>的实现与<code>无向图</code>差不多,只不过在<code>边</code>的方向上有所不同.(本文中的所有完整代码可以在我的<a href="https://github.com/SylvanasSun/algs4-study/tree/master/src/main/java/chapter4_graphs/C4_2_DirectedGraphs" target="_blank" rel="external">GitHub</a>中查看)</p>
<p><img src="http://algs4.cs.princeton.edu/42digraph/images/digraph-api.png" alt="有向图的API"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> <span class="keyword">implements</span> <span class="title">Graph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEWLINE = System.getProperty(<span class="string">"line.separator"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// number of vertices in this digraph</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vertex;</div><div class="line"></div><div class="line">    <span class="comment">// number of edges in this digraph</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edge;</div><div class="line"></div><div class="line">    <span class="comment">// adj[v] = adjacency list for vertex v</span></div><div class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;</div><div class="line"></div><div class="line">    <span class="comment">// indegree[v] = indegree of vertex v</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indegree;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.vertex = vertex;</div><div class="line">        <span class="keyword">this</span>.edge = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.indegree = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex; i++)</div><div class="line">            adj[i] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(Scanner scanner)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (scanner == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Scanner must be not null."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> vertex = scanner.nextInt();</div><div class="line">            validateVertex(vertex);</div><div class="line">            <span class="keyword">this</span>.vertex = vertex;</div><div class="line">            <span class="keyword">this</span>.indegree = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">            <span class="keyword">this</span>.adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[vertex];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex; i++)</div><div class="line">                adj[i] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> edge = scanner.nextInt();</div><div class="line">            validateEdge(edge);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; i++) &#123;</div><div class="line">                <span class="keyword">int</span> v = scanner.nextInt();</div><div class="line">                <span class="keyword">int</span> w = scanner.nextInt();</div><div class="line">                addEdge(v, w);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid input format in Digraph constructor"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(Digraph digraph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(digraph.vertex);</div><div class="line">        <span class="keyword">this</span>.edge = digraph.edge;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            <span class="keyword">this</span>.indegree[v] = digraph.indegree(v);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : digraph.adj(v))</div><div class="line">                reverse.push(w);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : reverse)</div><div class="line">                <span class="keyword">this</span>.adj[v].add(w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">vertex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vertex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">edge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> edge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注意这里与无向图不同,只在v的邻接表中添加了w</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        adj[v].add(w);</div><div class="line">		<span class="comment">// w的入度+ 1</span></div><div class="line">        indegree[w]++;</div><div class="line">        edge++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indegree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> indegree[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">	 * v的出度就是它邻接表中的顶点数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outdegree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v].size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adj[v].size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 它返回该有向图的一个副本,但所有边的方向都会被反转.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Digraph <span class="title">reverse</span><span class="params">()</span> </span>&#123;</div><div class="line">        Digraph reverse = <span class="keyword">new</span> Digraph(vertex);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v]) &#123;</div><div class="line">                reverse.addEdge(w, v);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> reverse;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(String.format(<span class="string">"Vertexes: %s, Edges: %s"</span>, vertex, edge));</div><div class="line">        sb.append(NEWLINE);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            sb.append(String.format(<span class="string">"vertex %d, "</span>, v));</div><div class="line">            sb.append(String.format(<span class="string">"indegree: %d, outdegree: %d"</span>, indegree(v), outdegree(v)));</div><div class="line">            sb.append(NEWLINE);</div><div class="line">            sb.append(<span class="string">"adjacent point: "</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v])</div><div class="line">                sb.append(w).append(<span class="string">" "</span>);</div><div class="line"></div><div class="line">            sb.append(NEWLINE);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateEdge</span><span class="params">(<span class="keyword">int</span> edge)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (edge &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of edges in a Digraph must be nonnegative."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of vertex in a Digraph must be nonnegative."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><hr>
<p>对于”是否存在一条从集合中的任意<code>顶点</code>到达给定<code>顶点v</code>的有向路径?”等类似问题,可以使用<code>深度优先搜索</code>或<code>广度优先搜索</code>(与<code>无向图</code>的实现一致,只不过传入的<code>图</code>的类型不同),<code>有向图</code>生成的搜索轨迹甚至要比<code>无向图</code>还要简单.</p>
<p>对于<code>可达性分析</code>的一个典型应用就是内存管理系统.例如,<code>JVM</code>使用<code>多点可达性分析</code>的方法来判断一个<code>对象</code>是否可以进行回收: 所有<code>对象</code>组成一幅<code>有向图</code>,其中有多个<code>Root顶点</code>(它是由<code>JVM</code>自己决定的)作为<code>起点</code>,如果一个<code>对象</code>从<code>Root顶点</code>不可达,那么这个<code>对象</code>就可以进行回收了.</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><hr>
<p>在与<code>有向图</code>相关的实际应用中,<code>有向环</code>特别的重要.我们需要知道一幅<code>有向图</code>中是否包含<code>有向环</code>.在任务调度问题或其他许多问题中会不允许存在<code>有向环</code>,所以对于<code>环</code>的检测是很重要的.</p>
<p>使用<code>深度优先搜索</code>解决这个问题并不困难,递归调用隐式使用的栈表示的正是”当前”正在遍历的<code>有向路径</code>,一旦找到了一条<code>边v-&gt;w</code>且<code>w</code>已经存在于栈中,就等于找到了一个<code>环</code>(栈表示的是一条由<code>w</code>到<code>v</code>的<code>有向路径</code>,而<code>v-&gt;w</code>正好补全了这个<code>环</code>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Digraph digraph;</div><div class="line"></div><div class="line">    <span class="comment">// marked[v] = has vertex v been marked?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="comment">// edgeTo[v] = previous vertex on path to v</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] edgeTo;</div><div class="line"></div><div class="line">    <span class="comment">// onStack[v] = is vertex on the stack?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] onStack;</div><div class="line"></div><div class="line">    <span class="comment">// directed cycle (or null if no such cycle)</span></div><div class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph digraph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.digraph = digraph;</div><div class="line">        <span class="keyword">int</span> vertex = digraph.vertex();</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">			<span class="comment">// 已经找到环时就不再需要继续搜索了</span></div><div class="line">            <span class="keyword">if</span> (!marked[v] &amp;&amp; cycle == <span class="keyword">null</span>)</div><div class="line">                dfs(v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">cycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cycle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        marked[vertex] = <span class="keyword">true</span>;</div><div class="line">        onStack[vertex] = <span class="keyword">true</span>; <span class="comment">// 用于模拟递归调用栈</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : digraph.adj(vertex)) &#123;</div><div class="line">            <span class="keyword">if</span> (cycle != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;</div><div class="line">                edgeTo[w] = vertex;</div><div class="line">                dfs(w);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) &#123;</div><div class="line">				<span class="comment">// 当w已被标记且在栈中时: 找到环</span></div><div class="line">                cycle = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = vertex; x != w; x = edgeTo[x])</div><div class="line">                    cycle.push(x);</div><div class="line">                cycle.push(w);</div><div class="line">                cycle.push(vertex);</div><div class="line">                <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">// 这条路径已经到头,从栈中弹出</span></div><div class="line">        onStack[vertex] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// certify that digraph has a directed cycle if it reports one</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (hasCycle()) &#123;</div><div class="line">            <span class="comment">// verify cycle</span></div><div class="line">            <span class="keyword">int</span> first = -<span class="number">1</span>, last = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v : cycle()) &#123;</div><div class="line">                <span class="keyword">if</span> (first == -<span class="number">1</span>) first = v;</div><div class="line">                last = v;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (first != last) &#123;</div><div class="line">                System.err.printf(<span class="string">"cycle begins with %d and ends with %d\n"</span>, first, last);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><hr>
<p><code>拓扑排序</code>等价于计算优先级限制下的调度问题的,所谓优先级限制的调度问题即是在给定一组需要完成的任务与关于任务完成的先后次序的优先级限制,需要在满足限制条件的前提下来安排任务.</p>
<p><code>拓扑排序</code>需要的是一幅<code>有向无环图</code>,如果这幅<code>图</code>中含有<code>环</code>,那么它肯定不是<code>拓扑有序</code>的(一个带有环的调度问题是无解的).</p>
<p>在学习<code>拓扑排序</code>之前,需要先知道<code>顶点</code>的排序.</p>
<h4 id="顶点排序"><a href="#顶点排序" class="headerlink" title="顶点排序"></a>顶点排序</h4><hr>
<p>使用<code>深度优先搜索</code>来记录<code>顶点排序</code>是一个很好的选择(正好只会访问每个<code>顶点</code>一次),我们借助一些<code>数据结构</code>来保存<code>顶点排序</code>的顺序: </p>
<ul>
<li>前序: 在递归调用之前将<code>顶点</code>加入队列.</li>
</ul>
<ul>
<li>后序: 在递归调用之后将<code>顶点</code>加入队列.</li>
</ul>
<ul>
<li>逆后序: 在递归调用之后将<code>顶点</code>压入栈.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/42digraph/images/depth-first-orders.png" alt="顶点排序的轨迹"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line"></div><div class="line">    <span class="comment">// marked[v] = has v been marked in dfs?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="comment">// pre[v]    = preorder  number of v</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] pre;</div><div class="line"></div><div class="line">    <span class="comment">// post[v]   = postorder number of v</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] post;</div><div class="line"></div><div class="line">    <span class="comment">// vertices in preorder</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; preorder;</div><div class="line"></div><div class="line">    <span class="comment">// vertices in postorder</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; postorder;</div><div class="line"></div><div class="line">    <span class="comment">// counter or preorder numbering</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> preCounter;</div><div class="line"></div><div class="line">    <span class="comment">// counter for postorder numbering</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> postCounter;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(Graph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.post = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.preorder = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.postorder = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            <span class="keyword">if</span> (!marked[v]) dfs(v);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> pre[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> post[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">post</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> postorder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pre</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> preorder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 逆后序,遍历后序队列并压入栈中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">reversePost</span><span class="params">()</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : postorder)</div><div class="line">            reverse.push(v);</div><div class="line">        <span class="keyword">return</span> reverse;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        marked[vertex] = <span class="keyword">true</span>;</div><div class="line">		<span class="comment">// 前序</span></div><div class="line">        pre[vertex] = preCounter++;</div><div class="line">        preorder.add(vertex);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(vertex)) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[w])</div><div class="line">                dfs(w);</div><div class="line">        &#125;</div><div class="line">		<span class="comment">// 后序</span></div><div class="line">        post[vertex] = postCounter++;</div><div class="line">        postorder.add(vertex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check that pre() and post() are consistent with pre(v) and post(v)</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// check that post(v) is consistent with post()</span></div><div class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : post()) &#123;</div><div class="line">            <span class="keyword">if</span> (post(v) != r) &#123;</div><div class="line">                System.out.println(<span class="string">"post(v) and post() inconsistent"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            r++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check that pre(v) is consistent with pre()</span></div><div class="line">        r = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : pre()) &#123;</div><div class="line">            <span class="keyword">if</span> (pre(v) != r) &#123;</div><div class="line">                System.out.println(<span class="string">"pre(v) and pre() inconsistent"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            r++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> V = marked.length;</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h4><hr>
<p>所谓<code>拓扑排序</code>就是<code>无环有向图</code>的<code>逆后序</code>,现在已经知道了如何检测<code>环</code>与<code>顶点排序</code>,那么实现<code>拓扑排序</code>就很简单了.</p>
<p><img src="http://algs4.cs.princeton.edu/42digraph/images/topological-sort.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Topological</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// topological order</span></div><div class="line">    <span class="keyword">private</span> Iterable&lt;Integer&gt; order;</div><div class="line"></div><div class="line">    <span class="comment">// rank[v] = position of vertex v in topological order</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Topological</span><span class="params">(Digraph digraph)</span> </span>&#123;</div><div class="line">        DirectedCycle directedCycle = <span class="keyword">new</span> DirectedCycle(digraph);</div><div class="line">		<span class="comment">// 只有这幅图没有环时,才进行计算拓扑排序</span></div><div class="line">        <span class="keyword">if</span> (!directedCycle.hasCycle()) &#123;</div><div class="line">            DepthFirstOrder depthFirstOrder = <span class="keyword">new</span> DepthFirstOrder(digraph);</div><div class="line">			<span class="comment">// 拓扑排序即是逆后序</span></div><div class="line">            order = depthFirstOrder.reversePost();</div><div class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[digraph.vertex()];</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v : order)</div><div class="line">                rank[v] = i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">order</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> order;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> order != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">if</span> (hasOrder()) <span class="keyword">return</span> rank[v];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> V = rank.length;</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="强连通性"><a href="#强连通性" class="headerlink" title="强连通性"></a>强连通性</h3><hr>
<p>在一幅<code>无向图</code>中,如果有一条路径连接顶点<code>v</code>和<code>w</code>,则它们就是<code>连通</code>的(既可以从<code>w</code>到达<code>v</code>,也可以从<code>v</code>到达<code>w</code>).但在<code>有向图</code>中,如果从顶点<code>v</code>有一条有向路径到达<code>w</code>,则<code>w</code>是从<code>v</code>可达的,但从<code>w</code>到达<code>v</code>的路径可能存在也可能不存在.</p>
<p><strong><code>强连通性</code>就是两个顶点<code>v</code>和<code>w</code>是互相可达的.</strong><code>有向图</code>中的<code>强连通性</code>具有以下性质: </p>
<ul>
<li>自反性: 任意<code>顶点v</code>和自己都是<code>强连通性</code>的(<code>有向图</code>中顶点都是自己可达的).</li>
</ul>
<ul>
<li>对称性: 如果<code>v</code>和<code>w</code>是强连通的,那么<code>w</code>和<code>v</code>也是强连通的.</li>
</ul>
<ul>
<li>传递性: 如果<code>v</code>和<code>w</code>是强连通的且<code>w</code>和<code>x</code>也是强连通的,那么<code>v</code>和<code>x</code>也是强连通的.</li>
</ul>
<p><code>强连通性</code>将所有<code>顶点</code>分为了一些等价类,每个等价类都是由相互为强连通的<code>顶点</code>的最大子集组成的.这些子集称为<code>强连通分量</code>,它的定义是基于顶点的,而非边.</p>
<p>一个含有<code>V</code>个顶点的<code>有向图</code>含有<code>1 ~ V</code>个<code>强连通分量</code>.一个<code>强连通图</code>只含有一个<code>强连通分量</code>,而一个<code>有向无环图</code>中则含有<code>V</code>个<code>强连通分量</code>.</p>
<h4 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h4><hr>
<p><a href="https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm" target="_blank" rel="external">Kosaraju</a>算法是用于枚举图中每个<code>强连通分量</code>内的所有顶点,它主要有以下步骤: </p>
<ul>
<li>在给定一幅<code>有向图</code>$G$中,取得它的反向图$G^R$.</li>
</ul>
<ul>
<li>利用<code>深度优先搜索</code>得到$G^R$的逆后序排列.</li>
</ul>
<ul>
<li>按照上述逆后序的序列进行<code>深度优先搜索</code></li>
</ul>
<ul>
<li>同一个<code>深度优先搜索</code>递归子程序中访问的所有<code>顶点</code>都在同一个<code>强连通分量</code>内.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KosarajuSharirSCC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Digraph digraph;</div><div class="line"></div><div class="line">    <span class="comment">// marked[v] = has vertex v been visited?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="comment">// id[v] = id of strong component containing v</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] id;</div><div class="line"></div><div class="line">    <span class="comment">// number of strongly-connected components</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KosarajuSharirSCC</span><span class="params">(Digraph digraph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.digraph = digraph;</div><div class="line">        <span class="keyword">int</span> vertex = digraph.vertex();</div><div class="line"></div><div class="line">        <span class="comment">// compute reverse postorder of reverse graph</span></div><div class="line">        DepthFirstOrder depthFirstOrder = <span class="keyword">new</span> DepthFirstOrder(digraph.reverse());</div><div class="line"></div><div class="line">        <span class="comment">// run DFS on G, using reverse postorder to guide calculation</span></div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : depthFirstOrder.reversePost()) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[v]) &#123;</div><div class="line">                dfs(v);</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check that id[] gives strong components</span></div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">(digraph)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        id[v] = count;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : digraph.adj(v)) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[w])</div><div class="line">                dfs(w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stronglyConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        <span class="keyword">return</span> id[v] == id[w];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> id[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// does the id[] array contain the strongly connected components?</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Digraph G)</span> </span>&#123;</div><div class="line">        TransitiveClosure tc = <span class="keyword">new</span> TransitiveClosure(G);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vertex(); v++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.vertex(); w++) &#123;</div><div class="line">                <span class="keyword">if</span> (stronglyConnected(v, w) != (tc.reachable(v, w) &amp;&amp; tc.reachable(w, v)))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> V = marked.length;</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h3><hr>
<p><img src="http://algs4.cs.princeton.edu/42digraph/images/transitive-closure.png" alt=""></p>
<p>在一幅有向图<code>G</code>中,<code>传递闭包</code>是由相同的一组<code>顶点</code>组成的另一幅<code>有向图</code>,在<code>传递闭包</code>中存在一条从<code>v</code>指向<code>w</code>的边且仅当在<code>G</code>中<code>w</code>是从<code>v</code>可达的.</p>
<p>由于<code>有向图</code>的性质,每个<code>顶点</code>对于自己都是可达的,所以<code>传递闭包</code>会含有<code>V</code>个自环.</p>
<p>通常将<code>传递闭包</code>表示为一个布尔值矩阵,其中<code>v</code>行<code>w</code>列的值为<code>true</code>代表当且仅当<code>w</code>是从<code>v</code>可达的.</p>
<p><code>传递闭包</code>不适合于处理<code>大型有向图</code>,因为构造函数所需的空间与$V^2$成正比,所需的时间和$V(V+E)$成正比.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransitiveClosure</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DirectedDFS[] tc;  <span class="comment">// tc[v] = reachable from v</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransitiveClosure</span><span class="params">(Digraph G)</span> </span>&#123;</div><div class="line">        tc = <span class="keyword">new</span> DirectedDFS[G.vertex()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vertex(); v++)</div><div class="line">            tc[v] = <span class="keyword">new</span> DirectedDFS(G, v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachable</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        <span class="keyword">return</span> tc[v].marked(w);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> V = tc.length;</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><hr>
<ul>
<li><a href="http://algs4.cs.princeton.edu/42digraph/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm" target="_blank" rel="external">Kosaraju’s algorithm - Wikipedia</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Transitive_closure" target="_blank" rel="external">Transitive closure - Wikipedia</a></li>
</ul>
<h3 id="图的那点事儿"><a href="#图的那点事儿" class="headerlink" title="图的那点事儿"></a>图的那点事儿</h3><hr>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/">图的那点事儿(1)-无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/">图的那点事儿(2)-有向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/">图的那点事儿(3)-加权无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph">图的那点事儿(4)-加权有向图</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文作者为: &lt;a href=&quot;https://github.com/SylvanasSun&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SylvanasSun&lt;/a&gt;.转载请务必将下面这段话置于文章开头处(保留超链接).&lt;br
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/categories/Algorithms/Graph/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>电影&lt;&lt;社交网络&gt;&gt;中的&quot;FaceMash&quot;算法</title>
    <link href="https://sylvanassun.github.io/2017/07/19/2017-07-19-FaceMash/"/>
    <id>https://sylvanassun.github.io/2017/07/19/2017-07-19-FaceMash/</id>
    <published>2017-07-19T10:00:00.000Z</published>
    <updated>2017-07-19T11:02:26.668Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img3.doubanio.com/view/photo/raw/public/p679478005.jpg" alt=""></p>
<blockquote>
<p>最近在看<a href="https://movie.douban.com/subject/3205624/" target="_blank" rel="external">&lt;&lt;社交网络&gt;&gt;</a>时,发现了一个用于投票排名的算法,自己折腾实现了一下.</p>
</blockquote>
<p>在影片中,卷西饰演的扎克伯格在被妹子甩了之后(其实是他自己直男癌),一气之下黑了附近女生宿舍的照片数据库打算做一个<code>FaceMash</code>(通过投票的方式来选出漂亮的女生,同时它也是<code>Facebook</code>的前身,后来这个网站由于流量太大,搞崩了哈佛大学的网络而被强行关闭了),并使用了他的好基友爱德华多用于计算国际象棋排名的算法.</p>
<p><strong>这是一部很好看的电影,如果没有看过我强烈推荐去看一看.</strong></p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><hr>
<p><img src="http://wx4.sinaimg.cn/large/63503acbly1fhpbwf3qy2j20vx0hx74u.jpg" alt=""></p>
<p>这个算法是用来计算<code>期望胜率</code>的,但影片中其实写的是错误的,正确的公式应该为: </p>
<p>$$E_a = \frac{1} {1 + 10 ^ {(R_b - R_a) / 400}}$$</p>
<ul>
<li>$E_a$就是<code>a</code>的期望胜率.</li>
</ul>
<ul>
<li>$R_b,R_a$是<code>b</code>与<code>a</code>的<code>Rank</code>分数.</li>
</ul>
<ul>
<li>当$R_a,R_b$都相同时,它们的<code>期望胜率</code>都为<code>0.5</code>,即$E_a = \frac{1} {1+10^0} = 0.5$.</li>
</ul>
<p>电影中只给出了计算<code>期望胜率</code>的算法,但我们还需要一个计算新的<code>Rank</code>分数的算法,公式如下: </p>
<p>$$R_n = R_o + K(W - E)$$</p>
<ul>
<li>$R_n$代表新的<code>Rank</code>,$R_o$自然就是旧的<code>Rank</code>了.</li>
</ul>
<ul>
<li><code>K</code>为一个定值,我把它设为<code>10</code>.</li>
</ul>
<ul>
<li><code>W</code>是<code>胜负值</code>,胜者为<code>1</code>,败者为<code>0</code>;<code>E</code>就是我们上面计算的<code>期望胜率</code>.</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><hr>
<p>有了这两个核心公式,我们就可以开始实现这个算法了,但在代码实现之前,我们先验证一下公式: </p>
<p>假设有两个女孩<code>A</code>与<code>B</code>,她们的基础<code>Rank</code>都为<code>1400</code>,通过上述的推论我们已经得知,<strong><code>当A</code>,<code>B</code>的分值相同时,她们的期望胜率都为0.5</strong>.</p>
<p>如果,我选择了<code>A</code>,则<code>A</code>的胜负值变为<code>1</code>,<code>B</code>的胜负值为<code>0</code>,然后我们套用公式2可以得出: </p>
<ul>
<li>$R_a = 1400 + 10 * (1 - 0.5) = 1405$</li>
</ul>
<ul>
<li>$R_b = 1400 + 10 * (0 - 0.5) = 1395$</li>
</ul>
<p>由于她们的分数不再相同,所以套用公式1计算现在的<code>期望胜率</code>: </p>
<ul>
<li>$R_a = \frac{1} {1 + 10 ^ {(1395 - 1405) / 400}} \approx 0.51439 $</li>
</ul>
<ul>
<li>$R_b = \frac{1} {1 + 10 ^ {(1405 - 1395) / 400}} \approx 0.48561$</li>
</ul>
<p>下面是我用<code>C</code>写的一个小程序,它初始化了两个”女孩”,然后根据输入来判断哪个胜出,并动态计算<code>Rank</code>与<code>期望胜率</code>.</p>
<p><img src="http://wx1.sinaimg.cn/mw690/63503acbly1fhpcccyw1bj20di0gcdg7.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">int</span> rank;</div><div class="line">    <span class="keyword">double</span> expect_rate;</div><div class="line">&#125; girl;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_girl</span><span class="params">(girl g)</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Girl name: %s, rank: %d, expect_rate: %.5f\n"</span>,g.name,g.rank,g.expect_rate);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_expect_rate</span><span class="params">(girl *a,girl *b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a_rank = a-&gt;rank;</div><div class="line">    <span class="keyword">int</span> b_rank = b-&gt;rank;</div><div class="line">    <span class="comment">// expect rate formula</span></div><div class="line">    <span class="comment">// Ea = 1 / (1 + 10 ^ ((Rb-Ra) / 400))</span></div><div class="line">    <span class="keyword">double</span> a_rank_differ = (<span class="keyword">double</span>) (b_rank - a_rank) / <span class="number">400</span>;</div><div class="line">    <span class="keyword">double</span> a_rank_rate = <span class="built_in">pow</span>(<span class="number">10</span>,a_rank_differ);</div><div class="line">    a-&gt;expect_rate = <span class="number">1</span> / (<span class="number">1</span> + a_rank_rate);</div><div class="line">    <span class="comment">// Eb = 1 / (1 + 10 ^ ((Ra-Rb) / 400))</span></div><div class="line">    <span class="keyword">double</span> b_rank_differ = (<span class="keyword">double</span>) (a_rank - b_rank) / <span class="number">400</span>;</div><div class="line">    <span class="keyword">double</span> b_rank_rate = <span class="built_in">pow</span>(<span class="number">10</span>,b_rank_differ);</div><div class="line">    b-&gt;expect_rate = <span class="number">1</span> / (<span class="number">1</span> + b_rank_rate);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new rank formula: Rn = Ro + K(W - E)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_rank</span><span class="params">(girl *a,girl *b,<span class="keyword">int</span> a_win_rate,<span class="keyword">int</span> b_win_rate)</span> </span>&#123;</div><div class="line">    a-&gt;rank = a-&gt;rank + K * (a_win_rate - a-&gt;expect_rate);</div><div class="line">    b-&gt;rank = b-&gt;rank + K * (b_win_rate - b-&gt;expect_rate);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> a_girl_name[<span class="number">20</span>];</div><div class="line">    <span class="keyword">char</span> b_girl_name[<span class="number">20</span>];</div><div class="line"></div><div class="line">    girl a = &#123;.name = <span class="string">"A Gril"</span>,.rank = <span class="number">1400</span>&#125;;</div><div class="line">    girl b = &#123;.name = <span class="string">"B Gril"</span>,.rank = <span class="number">1400</span>&#125;;</div><div class="line"></div><div class="line">    compute_expect_rate(&amp;a,&amp;b);</div><div class="line"></div><div class="line">    read_girl(a);</div><div class="line">    read_girl(b);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">char</span> choice[<span class="number">2</span>];</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Choice A or B?\n"</span>);</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,choice);</div><div class="line">        <span class="keyword">if</span> (choice[<span class="number">0</span>] == <span class="string">'A'</span>) &#123;</div><div class="line">            compute_rank(&amp;a,&amp;b,<span class="number">1</span>,<span class="number">0</span>);</div><div class="line">            compute_expect_rate(&amp;a,&amp;b);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice[<span class="number">0</span>] == <span class="string">'B'</span>) &#123;</div><div class="line">            compute_rank(&amp;a,&amp;b,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">            compute_expect_rate(&amp;a,&amp;b);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Invalid choice!\n"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        read_girl(a);</div><div class="line">        read_girl(b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/view/photo/raw/public/p679478005.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在看&lt;a href=&quot;https://movie.douban.c
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="Other" scheme="https://sylvanassun.github.io/categories/Algorithms/Other/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>图的那点事儿(1)-无向图</title>
    <link href="https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/"/>
    <id>https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/</id>
    <published>2017-07-18T03:00:00.000Z</published>
    <updated>2017-07-30T08:15:18.246Z</updated>
    
    <content type="html"><![CDATA[<p>在数学中,一个<code>图(Graph)</code>是表示物件与物件之间关系的方法,是<code>图论</code>的基本研究对象.一个图是由<code>顶点(Vertex)</code>与连接这些<code>顶点</code>的<code>边(Edge)</code>组成的.</p>
<p><code>图论</code>作为数学领域中的一个重要分支已经有数百年的历史了.人们发现了图的许多重要而实用的性质,发明了许多重要的算法,给你一个<code>图(Graph)</code>你可以联想到许多问题: 两个<code>顶点</code>之间是否存在一条链接?如果存在,两个<code>顶点</code>之间最短的连接又是哪一条?….</p>
<p>在生活中,到处都可以发现<code>图论</code>的应用: </p>
<ul>
<li>地图: 在使用地图中,我们经常会想知道”从xx到xx的最短路线”这样的问题,要回答这些问题,就需要把地图抽象成一个<code>图(Graph)</code>,十字路口就是<code>顶点</code>,公路就是<code>边</code>.</li>
</ul>
<ul>
<li>互联网: 整个互联网其实就是一张<code>图</code>,它的<code>顶点</code>为网页,<code>边</code>为超链接.而<code>图论</code>可以帮助我们在网络上定位信息.</li>
</ul>
<ul>
<li>任务调度: 当一些任务拥有优先级限制且需要满足前置条件时,如何在满足条件的情况下用最少的时间完成就需要用到<code>图论</code>.</li>
</ul>
<ul>
<li>社交网络: 在使用社交网站时,你就是一个<code>顶点</code>,你和你的朋友建立的关系则是<code>边</code>.分析这些社交网络的性质也是<code>图论</code>的一个重要应用.</li>
</ul>
<p><strong><code>图</code>就是由一组<code>顶点</code>和一组能够将两个<code>顶点</code>相连的<code>边</code>组成的.</strong></p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><hr>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/graph-anatomy.png" alt="图中的元素"></p>
<ul>
<li>相邻: 当两个<code>顶点</code>通过一条<code>边</code>相连接时,这两个<code>顶点</code>即为相邻的(也可以说这条<code>边</code>依附于这两个<code>顶点</code>).</li>
</ul>
<ul>
<li>度数: 某个<code>顶点</code>的<code>度数</code>即为依附于它的<code>边</code>的总数.</li>
</ul>
<ul>
<li>阶: <code>图G</code>中的<code>顶点集合V</code>的大小称为<code>G</code>的阶.</li>
</ul>
<ul>
<li>自环: 一条连接一个<code>顶点</code>和其自身的<code>边</code>.</li>
</ul>
<ul>
<li><p>平行边: 连接同一对<code>顶点</code>的两条<code>边</code>称为平行边.</p>
</li>
<li><p>桥: 如果去掉一条<code>边</code>会使整个<code>图</code>变成<code>非连通图</code>,则该<code>边</code>称为桥.</p>
</li>
<li><p>路径: 当<code>顶点v</code>到<code>顶点w</code>是连通时,我们用<code>v-&gt;x-&gt;y-&gt;w</code>为一条<code>v</code>到<code>w</code>的路径,用<code>v-&gt;x-&gt;y-&gt;v</code>表示一条环.</p>
</li>
</ul>
<ul>
<li>子图: 也称作<code>连通分量</code>,它由一张<code>图</code>的所有边的一个子集组成的<code>图</code>(以及依附的所有顶点).</li>
</ul>
<ul>
<li>连通图: <code>连通图</code>是一个整体,而<code>非连通图</code>则包含两个或多个<code>连通分量</code>.</li>
</ul>
<ul>
<li>稀疏图: 如果一张图中不同的<code>边</code>的数量在<code>顶点</code>总数<code>V</code>的一个小的常数倍内,那么该图就为稀疏图,否则为稠密图.</li>
</ul>
<ul>
<li>简单图与多重图: 含有<code>平行边</code>与<code>自环</code>的图称为<code>多重图</code>,而不含有<code>平行边</code>和<code>自环</code>的图称为<code>简单图</code>.</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><hr>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/tree.png" alt="树"></p>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/forest.png" alt="森林"></p>
<p>树是一张<code>无环连通图</code>,互不相连的树组成的集合称为森林.<code>连通图</code>的<code>生成树</code>是它的一张子图,它含有图中的所有顶点且是一棵树.图的<code>生成树森林</code>是它的所有<code>连通分量</code>的<code>生成树</code>的集合.</p>
<p>图<code>G</code>只要满足以下性质,那么它就是一棵树: </p>
<ul>
<li><code>G</code>有<code>V-1</code>条边且不含有环.</li>
</ul>
<ul>
<li><code>G</code>有<code>V-1</code>条边且是连通的.</li>
</ul>
<ul>
<li><code>G</code>是连通的,但删除任意一条边都会使它不再连通.</li>
</ul>
<ul>
<li><code>G</code>是无环图,但添加任意一条边都会产生一条环.</li>
</ul>
<ul>
<li><code>G</code>中的任意一对顶点之间仅存在一条简单路径(一条没有重复顶点的路径).</li>
</ul>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Simple-bipartite-graph.svg/600px-Simple-bipartite-graph.svg.png" alt="U和V就是两个顶点集合"></p>
<p><code>二分图</code>是一种能够将所有<code>顶点</code>分为两部分的图,其中<code>图</code>的每条边所连接的两个<code>顶点</code>都分别属于不同的部分.</p>
<p>设<code>G = (V,E)</code>为一张<code>无向图</code>,如果顶点<code>V</code>可以分割为两个互不相交的子集<code>(U,V)</code>,且图中的每条边<code>(x,y)</code>所关联的两个顶点<code>x</code>,<code>y</code>分别属于这两个不同的顶点集合<code>(x in U , y in V)</code>,则<code>G</code>为<code>二分图</code>.</p>
<p>也可以将<code>(U,V)</code>当做一张<code>着色图</code>: <code>U</code>中的所有顶点为蓝色,<code>V</code>中的所有顶点为绿色,每条边所关联的两个<code>顶点</code>颜色不同.</p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><hr>
<p><code>无向图</code>是一种最简单的图模型,它的每条边都没有方向.</p>
<h4 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h4><hr>
<p>实现一张<code>图</code>的<code>API</code>需要满足以下两个要求:</p>
<ol>
<li>必须为可能在应用中碰到的各种类型的<code>图</code>预留出足够的空间.</li>
</ol>
<ol>
<li><code>图</code>的实现一定要足够快(因为这是所有处理<code>图</code>的算法的基础结构).</li>
</ol>
<p>有以下三种数据结构能够用来表示一张图:</p>
<ul>
<li>邻接矩阵: 使用一个<code>V * V</code>的布尔矩阵.当顶点<code>v</code>和顶点<code>w</code>之间有相连接的<code>边</code>时,将<code>v</code>行<code>w</code>列的元素设为<code>true</code>,否则为<code>false</code>.这种方法不符合第一个条件,当<code>图</code>的顶点非常多时,邻接矩阵所需的空间将会非常大.且它无法表示平行边.</li>
</ul>
<ul>
<li>边的数组: 使用一个<code>Edge</code>类,它含有两个<code>int</code>成员变量来表示所依附的顶点.这种方法简单直接但不满足第二个条件(要实现查询邻接点的函数需要检查图中的所有边).</li>
</ul>
<ul>
<li>邻接表数组: <strong>使用一个<code>顶点</code>为索引的<code>链表数组</code>,其中的每个元素都是和该<code>顶点</code>相邻的顶点列表(邻接点)</strong>.这种方法同时满足了两个条件,我们会使用这种方法来实现<code>图</code>的数据结构.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/adjacency-lists.png" alt="邻接表数组"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Graph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vertex</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span> <span class="keyword">implements</span> <span class="title">Graph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vertex; <span class="comment">// 顶点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edge; <span class="comment">// 边</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bag&lt;Integer&gt;[] adjacent; <span class="comment">// 邻接表数组,Bag是一个没有实现删除操作的Stack</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UndirectedGraph</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        checkVertex(vertex);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.vertex = vertex;</div><div class="line">        <span class="keyword">this</span>.edge = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.adjacent = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            adjacent[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 读取一个文件并初始化为无向图</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UndirectedGraph</span><span class="params">(Scanner scanner)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (scanner == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified input stream must not null!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 文件的第一行为顶点数</span></div><div class="line">            <span class="keyword">this</span>.vertex = scanner.nextInt();</div><div class="line">            checkVertex(<span class="keyword">this</span>.vertex);</div><div class="line">			<span class="comment">// 文件的第二行为边数</span></div><div class="line">            <span class="keyword">int</span> edge = scanner.nextInt();</div><div class="line">            checkEdge(<span class="keyword">this</span>.edge);</div><div class="line">            <span class="keyword">this</span>.adjacent = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[<span class="keyword">this</span>.vertex];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="keyword">this</span>.vertex; v++)</div><div class="line">                adjacent[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</div><div class="line">			</div><div class="line">			<span class="comment">// 文件的剩余行为相连的顶点对 </span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; i++) &#123;</div><div class="line">                <span class="keyword">int</span> v = scanner.nextInt();</div><div class="line">                <span class="keyword">int</span> w = scanner.nextInt();</div><div class="line">                addEdge(v, w);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid input format in Undirected Graph constructor"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UndirectedGraph</span><span class="params">(Graph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(graph.vertex());</div><div class="line">        <span class="keyword">this</span>.edge = graph.edge();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="keyword">this</span>.vertex; v++) &#123;</div><div class="line">            <span class="comment">// reverse so that adjacency list is in same order as original</span></div><div class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(v))</div><div class="line">                stack.push(w);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : stack)</div><div class="line">                adjacent[v].add(w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkVertex</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of vertices must be positive number!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(<span class="keyword">int</span> edge)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (edge &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of edges must be positive number!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">vertex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vertex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">edge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> edge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 添加一条连接v和w的边,由于是无向图所以这条边会出现两次</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        adjacent[v].add(w);</div><div class="line">        adjacent[w].add(v);</div><div class="line">        edge++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adjacent[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> adjacent[v].size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex &lt; <span class="number">0</span> || vertex &gt;= <span class="keyword">this</span>.vertex)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Vertex "</span> + vertex + <span class="string">" is not between 0 and "</span> + (<span class="keyword">this</span>.vertex - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(<span class="string">"Vertices: "</span>).append(vertex).append(<span class="string">" Edges: "</span>).append(edge).append(NEW_LINE_SEPARATOR);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            sb.append(v).append(<span class="string">": "</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adjacent[v])</div><div class="line">                sb.append(w).append(<span class="string">" "</span>);</div><div class="line">            sb.append(NEW_LINE_SEPARATOR);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        InputStream inputStream =</div><div class="line">                UndirectedGraph.class.getResourceAsStream(<span class="string">"/graph_file/C4_1_UndirectedGraphs/"</span> + args[<span class="number">0</span>]);</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(inputStream, <span class="string">"UTF-8"</span>);</div><div class="line">        Graph graph = <span class="keyword">new</span> UndirectedGraph(scanner);</div><div class="line">        System.out.println(graph);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的这个实现拥有以下特点: </p>
<ul>
<li>使用的空间和<code>V + E</code>成正比.</li>
</ul>
<ul>
<li>添加一条边所需的时间为常数.</li>
</ul>
<ul>
<li>遍历顶点<code>v</code>的所有邻接点所需的时间和<code>v</code>的度数成正比(处理每个邻接点所需的时间为常数).</li>
</ul>
<ul>
<li>边的插入顺序决定了邻接表中顶点的出现顺序.</li>
</ul>
<ul>
<li>支持平行边与自环.</li>
</ul>
<ul>
<li>不支持添加或删除顶点的操作(如果想要支持这些操作需要使用一个<code>符号表</code>来代替由顶点索引构成的数组).</li>
</ul>
<ul>
<li>不支持删除边的操作(如果想要支持这个操作需要使用一个<code>SET</code>来代替<code>Bag</code>来实现邻接表,这种方法也叫<code>邻接集</code>).</li>
</ul>
<p>每种<code>图</code>实现的性能复杂度如下表: </p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>所需空间</th>
<th>添加一条边v - w</th>
<th>检查w和v是否相邻</th>
<th>遍历v的所有邻接点</th>
</tr>
</thead>
<tbody>
<tr>
<td>边的数组</td>
<td>E</td>
<td>1</td>
<td>E</td>
<td>E</td>
</tr>
<tr>
<td>邻接矩阵</td>
<td>V^2</td>
<td>1</td>
<td>1</td>
<td>V</td>
</tr>
<tr>
<td>邻接表</td>
<td>E+V</td>
<td>1</td>
<td>degree(V)</td>
<td>degree(V)</td>
</tr>
<tr>
<td>邻接集</td>
<td>E+V</td>
<td>logV</td>
<td>logV</td>
<td>logV+degree(V)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>本文中的所有完整代码可以到我的<a href="https://github.com/SylvanasSun/algs4-study/tree/master/src/main/java/chapter4_graphs/C4_1_UndirectedGraphs" target="_blank" rel="external">GitHub</a>中查看.</p>
</blockquote>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><hr>
<p>处理<code>图</code>的基本问题: <code>v 到 w是否是相连的?</code>. <code>深度优先搜索</code>就是用于解决这样问题的,它会<strong>沿着<code>图</code>的<code>边</code>寻找和<code>起点</code>连通的所有<code>顶点</code>.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/search-api.png" alt="搜索的基本API"></p>
<p>如其名一样,<code>深度优先搜素</code>就是沿着<code>图</code>的<code>深度</code>来遍历<code>顶点</code>,它类似于走迷宫,会沿着一条路径一直走,直到走到尽头时再回退到上一个路口.为了防止迷路,还需要使用工具来标记已走过的路口(在我们的代码实现中使用一个布尔数组来进行标记).</p>
<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><hr>
<p>使用递归方法来实现<code>深度优先搜索</code>会很简洁,当遇到一个<code>顶点</code>时:</p>
<ul>
<li>将它标记为已访问.</li>
</ul>
<ul>
<li>递归地访问它的所有没有被访问过的邻接点.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked; <span class="comment">// 标记已访问过的顶点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;  <span class="comment">// 记录起点连通的顶点数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph graph, <span class="keyword">int</span> originPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.vertex()];</div><div class="line">        validateVertex(originPoint);</div><div class="line">		<span class="comment">// 从起点开始进行深度优先搜索</span></div><div class="line">        depthSearch(originPoint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line">        <span class="keyword">return</span> marked[vertex];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">depthSearch</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        marked[vertex] = <span class="keyword">true</span>;</div><div class="line">        count++;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> adj : graph.adj(vertex)) &#123;</div><div class="line">			<span class="comment">// 遍历邻接点,如果未访问则递归调用</span></div><div class="line">            <span class="keyword">if</span> (!marked[adj])</div><div class="line">                depthSearch(adj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = marked.length;</div><div class="line">        <span class="keyword">if</span> (vertex &lt; <span class="number">0</span> || vertex &gt;= length)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Vertex "</span> + vertex + <span class="string">" is not between 0 and "</span> + (length - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><hr>
<p>如果是了解<code>JVM</code>中函数调用的小伙伴们应该知道,函数都会封装成一个个<code>栈帧</code>然后压入<code>虚拟机栈</code>,上述的递归实现其实就是在隐式的使用到了<code>栈</code>,要想实现非递归,我们需要显式使用<code>栈</code>这个数据结构.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonrecursiveDFS</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;Integer&gt;[] adj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonrecursiveDFS</span><span class="params">(Graph graph, <span class="keyword">int</span> originPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line"></div><div class="line">        validateVertex(originPoint);</div><div class="line"></div><div class="line">        <span class="comment">// 取出所有顶点的邻接表迭代器</span></div><div class="line">        adj = (Iterator&lt;Integer&gt;[]) <span class="keyword">new</span> Iterator[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++)</div><div class="line">            adj[v] = graph.adj(v).iterator();</div><div class="line"></div><div class="line">        dfs(originPoint);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> originPoint)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">		<span class="comment">// 标记起点并放入栈</span></div><div class="line">        marked[originPoint] = <span class="keyword">true</span>;</div><div class="line">        stack.push(originPoint);</div><div class="line">		</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            Integer v = stack.peek();</div><div class="line">			<span class="comment">// 遍历栈顶顶点的邻接点</span></div><div class="line">            <span class="keyword">if</span> (adj[v].hasNext()) &#123;</div><div class="line">                <span class="keyword">int</span> w = adj[v].next();</div><div class="line">				<span class="comment">// 如果未被访问,进行标记并放入栈中</span></div><div class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</div><div class="line">                    marked[w] = <span class="keyword">true</span>;</div><div class="line">                    stack.push(w);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// 当栈顶顶点的所有邻接点已经遍历完时,弹出栈</span></div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="寻找路径"><a href="#寻找路径" class="headerlink" title="寻找路径"></a>寻找路径</h3><hr>
<p>在<code>图</code>的应用中,找出<code>v-w</code>的可达路径也是常见的问题之一.</p>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/paths-api.png" alt="单点路径API"></p>
<p>我们基于<code>深度优先搜索</code>实现寻找路径,并添加一个<code>edgeTo[]</code>整形数组来记录路径.例如,在由边<code>v-w</code>第一次访问任意<code>w</code>时,将<code>edgeTo[w]</code>设为<code>v</code>来记录这条路径(<code>v-w</code>是从起点到<code>w</code>的路径上最后一条已知的边).这样搜索到的路径就是一颗以起点为根的树,<code>edgeTo[]</code>是一颗由父链接表示的树.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] edgeTo; <span class="comment">// 用于记录路径</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> originPoint;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph graph, <span class="keyword">int</span> originPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">this</span>.originPoint = originPoint;</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        validateVertex(originPoint);</div><div class="line">        dfs(originPoint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line">        <span class="keyword">return</span> marked[vertex];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line"></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">		<span class="comment">// 从指定顶点处向上遍历路径(直到起点)</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = vertex; x != originPoint; x = edgeTo[x])</div><div class="line">            stack.push(x);</div><div class="line">        stack.push(originPoint);</div><div class="line">        <span class="keyword">return</span> stack;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        marked[vertex] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> adj : graph.adj(vertex)) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[adj]) &#123;</div><div class="line">                marked[adj] = <span class="keyword">true</span>;</div><div class="line">				<span class="comment">// edgeTo[w] = v,记录了父链接</span></div><div class="line">                edgeTo[adj] = vertex;</div><div class="line">                dfs(adj);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><hr>
<p>对于寻找一条最短路径,<code>深度优先搜索</code>没有什么作为,因为它遍历整个图的顺序和找出最短路径的目标没有任何关系.这种问题就需要用到<code>广度优先搜索</code>.</p>
<p><code>广度优先搜索</code>是沿着宽度来进行搜索的.例如,要找到<code>s</code>到<code>v</code>的最短路径,<strong>从<code>s</code>开始,在所有由一条边就可以到达的<code>顶点</code>中寻找<code>v</code>,如果找不到就继续在与<code>s</code>距离两条边的所有顶点中寻找<code>v</code>,以此类推</strong>.</p>
<p>如果说<code>深度优先搜索</code>是一个人在走迷宫,那么<code>广度优先搜索</code>就是一群人一起朝着各个方向去走迷宫.</p>
<p>在<code>广度优先搜索</code>中,我们使用一个<code>队列</code>来保存所有已被标记过但<code>邻接表</code>还未被检查过的<code>顶点</code>.先将<code>起点</code>放入<code>队列</code>,然后重复以下步骤直到<code>队列</code>为空:</p>
<ul>
<li>取出<code>队列</code>中的下一个<code>顶点</code>并标记.</li>
</ul>
<ul>
<li>将它相邻的所有未被标记过的<code>顶点</code>加入队列.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] edgeTo;      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] distTo;      <span class="comment">// 记录路径中经过的顶点数,起点为0,需要全部初始化为无穷大</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph graph, <span class="keyword">int</span> originPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex; i++)</div><div class="line">            distTo[i] = INFINITY;</div><div class="line">        validateVertex(originPoint);</div><div class="line">        bfs(originPoint);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 以一组顶点为起点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph graph, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.distTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex; i++)</div><div class="line">            distTo[i] = INFINITY;</div><div class="line">        validateVertices(sources);</div><div class="line">        bfs(sources);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line">        <span class="keyword">return</span> marked[vertex];</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line">        <span class="keyword">return</span> distTo[vertex];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line"></div><div class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">		<span class="comment">// 这里使用distTo[x] != 0来判断是否为起点</span></div><div class="line">        <span class="keyword">for</span> (x = vertex; distTo[x] != <span class="number">0</span>; x = edgeTo[x])</div><div class="line">            path.push(x);</div><div class="line">        path.push(x);</div><div class="line">        <span class="keyword">return</span> path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        marked[vertex] = <span class="keyword">true</span>;</div><div class="line">        distTo[vertex] = <span class="number">0</span>;</div><div class="line">        queue.add(vertex);</div><div class="line"></div><div class="line">        searchAndMarkAdjacent(queue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Iterable&lt;Integer&gt; sources)</span> </span>&#123;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : sources) &#123;</div><div class="line">            marked[v] = <span class="keyword">true</span>;</div><div class="line">            distTo[v] = <span class="number">0</span>;</div><div class="line">            queue.add(v);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        searchAndMarkAdjacent(queue);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 广度优先搜索</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">searchAndMarkAdjacent</span><span class="params">(Queue&lt;Integer&gt; queue)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            Integer v = queue.remove();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> adj : graph.adj(v)) &#123;</div><div class="line">				<span class="comment">// 将未标记过的邻接点加入队列并进行标记等操作</span></div><div class="line">                <span class="keyword">if</span> (!marked[adj]) &#123;</div><div class="line">                    marked[adj] = <span class="keyword">true</span>;</div><div class="line">                    edgeTo[adj] = v;</div><div class="line">                    distTo[adj] = distTo[v] + <span class="number">1</span>;</div><div class="line">                    queue.add(adj);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = marked.length;</div><div class="line">        <span class="keyword">if</span> (vertex &lt; <span class="number">0</span> || vertex &gt;= length)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Vertex "</span> + vertex + <span class="string">" is not between 0 and "</span> + (length - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertices</span><span class="params">(Iterable&lt;Integer&gt; vertices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertices == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Vertices is null."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> length = marked.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : vertices) &#123;</div><div class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= length)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (length - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是<code>深度优先搜索</code>还是<code>广度优先搜索</code>,它们都是先将<code>起点</code>存入一个<code>数据结构</code>中,然后重复以下步骤直到<code>数据结构</code>被清空: </p>
<ul>
<li>取其中的下一个<code>顶点</code>并标记它.</li>
</ul>
<ul>
<li>将它的所有<code>相邻</code>而又未被标记的<code>顶点</code>放入<code>数据结构</code>中.</li>
</ul>
<p>这两种<code>算法</code>的<strong>不同之处仅在于从<code>数据结构</code>中获取下一个<code>顶点</code>的规则(对于<code>广度优先搜索</code>来说是最早加入的<code>顶点</code>,对于<code>深度优先搜索</code>来说是最晚加入的<code>顶点</code>)</strong>.</p>
<p><code>深度优先搜索</code>的方式是不断寻找离<code>起点</code>更远的<code>顶点</code>,直到碰见死胡同时才返回近处<code>顶点</code>.</p>
<p><code>广度优先搜索</code>的方式是先覆盖<code>起点</code>附近的<code>顶点</code>,只有当<code>邻接</code>的所有<code>顶点</code>都被访问过之后才继续前进.</p>
<p><code>深度优先搜素</code>的路径通常长且曲折,<code>广度优先搜索</code>的路径则短而直接.但不管是使用哪种<code>算法</code>,所有与<code>起点</code>连通的<code>顶点</code>和<code>边</code>都会被访问到.</p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><hr>
<p><code>深度优先搜索</code>的一个重要应用就是寻找出一幅<code>图</code>中的所有连通分量.</p>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/cc-api.png" alt="连通分量API"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectedComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="comment">// 顶点与它们所属的连通分量进行关联的数组</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] id;</div><div class="line"></div><div class="line">    <span class="comment">// 记录每个连通分量中有多少顶点的数组</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] size;</div><div class="line"></div><div class="line">    <span class="comment">// 连通分量数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectedComponent</span><span class="params">(Graph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.id = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[v]) &#123;</div><div class="line">                dfs(v);</div><div class="line">                count++; <span class="comment">// 一张连通图遍历完毕后,连通分量数 + 1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line">        <span class="keyword">return</span> id[vertex];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        validateVertex(vertex);</div><div class="line">        <span class="keyword">return</span> size[id[vertex]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 两个顶点是否处于一个连通分量中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        validateVertex(w);</div><div class="line">        <span class="keyword">return</span> id[v] == id[w];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        marked[vertex] = <span class="keyword">true</span>;</div><div class="line">        id[vertex] = count;</div><div class="line">        size[count]++;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> adj : graph.adj(vertex)) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[adj])</div><div class="line">                dfs(adj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检测环与双色问题"><a href="#检测环与双色问题" class="headerlink" title="检测环与双色问题"></a>检测环与双色问题</h3><hr>
<p><code>深度优先搜索</code>的应用远不于此,它还可以用来检测是否有环以及双色问题.</p>
<h4 id="检测环"><a href="#检测环" class="headerlink" title="检测环"></a>检测环</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cyclic</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line">	</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked</div><div class="line">	;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</div><div class="line">	<span class="comment">// 如果存在环则返回这条环路径</span></div><div class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; cyclic;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cyclic</span><span class="params">(Graph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">		<span class="comment">// 先检测是否有自环</span></div><div class="line">        <span class="keyword">if</span> (hasSelfLoop()) <span class="keyword">return</span>;</div><div class="line">		<span class="comment">// 再检测是否有平行边</span></div><div class="line">        <span class="keyword">if</span> (hasParallelEdges()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[vertex];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[v])</div><div class="line">                dfs(v, -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCyclic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cyclic != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">cyclic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cyclic;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasSelfLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.vertex(); v++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(v)) &#123;</div><div class="line">				<span class="comment">// 如果v与w是同一个顶点,则代表有自环</span></div><div class="line">                <span class="keyword">if</span> (v == w) &#123;</div><div class="line">                    cyclic = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">                    cyclic.push(v);</div><div class="line">                    cyclic.push(v);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasParallelEdges</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line">        <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">		</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            <span class="comment">// check for parallel edges incident to v</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(v)) &#123;</div><div class="line">                <span class="keyword">if</span> (marked[w]) &#123;</div><div class="line">                    cyclic = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">                    cyclic.push(v);</div><div class="line">                    cyclic.push(w);</div><div class="line">                    cyclic.push(v);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                marked[w] = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// reset so marked[v] = false for all v</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(v))</div><div class="line">                marked[w] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> u)</span> </span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(v)) &#123;</div><div class="line">            <span class="keyword">if</span> (cyclic != <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</div><div class="line">                edgeTo[w] = v;</div><div class="line">                dfs(w, v);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w != u) &#123;</div><div class="line">                <span class="comment">// check for cycle (but disregard reverse of edge leading to v)</span></div><div class="line">                cyclic = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != w; x = edgeTo[x])</div><div class="line">                    cyclic.push(x);</div><div class="line">                cyclic.push(w);</div><div class="line">                cyclic.push(v);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="检测双色"><a href="#检测双色" class="headerlink" title="检测双色"></a>检测双色</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoColor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Graph graph;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] marked;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] color;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTwoColorable = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoColor</span><span class="params">(Graph graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.graph = graph;</div><div class="line">        <span class="keyword">int</span> vertex = graph.vertex();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line">        <span class="keyword">this</span>.color = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; vertex; v++) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[v])</div><div class="line">                dfs(v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isTwoColorable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">		</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.adj(v)) &#123;</div><div class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</div><div class="line">				<span class="comment">// 将未被访问过的邻接点w设为v的反色</span></div><div class="line">                color[w] = !color[v];</div><div class="line">                dfs(w);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[w] == color[v]) &#123;</div><div class="line">				<span class="comment">// 如果w已被访问且颜色与v相同,则代表这不是一张双色图</span></div><div class="line">                isTwoColorable = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="符号图"><a href="#符号图" class="headerlink" title="符号图"></a>符号图</h3><hr>
<p>在很多应用中,是使用字符串而非整数来表示<code>顶点</code>的,为了适应这种需求,需要拥有以下性质的输入格式: </p>
<ul>
<li>顶点名是字符串.</li>
</ul>
<ul>
<li>用指定的分隔符来隔开顶点名</li>
</ul>
<ul>
<li>每一行都表示一组边的集合,每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点.</li>
</ul>
<ul>
<li>顶点集<code>V</code>与边集<code>E</code>都是隐式定义的.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/routes.png" alt="符号图的输入格式"></p>
<p>要实现<code>符号图</code>还需要借助以下数据结构: </p>
<ul>
<li>一个<code>符号表</code>,我这里使用的是<code>TreeMap</code>即<code>红黑树</code>,它的<code>Key</code>为<code>String</code>(顶点名),<code>Value</code>为<code>Integer</code>(顶点索引).</li>
</ul>
<ul>
<li>一个<code>字符串数组</code>,它用来与<code>符号表</code>作<code>反向索引</code>,保存每个<code>顶点</code>索引所对应的<code>顶点名</code>.</li>
</ul>
<ul>
<li>一个<code>Graph</code>对象,我们使用索引来生成这张<code>图</code>对象.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/symbol-graph-api.png" alt="符号图的API"></p>
<p><img src="http://algs4.cs.princeton.edu/41graph/images/symbol-graph.png" alt="需要用到的数据结构"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolGraph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TreeMap&lt;String, Integer&gt; symbolTable; <span class="comment">// string -&gt; index</span></div><div class="line">    <span class="keyword">private</span> String[] keys; <span class="comment">// index -&gt; string</span></div><div class="line">    <span class="keyword">private</span> Graph graph;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SymbolGraph</span><span class="params">(String filename, String delimiter)</span> </span>&#123;</div><div class="line">        symbolTable = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 第一次读取文件</span></div><div class="line">        String filePath = <span class="string">"/graph_file/C4_1_UndirectedGraphs/"</span> + filename;</div><div class="line">        InputStream inputStream</div><div class="line">                = SymbolGraph.class.getResourceAsStream(filePath);</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(inputStream, <span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 初始化符号表</span></div><div class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</div><div class="line">            String[] s = scanner.nextLine().split(delimiter);</div><div class="line">            <span class="keyword">for</span> (String key : s) &#123;</div><div class="line">                <span class="keyword">if</span> (!symbolTable.containsKey(key))</div><div class="line">                    symbolTable.put(key, symbolTable.size());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.printf(<span class="string">"Done reading %s!\n"</span>, filename);</div><div class="line"></div><div class="line">        <span class="comment">// 初始化反向索引</span></div><div class="line">        keys = <span class="keyword">new</span> String[symbolTable.size()];</div><div class="line">        <span class="keyword">for</span> (String name : symbolTable.keySet())</div><div class="line">            keys[symbolTable.get(name)] = name;</div><div class="line"></div><div class="line">        <span class="comment">// 第二次读取文件,并生成图</span></div><div class="line">        graph = <span class="keyword">new</span> UndirectedGraph(symbolTable.size());</div><div class="line">        Scanner create_graph_scanner = <span class="keyword">new</span> Scanner(SymbolGraph.class.getResourceAsStream(filePath));</div><div class="line">        <span class="keyword">while</span> (create_graph_scanner.hasNextLine()) &#123;</div><div class="line">            String[] s = create_graph_scanner.nextLine().split(delimiter);</div><div class="line">			<span class="comment">// 将第一行的第一个顶点与其他顶点相连</span></div><div class="line">            <span class="keyword">int</span> v = symbolTable.get(s[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</div><div class="line">                <span class="keyword">int</span> w = symbolTable.get(s[i]);</div><div class="line">                graph.addEdge(v, w);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> symbolTable.containsKey(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> symbolTable.get(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nameOf</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        validateVertex(v);</div><div class="line">        <span class="keyword">return</span> keys[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Graph <span class="title">graph</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> graph;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)" target="_blank" rel="external">Graph (discrete mathematics) - Wikipedia</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bipartite_graph" target="_blank" rel="external">Bipartite graph - Wikipedia</a></li>
</ul>
<ul>
<li><a href="http://algs4.cs.princeton.edu/41graph/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></li>
</ul>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
<h3 id="图的那点事儿"><a href="#图的那点事儿" class="headerlink" title="图的那点事儿"></a>图的那点事儿</h3><hr>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/18/2017-07-18-Graph_UndirectedGraph/">图的那点事儿(1)-无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/23/2017-07-23-Graph_DirectedGraphs/">图的那点事儿(2)-有向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/25/2017-07-25-Graph_WeightedUndirectedGraph/">图的那点事儿(3)-加权无向图</a></li>
</ul>
<ul>
<li><a href="https://sylvanassun.github.io/2017/07/27/2017-07-27-Graph_WeightedDigraph">图的那点事儿(4)-加权有向图</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数学中,一个&lt;code&gt;图(Graph)&lt;/code&gt;是表示物件与物件之间关系的方法,是&lt;code&gt;图论&lt;/code&gt;的基本研究对象.一个图是由&lt;code&gt;顶点(Vertex)&lt;/code&gt;与连接这些&lt;code&gt;顶点&lt;/code&gt;的&lt;code&gt;边(Edge)&lt;/code&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/categories/Algorithms/Graph/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="Graph" scheme="https://sylvanassun.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>什么是动态规划?</title>
    <link href="https://sylvanassun.github.io/2017/06/27/2017-06-27-DynamicProgramming/"/>
    <id>https://sylvanassun.github.io/2017/06/27/2017-06-27-DynamicProgramming/</id>
    <published>2017-06-27T10:00:00.000Z</published>
    <updated>2017-07-11T07:05:34.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>动态规划(Dynamic Programming)是一种分阶段求解决策问题的数学思想,它通过把原问题分解为简单的子问题来解决复杂问题.动态规划在很多领域都有着广泛的应用,例如管理学,经济学,数学,生物学.</p>
<p>动态规划适用于解决带有<code>最优子结构</code>和<code>子问题重叠</code>性质的问题.</p>
<ul>
<li><code>最优子结构</code> : 即是局部最优解能够决定全局最优解(也可以认为是问题可以被分解为子问题来解决),如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有<code>最优子结构</code>性质.</li>
</ul>
<ul>
<li><code>子问题重叠</code> : 即是当使用递归进行自顶向下的求解时,<strong>每次产生的子问题不总是新的问题,而是已经被重复计算过的问题</strong>.动态规划利用了这种性质,使用一个集合将已经计算过的结果放入其中,当再次遇见重复的问题时,只需要从集合中取出对应的结果.</li>
</ul>
<h3 id="动态规划与分治算法的区别"><a href="#动态规划与分治算法的区别" class="headerlink" title="动态规划与分治算法的区别"></a>动态规划与分治算法的区别</h3><hr>
<p>相信了解过分治算法的同学会发现,动态规划与分治算法很相似,下面我们例举出一些它们的相同之处与不同之处.</p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>分治算法与动态规划都是将一个复杂问题分解为简单的子问题.</li>
</ul>
<ul>
<li>分治算法与动态规划都只能解决带有<code>最优子结构</code>性质的问题.</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>分治算法一般都是使用递归自顶向下实现,动态规划使用迭代自底向上实现或带有记忆功能的递归实现.</li>
</ul>
<ul>
<li>动态规划解决带有<code>子问题重叠</code>性质的问题效率更加高效.</li>
</ul>
<ul>
<li>分治算法分解的子问题是相对独立的.</li>
</ul>
<ul>
<li>动态规划分解的子问题是互相带有关联且有重叠的.</li>
</ul>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><hr>
<p>斐波那契数列就很适合使用动态规划来求解,它在数学上是使用递归来定义的,公式为<code>F(n) = F(n-1) + F(n-2)</code>.</p>
<p><img src="http://wx3.sinaimg.cn/mw690/63503acbly1fgzut0a5nuj20lp08xq36.jpg" alt="斐波那契数列求解过程"></p>
<h4 id="普通递归实现"><a href="#普通递归实现" class="headerlink" title="普通递归实现"></a>普通递归实现</h4><p>一个最简单的实现如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这种算法并不高效,它做了很多重复计算,它的时间复杂度为<code>O(2^n)</code>.</p>
<h4 id="动态规划递归实现"><a href="#动态规划递归实现" class="headerlink" title="动态规划递归实现"></a>动态规划递归实现</h4><p>使用动态规划来将重复计算的结果具有”记忆性”,就可以将时间复杂度降低为<code>O(n)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 判断当前n的结果是否已经被计算,如果map存在n则代表该结果已经计算过了</span></div><div class="line">	<span class="keyword">if</span> (map.containsKey(n))</div><div class="line">		<span class="keyword">return</span> map.get(n);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> value = fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">	map.put(n, value);</div><div class="line">	<span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然降低了时间复杂度,但需要维护一个集合用于存放计算结果,导致空间复杂度提升了.</p>
<h4 id="动态规划迭代实现"><a href="#动态规划迭代实现" class="headerlink" title="动态规划迭代实现"></a>动态规划迭代实现</h4><p>通过观察斐波那契数列的规律,发现n只依赖于前2种状态,所以我们可以自底向上地迭代实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 使用变量a,b来保存上次迭代和上上次迭代的结果</span></div><div class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">		temp = a + b;</div><div class="line">		a = b;</div><div class="line">		b = temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样不仅时间复杂度得到了优化,也不需要额外的空间复杂度.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="external">Wikipedia</a></li>
</ul>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun/" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;动态规划(Dynamic Programming)是一种分阶段求解决策问题的数学思想,它通过把原问题分解为简单的子问题来解决复杂问
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="动态规划" scheme="https://sylvanassun.github.io/categories/Algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="动态规划" scheme="https://sylvanassun.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>红黑树那点事儿</title>
    <link href="https://sylvanassun.github.io/2017/06/16/2017-06-16-RedBlackTree/"/>
    <id>https://sylvanassun.github.io/2017/06/16/2017-06-16-RedBlackTree/</id>
    <published>2017-06-16T10:00:00.000Z</published>
    <updated>2017-07-11T07:04:07.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>红黑树</code>是一种<code>自平衡二叉查找树</code>,它相对于<code>二叉查找树</code>性能会更加高效(查找、删除、添加等操作需要<code>O(log n)</code>,其中<code>n</code>为树中元素的个数),但实现较为复杂(需要保持自身的平衡).</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_example.svg" alt=""></p>
<p><code>红黑树</code>与<code>二叉查找树</code>不同,它的节点多了一个颜色属性,每个节点非黑即红,这也是它名字的由来.</p>
<p><code>红黑树</code>的节点定义如以下代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> Node root;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> color = RED; <span class="comment">//颜色</span></div><div class="line">    <span class="keyword">private</span> Node parent, left, right;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderStatus = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> K key;</div><div class="line">    <span class="keyword">private</span> V value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.size = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整的代码我已经放在了我的<code>Gist</code>中,<a href="https://gist.github.com/SylvanasSun/147672912cc5bc6da27e15528542877f" target="_blank" rel="external">点击查看完整代码</a>.</p>
<p><code>红黑树</code>需要保证以下性质: </p>
<ol>
<li>每个节点的颜色非黑即红.</li>
</ol>
<ol>
<li><strong>根节点的颜色为黑色.</strong></li>
</ol>
<ol>
<li>所有叶子节点都为黑色(即NIL节点).</li>
</ol>
<ol>
<li><p><strong>每个红色节点的两个子节点都必须为黑色(不能有两个连续的红节点).</strong></p>
</li>
<li><p><strong>从任一节点到其叶子的所有简单路径包含相同数量的黑色节点.</strong></p>
</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><hr>
<p><code>红黑树</code>的查找操作与<code>二叉查找树</code>一致(因为查找不会影响树的结构),而插入与删除操作需要在最后对树进行调整.</p>
<p>我们将新的节点的颜色设为红色(如果设为黑色会使根节点到叶子的一条路径上多了一个黑节点,违反了性质5,这个是很难调整的).</p>
<p>现在我们假设新节点为<code>N</code>,它的父节点为<code>P</code>(且<code>P</code>为<code>G</code>的左节点,如果为右节点则与其操作互为镜像),祖父节点为<code>G</code>,叔叔节点为<code>U</code>.插入一个节点会有以下种情况.</p>
<h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p><strong><code>N</code>位于根,它没有父节点与子节点,这时候只需要把它重新设置为黑色即可</strong>,无需其他调整.</p>
<h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p><strong><code>P</code>的颜色为黑色</strong>,这种情况下保持了性质4(<code>N</code>只有两个叶子节点,它们都为黑色)与性质5(<code>N</code>是一个红色节点,不会对其造成影响)的有效,所以<strong>无需调整</strong>.</p>
<h4 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h4><p>如果<code>P</code>与<code>U</code>都为红色,我们可以将它们两个重新绘制为黑色,然后将<code>G</code>绘制为红色(保持性质5),最后再从<code>G</code>开始继续向上进行调整.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png" alt=""></p>
<h4 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h4><p><strong><code>P</code>为红色,<code>U</code>为黑色,且<code>N</code>为<code>P</code>的左子节点,这种情况下,我们需要在<code>G</code>处进行一次<code>右旋转</code></strong>,结果满足了性质4与性质5,因为通过这三个节点中任何一个的所有路径以前都通过祖父节点<code>G</code>，现在它们都通过以前的父节点<code>P</code>.</p>
<p>关于旋转操作,可以查看这篇文章<a href="http://sylvanassun.github.io/2017/03/30/red_black_binary_search_tree/">《Algorithms,4th Edition》读书笔记-红黑二叉查找树</a>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png" alt=""></p>
<h4 id="情况5"><a href="#情况5" class="headerlink" title="情况5"></a>情况5</h4><p><code>P</code>为红色,<code>U</code>为黑色,且<code>N</code>为<code>P</code>的右子节点,我们需要先在<code>P</code>处进行一次<code>左旋转</code>,这样就又回到了情况4.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png" alt=""></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; colorOf(parentOf(x)) == RED) &#123;</div><div class="line">          <span class="keyword">if</span> (parentOf(x) == grandpaOf(x).left) &#123;</div><div class="line">              x = parentIsLeftNode(x);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              x = parentIsRightNode(x);</div><div class="line">          &#125;</div><div class="line">          fixSize(x);</div><div class="line">      &#125;</div><div class="line">      setColor(root, BLACK);</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">parentIsLeftNode</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      Node xUncle = grandpaOf(x).right;</div><div class="line"><span class="comment">// 情况3</span></div><div class="line">      <span class="keyword">if</span> (colorOf(xUncle) == RED) &#123;</div><div class="line">          x = uncleColorIsRed(x, xUncle);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// 情况5</span></div><div class="line">          <span class="keyword">if</span> (x == parentOf(x).right) &#123;</div><div class="line">              x = parentOf(x);</div><div class="line">              rotateLeft(x);</div><div class="line">          &#125;</div><div class="line">	<span class="comment">// 情况4</span></div><div class="line">          rotateRight(grandpaOf(x));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">parentIsRightNode</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      Node xUncle = grandpaOf(x).left;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (colorOf(xUncle) == RED) &#123;</div><div class="line">          x = uncleColorIsRed(x, xUncle);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">if</span> (x == parentOf(x).left) &#123;</div><div class="line">              x = parentOf(x);</div><div class="line">              rotateRight(x);</div><div class="line">          &#125;</div><div class="line">          rotateLeft(grandpaOf(x));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">uncleColorIsRed</span><span class="params">(Node x, Node xUncle)</span> </span>&#123;</div><div class="line">      setColor(parentOf(x), BLACK);</div><div class="line">      setColor(xUncle, BLACK);</div><div class="line">      setColor(grandpaOf(x), RED);</div><div class="line">      x = grandpaOf(x);</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>我们只考虑删除节点只有一个子节点的情况,且只有后继节点与删除节点都为黑色(如果删除节点为红色,从根节点到叶子节点的每条路径上少了一个红色节点并不会违反<code>红黑树</code>的性质,而如果后继节点为红色,只需要将它重新绘制为黑色即可).</p>
<p>先将删除节点替换为后继节点,且后继节点定义为<code>N</code>,它的兄弟节点为<code>S</code>.</p>
<h4 id="情况1-1"><a href="#情况1-1" class="headerlink" title="情况1"></a>情况1</h4><p><code>N</code>为新的根节点,在这种情况下只需要把根节点保持为黑色即可.</p>
<h4 id="情况2-1"><a href="#情况2-1" class="headerlink" title="情况2"></a>情况2</h4><p><strong><code>S</code>为红色,只需要在<code>P</code>进行一次<code>左旋转</code></strong>,接下来则<strong>继续按以下情况进行处理</strong>(尽管路径上的黑色节点数量没有改变,但<code>N</code>有了一个黑色的兄弟节点与红色的父节点).</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png" alt=""></p>
<h4 id="情况3-1"><a href="#情况3-1" class="headerlink" title="情况3"></a>情况3</h4><p><code>S</code>和它的子节点都是黑色的,而<code>P</code>为红色.这种情况下只需要将<code>S</code>与<code>P</code>的颜色进行交换</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png" alt=""></p>
<h4 id="情况4-1"><a href="#情况4-1" class="headerlink" title="情况4"></a>情况4</h4><p><strong><code>S</code>和它的子节点都是黑色的,这种情况下需要把<code>S</code>重新绘制为红色</strong>.这时不通过<code>N</code>的路径都将少一个黑色节点(通过<code>N</code>的路径因为删除节点是黑色的也都少了一个黑色节点),这让它们平衡了起来.</p>
<p>但现在通过<code>P</code>的路径比不通过<code>P</code>的路径都少了一个黑色节点,所以还需要在<code>P</code>上继续进行调整.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png" alt=""></p>
<h4 id="情况5-1"><a href="#情况5-1" class="headerlink" title="情况5"></a>情况5</h4><p><strong><code>S</code>为黑色,它的左子节点为红色,右子节点为黑色.这种情况下,我们在<code>S</code>上做<code>右旋转</code></strong>,这样<code>S</code>的左儿子成为<code>S</code>的父亲和N的新兄弟。我们接着交换<code>S</code>和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在<code>N</code>有了一个右儿子是红色的黑色兄弟，所以我们进入了情况6。<code>N</code>和<code>P</code>都不受这个变换的影响。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png" alt=""></p>
<h4 id="情况6"><a href="#情况6" class="headerlink" title="情况6"></a>情况6</h4><p><strong><code>S</code>是黑色，它的右子节点是红色,我们在<code>N</code>的父亲<code>P</code>上做<code>左旋转</code></strong>.这样<code>S</code>成为<code>N</code>的父亲和<code>S</code>的右儿子的父亲。我们接着交换<code>N</code>的父亲和<code>S</code>的颜色，<strong>并使<code>S</code>的右儿子为黑色</strong>。子树在它的根上的仍是同样的颜色,但是,<code>N</code>现在增加了一个黑色祖先.所以,通过<code>N</code>的路径都增加了一个黑色节点.此时,如果一个路径不通过<code>N</code>,则有两种可能性:</p>
<ul>
<li>它通过<code>N</code>的新兄弟.那么它以前和现在都必定通过<code>S</code>和<code>N</code>的父亲,而它们只是交换了颜色.所以路径保持了同样数目的黑色节点.</li>
</ul>
<ul>
<li>它通过<code>N</code>的新叔父,<code>S</code>的右儿子.那么它以前通过<code>S</code>、<code>S</code>的父亲和<code>S</code>的右儿子,但是现在只通过<code>S</code>,它被假定为它以前的父亲的颜色,和<code>S</code>的右儿子,它被从红色改变为黑色.合成效果是这个路径通过了同样数目的黑色节点.</li>
</ul>
<p>在任何情况下,在这些路径上的黑色节点数目都没有改变.所以我们恢复了性质4.在示意图中的白色节点可以是红色或黑色,但是在变换前后都必须指定相同的颜色.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png" alt=""></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; colorOf(x) == BLACK) &#123;</div><div class="line">          <span class="keyword">if</span> (x == parentOf(x).left) &#123;</div><div class="line">              x = successorIsLeftNode(x);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              x = successorIsRightNode(x);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      setColor(x, BLACK);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">successorIsLeftNode</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      Node brother = parentOf(x).right;</div><div class="line"><span class="comment">// 情况2</span></div><div class="line">      <span class="keyword">if</span> (colorOf(brother) == RED) &#123;</div><div class="line">          rotateLeft(parentOf(x));</div><div class="line">          brother = parentOf(x).right;</div><div class="line">      &#125;</div><div class="line"><span class="comment">// 情况3,4</span></div><div class="line">      <span class="keyword">if</span> (colorOf(brother.left) == BLACK &amp;&amp; colorOf(brother.right) == BLACK) &#123;</div><div class="line">          x = brotherChildrenColorIsBlack(x, brother);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// 情况5</span></div><div class="line">          <span class="keyword">if</span> (colorOf(brother.right) == BLACK) &#123;</div><div class="line">              rotateRight(brother);</div><div class="line">              brother = parentOf(x).right;</div><div class="line">          &#125;</div><div class="line">	<span class="comment">// 情况6</span></div><div class="line">          setColor(brother.right, BLACK);</div><div class="line">          rotateLeft(parentOf(x));</div><div class="line">          x = root;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">brotherChildrenColorIsBlack</span><span class="params">(Node x, Node brother)</span> </span>&#123;</div><div class="line">      setColor(brother, RED);</div><div class="line">      x = parentOf(x);</div><div class="line">      <span class="keyword">return</span> x;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">Wikipedia</a></li>
</ul>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun/" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;红黑树&lt;/code&gt;是一种&lt;code&gt;自平衡二叉查找树&lt;/code&gt;,它相对于&lt;code&gt;二叉查找树&lt;/code&gt;性能
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出排序算法(3)-快速排序</title>
    <link href="https://sylvanassun.github.io/2017/06/14/2017-06-14-sort_algorithms_qucikSort/"/>
    <id>https://sylvanassun.github.io/2017/06/14/2017-06-14-sort_algorithms_qucikSort/</id>
    <published>2017-06-14T08:30:00.000Z</published>
    <updated>2017-07-11T07:03:48.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>快速排序</code>与<code>归并排序</code>一样也是基于分治算法的排序算法.所以它的实现方法也与其他的分治算法一样,需要进行分解子任务,处理子任务,归并子任务这些步骤.</p>
<p>但<code>快速排序</code>与<code>归并排序</code>不同,它是一种<code>原地排序</code>算法(不需要额外的辅助数组),且<code>快速排序</code>不使用中间值来分解任务,而是使用<code>划分函数</code>.</p>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""></p>
<ul>
<li>从数组中挑选出一个值,作为<code>基准值 k</code>.</li>
</ul>
<ul>
<li>重新排序序列,<strong>将所有小于<code>k</code>的值放到<code>k</code>前面,所有大于<code>k</code>的值放到<code>k</code>后面</strong>(也可以理解为将数组<code>a</code>切分为两个子数组<code>a[begin...k-1],a[k+1...end]</code>,其中前一个子数组都小于<code>k</code>,后一个子数组都大于<code>k</code>).</li>
</ul>
<ul>
<li>递归地将两个子数组进行快速排序(递归到最底部时,子数组的大小是零或一,也就是已经排序好了.).</li>
</ul>
<h3 id="划分函数"><a href="#划分函数" class="headerlink" title="划分函数"></a>划分函数</h3><hr>
<p><code>划分函数</code>就是上述步骤中的第二步,它将数组根据<code>基准值</code>进行重排序.根据<code>基准值</code>选择的位置不同,<code>划分函数</code>也有不同的实现方法,不过其根本思想都是将小于<code>基准值</code>的值放到前面,大于<code>基准值</code>的值放到后面.</p>
<h4 id="使用末尾元素作为基准值"><a href="#使用末尾元素作为基准值" class="headerlink" title="使用末尾元素作为基准值"></a>使用末尾元素作为基准值</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用末尾元素作为基准值来进行切分</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionUseEnd</span><span class="params">(Comparable[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    Comparable pivot = a[end]; <span class="comment">// 基准值,切分后的数组应满足左边都小于基准,右边都大于基准</span></div><div class="line">    <span class="keyword">int</span> i = begin - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end; j++) &#123;</div><div class="line">        <span class="comment">// 如果j小于基准值则与i交换</span></div><div class="line">        <span class="keyword">if</span> (less(a[j], pivot)) &#123;</div><div class="line">            i++;</div><div class="line">            swap(a, i, j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将基准值交换到正确的位置上</span></div><div class="line">    <span class="keyword">int</span> pivotLocation = i + <span class="number">1</span>;</div><div class="line">    swap(a, pivotLocation, end);</div><div class="line">    <span class="keyword">return</span> pivotLocation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用首元素作为基准值"><a href="#使用首元素作为基准值" class="headerlink" title="使用首元素作为基准值"></a>使用首元素作为基准值</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用首元素作为基准值来进行切分</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionUseBegin</span><span class="params">(Comparable[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    Comparable pivot = a[begin];</div><div class="line">    <span class="keyword">int</span> i = begin;</div><div class="line">    <span class="keyword">int</span> j = end + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 从左向右扫描,直到找出一个大于等于基准的值</span></div><div class="line">        <span class="keyword">while</span> (less(a[++i], pivot)) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= end)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从右向左扫描,直到找出一个小于等于基准的值</span></div><div class="line">        <span class="keyword">while</span> (less(pivot, a[--j])) &#123;</div><div class="line">            <span class="keyword">if</span> (j &lt;= begin)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果指针i与j发生碰撞则结束循环</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= j)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 将左边大于小于基准的值与右边小于等于基准的值进行交换</span></div><div class="line">        swap(a, i, j);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将基准值交换到正确的位置上</span></div><div class="line">    swap(a, begin, j);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<p>了解了<code>划分函数</code>的实现,剩下就只需要递归地调用<code>快速排序</code>不断地分解子任务即可.</p>
<p>注意,<code>快速排序</code>与<code>归并排序</code>不同,它不需要进行<code>归并</code>(划分后就已经是有序的了),并且是先进行<code>划分函数</code>,再分解任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (begin &gt;= end)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> k = partitionUseEnd(a, begin, end);</div><div class="line">    sort(a, begin, k - <span class="number">1</span>);</div><div class="line">    sort(a, k + <span class="number">1</span>, end);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun/" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;快速排序&lt;/code&gt;与&lt;code&gt;归并排序&lt;/code&gt;一样也是基于分治算法的排序算法.所以它的实现方法也与其他的分
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出排序算法(2)-归并排序</title>
    <link href="https://sylvanassun.github.io/2017/06/12/2017-06-12-sort_algorithmes_mergeSort/"/>
    <id>https://sylvanassun.github.io/2017/06/12/2017-06-12-sort_algorithmes_mergeSort/</id>
    <published>2017-06-12T07:00:00.000Z</published>
    <updated>2017-07-11T07:04:56.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>归并排序</code>是基于分治算法实现的一种排序算法,它将数组分割为两个子数组,然后对子数组进行排序,最终将子数组<code>归并</code>为有序的数组.</p>
<p><code>归并排序</code>的时间复杂度为<code>O(n log n)</code>,空间复杂度为<code>O(1)</code>,并且它是稳定的排序算法(所谓稳定即是不影响值相等元素的相对次序).</p>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><hr>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt=""></p>
<ul>
<li>首先,<code>归并排序</code>需要将一个大小为<code>n</code>个元素的数组分解为各包含<code>n/2</code>个元素的子数组(这个分解的过程会不断进行,直到子数组元素个数为<code>1</code>).</li>
</ul>
<ul>
<li>当子数组的元素个数为<code>1</code>时,代表这个子数组已经有序,开始两两归并(将两个个数为<code>1</code>的子数组归并为一个个数为<code>2</code>的子数组,不断归并,直到所有子数组个数为<code>2</code>,然后继续将两个个数为<code>2</code>的子数组归并为一个个数为<code>4</code>的子数组….以此类推).</li>
</ul>
<ul>
<li>不断重复步骤2,直到整个数组有序.</li>
</ul>
<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><hr>
<p>通过以上的了解,我们发现<code>归并排序</code>中最重要的步骤就是<code>归并</code>.</p>
<p>采用类似<code>洗牌</code>的方式来理解这个过程.想象辅助数组为一个空牌堆,两个子数组为两堆牌<code>a</code>和<code>b</code>.我们从<code>a</code>堆与<code>b</code>堆中<strong>各取出一张牌进行比较,然后将较小的牌放入空牌堆中</strong>,不断重复比较直到任一牌堆为空.最后,再将未空的牌堆全部放入空牌堆中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将两个子序列进行归并</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[a.length]; <span class="comment">// 辅助数组</span></div><div class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> count = lo;</div><div class="line">    <span class="comment">// 对[lo...mid] 与 [mid+1...hi] 两个子序列的首元素进行比较,将较小的元素放入辅助数组</span></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</div><div class="line">        <span class="keyword">if</span> (less(a[i], a[j]))</div><div class="line">            aux[count++] = a[i++];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            aux[count++] = a[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//将[lo...mid] 与 [mid+1...hi] 两个子序列中剩余的元素放入辅助数组</span></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">        aux[count++] = a[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt;= hi) &#123;</div><div class="line">        aux[count++] = a[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将辅助数组中的元素复制到源数组中</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">        a[k] = aux[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><hr>
<p>只要理解了<code>归并</code>的过程,剩下就很容易实现了.<code>归并排序</code>的递归实现如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">      sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">  <span class="comment">// 递归实现归并排序</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (lo &gt;= hi)</div><div class="line">          <span class="keyword">return</span>;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// (lo + hi) / 2</span></div><div class="line"><span class="comment">// 分解数组</span></div><div class="line">      sort(a, lo, mid);</div><div class="line">      sort(a, mid + <span class="number">1</span>, hi);</div><div class="line"><span class="comment">// 归并</span></div><div class="line">      merge(a, lo, mid, hi);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><hr>
<p>我们已经知道了<code>归并排序</code>中最小子数组的元素个数为<code>1</code>,非递归实现只需要从<code>1</code>开始自底向上地归并即可(递归实现的真实计算过程也是如此,这是由于递归调用是后进先出的).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 非递归实现归并排序</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortUnRecursive</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">1</span>; <span class="comment">// 自底向上实现归并排序,子序列的最小粒度为1</span></div><div class="line">       <span class="keyword">while</span> (len &lt; a.length) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i += len &lt;&lt; <span class="number">1</span>) &#123;</div><div class="line">               merge(a, i, len);</div><div class="line">           &#125;</div><div class="line">           len = len &lt;&lt; <span class="number">1</span>; <span class="comment">// 子序列规模每次迭代时乘2</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// 与递归实现的归并函数不同,需要注意边界检查</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> length = a.length;</div><div class="line">       Comparable[] aux = <span class="keyword">new</span> Comparable[length];</div><div class="line">       <span class="keyword">int</span> count = lo;</div><div class="line">       <span class="comment">// 子数组1</span></div><div class="line">       <span class="keyword">int</span> i = lo;</div><div class="line">       <span class="keyword">int</span> i_bound = lo + hi;</div><div class="line">       <span class="comment">// 子数组2</span></div><div class="line">       <span class="keyword">int</span> j = i_bound;</div><div class="line">       <span class="keyword">int</span> j_bound = j + hi;</div><div class="line"></div><div class="line">       <span class="comment">// 注意j的边界检查</span></div><div class="line">       <span class="keyword">while</span> (i &lt; i_bound &amp;&amp; j &lt; j_bound &amp;&amp; j &lt; length) &#123;</div><div class="line">           <span class="keyword">if</span> (less(a[i], a[j]))</div><div class="line">               aux[count++] = a[i++];</div><div class="line">           <span class="keyword">else</span></div><div class="line">               aux[count++] = a[j++];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// i和j都有可能越界</span></div><div class="line">       <span class="keyword">while</span> (i &lt; i_bound &amp;&amp; i &lt; length) &#123;</div><div class="line">           aux[count++] = a[i++];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (j &lt; j_bound &amp;&amp; j &lt; length) &#123;</div><div class="line">           aux[count++] = a[j++];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> k = lo;</div><div class="line">       <span class="keyword">while</span> (k &lt; j &amp;&amp; k &lt; length) &#123;</div><div class="line">           a[k] = aux[k];</div><div class="line">           k++;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;归并排序&lt;/code&gt;是基于分治算法实现的一种排序算法,它将数组分割为两个子数组,然后对子数组进行排序,最终将子数组&lt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出排序算法(1)-堆排序</title>
    <link href="https://sylvanassun.github.io/2017/06/09/2017-06-09-sort_algorithms_heapSort/"/>
    <id>https://sylvanassun.github.io/2017/06/09/2017-06-09-sort_algorithms_heapSort/</id>
    <published>2017-06-09T10:00:00.000Z</published>
    <updated>2017-07-11T07:04:50.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>堆排序</code>即是利用<code>堆</code>这个数据结构来完成排序的.所以,要想理解<code>堆排序</code>就要先了解<code>堆</code>.</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><hr>
<p><code>堆(Heap)</code>是一种数据结构,它可以被看做是一棵树的数组对象.一个<code>二叉堆</code>拥有以下性质.</p>
<ul>
<li>父节点<code>k</code>的左子节点在数组中的索引位置为<code>2 * k + 1</code>.</li>
</ul>
<ul>
<li>父节点<code>k</code>的右子节点在数组中的索引位置为<code>2 * k + 2</code>.</li>
</ul>
<ul>
<li>子节点<code>i</code>的父节点在数组中的索引位置为<code>(i - 1) / 2</code>.</li>
</ul>
<ul>
<li>父节点<code>k</code>的任意子节点都必须小于(或大于)<code>k</code>.</li>
</ul>
<ul>
<li>根节点必须是最大节点(或最小节点).</li>
</ul>
<h4 id="最大堆代码实现"><a href="#最大堆代码实现" class="headerlink" title="最大堆代码实现"></a>最大堆代码实现</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    T[] heap;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MaxHeap</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(T[] heap)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.heap = heap;</div><div class="line">        buildHeap();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自底向上构建堆</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = heap.length;</div><div class="line">        <span class="comment">// 当堆为空或者长度为1时不需要任何操作</span></div><div class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> root = (length - <span class="number">2</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// (i - 1) / 2</span></div><div class="line">        <span class="keyword">while</span> (root &gt;= <span class="number">0</span>) &#123;</div><div class="line">            heapify(heap, length, root);</div><div class="line">            root--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调整堆的结构</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> heap   堆</div><div class="line">     * <span class="doctag">@param</span> length 堆的长度</div><div class="line">     * <span class="doctag">@param</span> root   根节点索引</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(T[] heap, <span class="keyword">int</span> length, <span class="keyword">int</span> root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root &gt;= length)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> largest = root; <span class="comment">// 表示root,left,right中最大值的变量</span></div><div class="line">        <span class="keyword">int</span> left = (root &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点,root * 2 + 1</span></div><div class="line">        <span class="keyword">int</span> right = left + <span class="number">1</span>; <span class="comment">// 右子节点,root * 2 + 2</span></div><div class="line"></div><div class="line">        <span class="comment">// 找出最大值</span></div><div class="line">        <span class="keyword">if</span> (left &lt; length &amp;&amp; greater(heap[left], heap[largest]))</div><div class="line">            largest = left;</div><div class="line">        <span class="keyword">if</span> (right &lt; length &amp;&amp; greater(heap[right], heap[largest]))</div><div class="line">            largest = right;</div><div class="line"></div><div class="line">        <span class="comment">// 如果largest发生变化,将largest与root交换</span></div><div class="line">        <span class="keyword">if</span> (largest != root) &#123;</div><div class="line">            T t = heap[root];</div><div class="line">            heap[root] = heap[largest];</div><div class="line">            heap[largest] = t;</div><div class="line">            <span class="comment">// 继续向下调整堆</span></div><div class="line">            heapify(heap, length, largest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable a, Comparable b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><hr>
<p>普通的队列是基于<code>先进先出</code>的,也就是说最先入队的元素永远是在第一位,而<code>优先队列</code>中的每一个元素都是拥有<code>优先级</code>的,<code>优先级</code>最高的元素永远在第一位.</p>
<p><code>优先队列</code>也是<code>贪心算法</code>的体现,所谓的<code>贪心算法</code>即是在问题求解的每一步中总是选择当前最好的结果.</p>
<p><code>堆</code>就是用于实现<code>优先队列</code>的,因为<code>堆</code>的性质与<code>优先队列</code>十分吻合.</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><hr>
<p>往<code>优先队列</code>中添加元素时,我们只需要将元素添加到数组末尾并调整堆(以下例子均是以最大堆为例).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">       <span class="keyword">if</span> (size == queue.length)</div><div class="line">           resize(queue.length * <span class="number">2</span>);</div><div class="line">       <span class="keyword">int</span> i = size;</div><div class="line">	<span class="comment">// 如果当前队列为空,则不需要进行堆调整直接插入元素即可</span></div><div class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">           queue[<span class="number">0</span>] = t;</div><div class="line">       <span class="keyword">else</span></div><div class="line">           swim(i, t);</div><div class="line">       size++;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// 上浮调整</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</div><div class="line">       Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable) t;</div><div class="line">       <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">int</span> parent = (i - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">           T p = (T) queue[parent];</div><div class="line">		<span class="comment">// 如果key小于他的父节点(符合最大堆规则)则结束调整</span></div><div class="line">           <span class="keyword">if</span> (key.compareTo(p) &lt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           queue[i] = p;</div><div class="line">           i = parent;</div><div class="line">       &#125;</div><div class="line">       queue[i] = key;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><hr>
<p>删除操作要稍微麻烦一点,将<code>优先队列</code>中末尾的元素放到队头并进行堆调整.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isEmpty())</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">int</span> s = --size;</div><div class="line">       Object result = queue[<span class="number">0</span>];</div><div class="line">       Object end = queue[s];</div><div class="line">       queue[s] = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">           sink(<span class="number">0</span>, (T) end);</div><div class="line">       <span class="keyword">if</span> (size &lt;= queue.length / <span class="number">4</span>)</div><div class="line">           resize(queue.length / <span class="number">2</span>);</div><div class="line">       <span class="keyword">return</span> (T) result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// 下沉调整</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</div><div class="line">       Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) t;</div><div class="line">       <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (i &lt; half) &#123;</div><div class="line">           <span class="keyword">int</span> child = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点</span></div><div class="line">           <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 右子节点</span></div><div class="line">           T max = (T) queue[child];</div><div class="line">           <span class="comment">// find maximum element</span></div><div class="line">           <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">                   ((Comparable&lt;? <span class="keyword">super</span> T&gt;) max).compareTo((T) queue[right]) &lt; <span class="number">0</span>)</div><div class="line">               max = (T) queue[child = right];</div><div class="line">		<span class="comment">// key大于它的最大子节点(符合最大堆规则)则结束调整	</span></div><div class="line">           <span class="keyword">if</span> (key.compareTo(max) &gt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           queue[i] = max;</div><div class="line">           i = child;</div><div class="line">       &#125;</div><div class="line">       queue[i] = key;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/SylvanasSun/test-demo/blob/master/src/main/java/com/sun/sylvanas/data_struct/heap/MaxPriorityQueue.java" target="_blank" rel="external">点击查看优先队列完整代码</a></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p>实现<code>堆排序</code>有两种方法,一种是使用<code>优先队列</code>,另一种是直接使用<code>堆</code>.</p>
<h4 id="直接使用堆实现堆排序"><a href="#直接使用堆实现堆排序" class="headerlink" title="直接使用堆实现堆排序"></a>直接使用堆实现堆排序</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用最大堆实现堆排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    MaxHeap&lt;Comparable&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;(a);</div><div class="line">    <span class="comment">//不断地将最大堆中顶端元素(最大值)与最底部的元素(最小值)交换</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        Comparable largest = a[<span class="number">0</span>];</div><div class="line">        a[<span class="number">0</span>] = a[i];</div><div class="line">        a[i] = largest;</div><div class="line">        <span class="comment">// 堆减少,并调整新的堆</span></div><div class="line">        maxHeap.heapify(a, i, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用优先队列实现堆排序"><a href="#使用优先队列实现堆排序" class="headerlink" title="使用优先队列实现堆排序"></a>使用优先队列实现堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用优先队列实现堆排序</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pqSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    MinPriorityQueue&lt;Comparable&gt; priorityQueue = <span class="keyword">new</span> MinPriorityQueue&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">        priorityQueue.add(a[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">        a[i] = priorityQueue.poll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;堆排序&lt;/code&gt;即是利用&lt;code&gt;堆&lt;/code&gt;这个数据结构来完成排序的.所以,要想理解&lt;code&gt;堆排序&lt;/
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>IoC与AOP的那点事儿</title>
    <link href="https://sylvanassun.github.io/2017/06/07/2017-06-07-IoC&amp;AOP/"/>
    <id>https://sylvanassun.github.io/2017/06/07/2017-06-07-IoC&amp;AOP/</id>
    <published>2017-06-07T08:00:00.000Z</published>
    <updated>2017-07-11T07:02:27.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><hr>
<p>控制反转(Inversion of Control)是<code>OOP</code>中的一种设计原则,也是<code>Spring</code>框架的核心.大多数应用程序的业务逻辑代码都需要两个或多个类进行合作完成的,<strong>通过<code>IoC</code>则可以减少它们之间的耦合度</strong>.</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><hr>
<p><code>IoC</code>的主要实现方法有两种,<code>依赖注入</code>与<code>依赖查找</code>.</p>
<p> <strong>依赖注入 :</strong>  应用程序被动的接收对象,<code>IoC</code>容器通过类型或名称等信息来判断将不同的对象注入到不同的属性中.</p>
<p>依赖注入主要有以下的方式: </p>
<ul>
<li>基于<code>set</code>方法 : 实现特定属性的public set()方法,来让<code>IoC</code>容器调用注入所依赖类型的对象.</li>
</ul>
<ul>
<li>基于接口 : 实现特定接口以供<code>IoC</code>容器注入所依赖类型的对象.</li>
</ul>
<ul>
<li><p>基于构造函数 : 实现特定参数的构造函数,在创建对象时来让<code>IoC</code>容器注入所依赖类型的对象.</p>
</li>
<li><p>基于注解 : 通过<code>Java</code>的注解机制来让<code>IoC</code>容器注入所依赖类型的对象,例如<code>Spring</code>框架中的<code>@Autowired</code>.</p>
</li>
</ul>
<p><strong>依赖查找 :</strong> 它相对于<code>依赖注入</code>而言是一种更为主动的方法,它会在需要的时候通过调用框架提供的方法来获取对象,获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态.</p>
<h4 id="IoC的思想"><a href="#IoC的思想" class="headerlink" title="IoC的思想"></a>IoC的思想</h4><hr>
<p>在传统实现中,我们都是通过应用程序自己来管理依赖的创建,例如下代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 由Person自己管理Food类的创建</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">		Food food = <span class="keyword">new</span> Chicken();</div><div class="line">		System.out.println(<span class="string">"I am eating "</span> + food.getName() + <span class="string">"..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>IoC</code>则是通过一个<strong>第三方容器来管理并维护这些被依赖对象,应用程序只需要接收并使用<code>IoC容器</code>注入的对象而不需要关注其他事情</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Food food;</div><div class="line"></div><div class="line">	<span class="comment">// 通过set注入</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFood</span><span class="params">(Food food)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.food = food;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Person不需要关注Food,只管使用即可</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"I am eating "</span> + <span class="keyword">this</span>.food.getName() + <span class="string">"..."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上的例子我们能够发现,控制反转其实就是对象控制权的转移,<strong>应用程序将对象的控制权转移给了第三方容器并通过它来管理这些被依赖对象,完成了应用程序与被依赖对象的解耦.</strong></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><hr>
<p><code>AOP(Aspect-Oriented Programming)</code>即面向方面编程.<strong>它是一种在运行时,动态地将代码切入到类的指定方法、指定位置上的编程思想.</strong>用于<strong>切入到指定类指定方法的代码片段叫做<code>切面</code></strong>,而<strong>切入到哪些类中的哪些方法叫做<code>切入点</code>.</strong></p>
<p><code>AOP</code>是<code>OOP</code>的有益补充,<code>OOP</code>从横向上区分出了一个个类,<code>AOP</code>则从纵向上向指定类的指定方法中动态地切入代码.它使<code>OOP</code>变得更加立体.</p>
<p><code>Java</code>中的动态代理或<code>CGLib</code>就是<code>AOP</code>的体现.</p>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><hr>
<p>在<code>OOP</code>中,我们使用封装的特性来将不同职责的代码抽象到不同的类中.但是在分散代码的同时,也增加了代码的重复性.</p>
<p>例如,我们需要在两个或多个类中的方法都记录日志或执行时间,可能这些代码是完全一致的,但因为类与类无法联系造成代码重复.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		recordLog();	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 记录日志...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		recordLog();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 记录日志...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来,我们采取两种不同方案来改进这段代码.</p>
<h4 id="将重复代码抽离到一个类中"><a href="#将重复代码抽离到一个类中" class="headerlink" title="将重复代码抽离到一个类中"></a>将重复代码抽离到一个类中</h4><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		Report.recordLog();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 业务逻辑...</span></div><div class="line">		Report.recordLog();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordLog</span> <span class="params">(String ...messages)</span> </span>&#123;</div><div class="line">		<span class="comment">// 记录日志...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看似解决了问题,但类之间已经耦合了.并且当这些外围业务代码(日志,权限校验等)越来越多时,它们的侵入(与核心业务代码混在一起)会使代码的整洁度变得混乱不堪.</p>
<h4 id="使用AOP分离外围业务代码"><a href="#使用AOP分离外围业务代码" class="headerlink" title="使用AOP分离外围业务代码"></a>使用AOP分离外围业务代码</h4><hr>
<p>我们使用<code>AspectJ</code>,它是一个<code>AOP</code>框架,扩展了Java语言,并定义了<code>AOP</code>语法(通过它实现的编译器).</p>
<p>使用<code>AspectJ</code>需要先安装并将lib中aspectjrt.jar添加进入classpath,<a href="http://www.eclipse.org/aspectj/downloads.php" target="_blank" rel="external">下载地址</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Say something..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Something something = <span class="keyword">new</span> Something();</div><div class="line">        something.say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> aspect SomethingAspect &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 切入点,切入到Something.say()</div><div class="line">     */</div><div class="line">    <span class="function">pointcut <span class="title">recordLog</span><span class="params">()</span>:<span class="title">call</span><span class="params">(* com.sun.sylvanas.application.hello_aop.Something.say(..)</span>)</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在方法执行后执行</div><div class="line">     */</div><div class="line">    after():recordLog() &#123;</div><div class="line">        System.out.println(<span class="string">"[AFTER] Record log..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AOP</code>解决了代码的重复并将这些外围业务代码抽离到一个切面中,我们可以动态地将切面切入到切入点.</p>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IoC&quot;&gt;&lt;a href=&quot;#IoC&quot; class=&quot;headerlink&quot; title=&quot;IoC&quot;&gt;&lt;/a&gt;IoC&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;控制反转(Inversion of Control)是&lt;code&gt;OOP&lt;/code&gt;中的一种设计原则,也是&lt;code&gt;S
    
    </summary>
    
      <category term="后端" scheme="https://sylvanassun.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://sylvanassun.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
      <category term="Spring" scheme="https://sylvanassun.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://sylvanassun.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://sylvanassun.github.io/tags/Spring/"/>
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>谈谈如何实现一个非阻塞的线程安全的集合</title>
    <link href="https://sylvanassun.github.io/2017/05/29/2017-5-29-cas_concurrent_stack/"/>
    <id>https://sylvanassun.github.io/2017/05/29/2017-5-29-cas_concurrent_stack/</id>
    <published>2017-05-29T10:00:00.000Z</published>
    <updated>2017-07-11T07:01:59.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>众所周知,想要在<code>java</code>中要实现一个线程安全的类有很多方法.最简单直接的即是使用<code>synchronized</code>关键字或<code>ReentrantLock</code>.</p>
<p>但是,这两种同步方法都是基于锁的,基于锁的同步方法是阻塞的,即未争夺到锁的线程需要阻塞等待(或挂起)直到锁可用.</p>
<p>这种方法具有一些明显的缺点:</p>
<ul>
<li>被阻塞的线程无法去做任何其他事情,如果这个线程是优先级较高的线程甚至会发生非常不好的结果(优先级倒置).</li>
</ul>
<ul>
<li>由于<code>java</code>的线程模型是基于内核线程实现的,挂起恢复线程需要来回地切换到内核态,性能开销很大.</li>
</ul>
<ul>
<li>当两个(或多个)线程都阻塞着等待另一方释放锁时,将会引发死锁.</li>
</ul>
<p>那么有非阻塞的方法来实现同步吗?(<code>volatile</code>关键字也是非阻塞的,但它只保证了数据的可见性与有序性,并不保证原子性)</p>
<p>有!在<code>jdk5</code>中,java增加了大量的原子类来保证无锁下的操作原子性,可以说<code>java.util.concurrent</code>包下的所有类都几乎用到了这些原子类.</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><hr>
<p>这些原子类都是基于<code>CAS</code>实现的,<code>CAS</code>即是<strong>Compare And Swap</strong>,它的原理简单来讲就是<strong>在更新新值之前先去比较原值有没有发生变化,如果没发生变化则进行更新</strong>.</p>
<p><code>java</code>中的<code>CAS</code>是通过<code>Unsafe</code>类中的本地方法实现的,而这些本地方法需要通过现代处理器提供的<code>CAS</code>指令实现(在<code>Intel</code>处理器中该指令为<code>cmpxchg</code>).</p>
<p>所以我们发现,<strong><code>CAS</code>操作的原子性是由处理器来保证的</strong>.</p>
<h4 id="比较的过程"><a href="#比较的过程" class="headerlink" title="比较的过程"></a>比较的过程</h4><p>在<code>CAS</code>操作中包含了三个数,<code>V(内存位置)</code>,<code>A(预期值)</code>,<code>B(新值)</code>.</p>
<ul>
<li>首先会将<code>V</code>与<code>A</code>进行匹配.</li>
</ul>
<ul>
<li>如果两个值相等,则使用<code>B</code>作为新值进行更新.</li>
</ul>
<ul>
<li>如果不相等,则不进行更新操作(一般的补救措施是继续进行请求).</li>
</ul>
<h4 id="与锁相比的优点"><a href="#与锁相比的优点" class="headerlink" title="与锁相比的优点"></a>与锁相比的优点</h4><ul>
<li><p><code>CAS</code>操作是无锁的实现,所以它不会发生死锁情况.</p>
</li>
<li><p>虽然<code>CAS</code>操作失败需要不断的进行请求重试,但相对于不断地挂起或恢复线程来说,性能开销要低得多.</p>
</li>
<li><p><code>CAS</code>的粒度更细,操作也更加轻量与灵活.</p>
</li>
</ul>
<h3 id="ConcurrentStack"><a href="#ConcurrentStack" class="headerlink" title="ConcurrentStack"></a>ConcurrentStack</h3><hr>
<p>我们通过实现一个简单的<code>ConcurentStack</code>来看看<code>CAS</code>操作是如何保证线程安全的.</p>
<p><a href="https://gist.github.com/SylvanasSun/15353e5567e1890b45f516f7fe6a187d" target="_blank" rel="external">完整代码请从作者的Gist中获取</a></p>
<h4 id="节点的实现"><a href="#节点的实现" class="headerlink" title="节点的实现"></a>节点的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&lt;E&gt;&gt; head = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</div><div class="line">    <span class="keyword">private</span> AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This internal static class represents the nodes in the stack.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E value;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>push函数主要是通过观察头节点(这里的头节点即是<code>V</code>),然后构建一个新的节点(它代表<code>B</code>)放于栈顶,如果<code>V</code>没有发生变化,则进行更新.如果发生了变化(被其他线程修改),就重新尝试进行<code>CAS</code>操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Insert a new element to the this stack.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> if &#123;<span class="doctag">@code</span> true&#125; insert success,&#123;<span class="doctag">@code</span> false&#125; otherwise</div><div class="line"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> value&#125; is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">return</span> putAndReturnResult(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putAndReturnResult</span><span class="params">(E value)</span> </span>&#123;</div><div class="line">    Node&lt;E&gt; oldNode;</div><div class="line">    Node&lt;E&gt; newNode;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        oldNode = head.get();</div><div class="line">        newNode = <span class="keyword">new</span> Node&lt;E&gt;(value, oldNode);</div><div class="line">    &#125; <span class="keyword">while</span> (!head.compareAndSet(oldNode, newNode));</div><div class="line">    sizePlusOne();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop函数中的<code>CAS</code>操作的思想基本与push函数一致.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the element of stack top and remove this element.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if this stack is empty</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">return</span> removeAndReturnElement();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAndReturnElement</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;E&gt; oldNode;</div><div class="line">    Node&lt;E&gt; newNode;</div><div class="line">    E result;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        oldNode = head.get();</div><div class="line">        newNode = oldNode.next;</div><div class="line">        result = oldNode.value;</div><div class="line">    &#125; <span class="keyword">while</span> (!head.compareAndSet(oldNode, newNode));</div><div class="line">    sizeMinusOne();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<p>非阻塞的算法实现的复杂度要比阻塞算法复杂的多,但它能带来更少的性能开销,在<code>jdk</code>中,很多线程安全类都是在尽量地避免使用锁的基础上来实现线程安全.</p>
<blockquote>
<p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun(sylvanassun_xtz@163.com)</a>,转载请务必指明原文链接.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;众所周知,想要在&lt;code&gt;java&lt;/code&gt;中要实现一个线程安全的类有很多方法.最简单直接的即是使用&lt;code&gt;synchr
    
    </summary>
    
      <category term="后端" scheme="https://sylvanassun.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="多线程" scheme="https://sylvanassun.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="CAS" scheme="https://sylvanassun.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/CAS/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="CAS" scheme="https://sylvanassun.github.io/tags/CAS/"/>
    
      <category term="多线程" scheme="https://sylvanassun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Algorithms,4th Edition》读书笔记-散列表</title>
    <link href="https://sylvanassun.github.io/2017/04/13/2017-4-13-hash_table/"/>
    <id>https://sylvanassun.github.io/2017/04/13/2017-4-13-hash_table/</id>
    <published>2017-04-13T10:00:00.000Z</published>
    <updated>2017-07-11T07:04:13.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>散列表</code>(<code>Hash Table</code>,也叫<code>哈希表</code>),它是根据键而直接访问在内存存储位置的数据结构.也可以说是用一个数组来实现的<strong>无序的符号表</strong>,将键作为数组的索引而数组中键<code>i</code>处存储的就是它对应的值.</p>
<p><code>散列表</code>通过<code>散列函数</code>将键转化为数组的索引来访问数组中的键值对.</p>
<p>在<code>散列表</code>的算法中,最重要的两个操作如下.</p>
<ol>
<li>使用<code>散列函数</code>将被查找的键转化为数组的一个索引.</li>
</ol>
<ol>
<li>处理散列表中的<code>碰撞冲突</code>问题.</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/hashing-crux.png" alt=""></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><hr>
<ul>
<li>若关键字为<code>k</code>,则其值存放于<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c36f16f5357aeb5b0fa2fe3040e74282d62f8881">的存储位置上.由此,不需要比较便可直接取得所查记录.称这个对应关系<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/132e57acb643253e7810ee9702d9581f159a1c61">为<code>散列函数</code>,按照这个思想建立的符合表为<code>散列表</code>.</li>
</ul>
<ul>
<li>对不同的键可能会得到同一个<code>散列地址</code>,即<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f2b910a452063a4769272110d8d22cab053d433d">,而<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fa1d43b27a17bf57baf12626ad7cfbf8ee9bb96d">,这种现象被称为<code>碰撞冲突</code>.具有相同函数值的键对该<code>散列函数</code>来说称做同义词.综上所述,根据散列函数<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c36f16f5357aeb5b0fa2fe3040e74282d62f8881">和处理<code>碰撞冲突</code>的方法将一组键映射到一个有限的连续的地址集(区间)上,这种表称为<code>散列表</code>,这一映射过程称为<code>散列</code>,所得的存储位置称为<code>散列地址</code>.</li>
</ul>
<ul>
<li>若对于键集合中的任一个键,经<code>散列函数</code>映射到地址集合中任何一个地址的概率是相等的,则这个<code>散列函数</code>被称为<code>均匀散列函数</code>,它可以减少<code>碰撞冲突</code>.</li>
</ul>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><hr>
<p><code>散列函数</code>用于将键转化为数组的索引.如果我们有一个能够保存M个键值对的数组,那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1]范围内的整数)的<code>散列函数</code></p>
<p><code>散列函数</code>与键的类型有关,对于每种类型的键都需要一个与之对应的<code>散列函数</code>.</p>
<h4 id="实现散列函数的几种方法"><a href="#实现散列函数的几种方法" class="headerlink" title="实现散列函数的几种方法"></a>实现散列函数的几种方法</h4><ul>
<li>直接定址法 : 取<code>key</code>或者<code>key</code>的某个线性函数值为<code>散列地址</code>.即<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/989ebc7db55ece5d29e2a8baa005e876ef486e4e">或<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/989ebc7db55ece5d29e2a8baa005e876ef486e4e">其中a,b为常数(这种<code>散列函数</code>叫做自身函数).</li>
</ul>
<ul>
<li>数字分析法 : 假设<code>key</code>是以<code>r</code>为基的数,并且<code>散列表</code>中可能出现的<code>key</code>都是事先知道的,则可取<code>key</code>的若干数位组成<code>散列地址</code>.</li>
</ul>
<ul>
<li>平方取中法 : 取<code>key</code>平方后的中间几位为<code>散列地址</code>.通常在选定<code>散列函数</code>时不一定能知道<code>key</code>的全部情况,取其中的哪几位也不一定合适,而一个数平方后的中间几位数和数的每一位都相关,由此使随机分布的<code>key</code>得到的<code>散列地址</code>也是随机的.取的位数由表长决定.</li>
</ul>
<ul>
<li>折叠法 : 将<code>key</code>分割成位数相同的几部分(最后一部分的位数可以不同),然后取这几部分的叠加和(舍去进位)作为<code>散列地址</code>.</li>
</ul>
<ul>
<li>除留余数法 : 取<code>key</code>被某个不大于<code>散列表</code>长度<code>m</code>的数<code>p</code>除后所得的余数为<code>散列地址</code>.即<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bc04a0c2f72156976761fa24dd4ba098855b7dca">,<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3aad2b022083cbc8aef0745526f3a448e7d96160">.不仅可以对<code>key</code>直接取模，也可在<code>折叠法</code>、<code>平方取中法</code>等运算之后取模。对<code>p</code>的选择很重要，一般取<code>素数</code>或<code>m</code>，若<code>p</code>选择不好，容易产生<code>碰撞冲突</code>.</li>
</ul>
<h4 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h4><p>将正整数<code>散列</code>一般使用的是<code>除留余数法</code>.我们选择大小为<strong>素数</strong><code>M</code>的数组,对于任意正整数<code>k</code>,计算<code>k</code>除以<code>M</code>的余数(即<code>k%M</code>).它能够有效地将<code>key</code>散布在0到M-1的范围内.</p>
<p>如果<code>M</code>不是<strong>素数</strong>,可能无法利用<code>key</code>中包含的所有信息,这<strong>可能导致无法均匀地散列散列值</strong>.</p>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/modular-hashing.png" alt=""></p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>对浮点数进行散列一般是将<code>key</code>表示为二进制数然后再使用<code>除留余数法</code>.</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>除留余数法</code>也可以处理较长的<code>key</code>,例如字符串,我们只需将它们当成大整数即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">   	hash = (R * hash + s.charAt(i)) % M;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java的<code>charAt()</code>函数能够返回一个char值,即一个非负16位整数.如果<code>R</code>比任何字符的值都大,这种计算相当于将字符串当作一个N位的<code>R</code>进制值,将它除以<code>M</code>并取余.只要<code>R</code>足够小,不造成溢出,那么结果就能够落在0至M-1之间.可以使用一个较小的素数,例如31.</p>
<h4 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h4><p>如果<code>key</code>的类型含有多个整型变量,我们可以和字符串类型一样将它们混合起来.</p>
<p>例如,<code>key</code>的类型为Date,其中含有几个整型的域 : day(两个数字表示的日),month(两个数字表示的月),year(四个数字表示的年).我们可以这样计算它的散列值: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = (((day * R + month) % M) * R + year) % M;</div></pre></td></tr></table></figure>
<h4 id="Java中的约定"><a href="#Java中的约定" class="headerlink" title="Java中的约定"></a>Java中的约定</h4><p>在Java中如果要为自定义的数据类型定义散列函数,需要同时重写<code>hashCode()</code>和<code>equals()</code>两个函数,并要遵守以下规则.</p>
<ul>
<li><code>hashCode()</code>与<code>equals()</code>的结果必须保持一致性.即<code>a.equals(b)</code>返回true,则<code>a.hashCode()</code>的返回值也必然和<code>b.hashCode()</code>的返回值相同.</li>
</ul>
<ul>
<li>但如果两个对象的<code>hashCode()</code>函数的返回值相同,这两个对象也有可能不同,还需要用<code>equals()</code>函数进行判断.</li>
</ul>
<p>一个使用<code>除留余数法</code>的简单<code>散列函数</code>如下,它会将符号位屏蔽(将一个32位整数变为一个31位非负整数).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h4><p>由于<code>散列函数</code>的计算有可能会很耗时,我们可以进行缓存优化,将每个<code>key</code>的散列值缓存起来(可以在每个<code>key</code>中使用一个hash变量来保存它的<code>hashCode()</code>的返回值).</p>
<p>当第一次调用<code>hashCode()</code>时,需要计算对象的散列值,但之后对<code>hashCode()</code>方法的调用会直接返回hash变量的值.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总之,要想实现一个优秀的<code>散列函数</code>需要满足以下的条件.</p>
<ol>
<li>一致性,等价的<code>key</code>必然产生相等的散列值.</li>
</ol>
<ol>
<li>.高效性,计算简便.</li>
</ol>
<ol>
<li>均匀性,均匀地散列所有的<code>key</code>.</li>
</ol>
<h3 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h3><hr>
<p>拉链法是解决<code>碰撞冲突</code>的一种策略,它的核心思想是 : 将大小为<code>M</code>的<strong>数组中的每个元素指向一条链表</strong>,链表中的每个节点都存储了散列值为该元素的索引的键值对.</p>
<p>拉链法的实现一般分为以下两种: </p>
<ol>
<li>使用一个原始的链表数据类型来表示数组中的每个元素.</li>
</ol>
<ol>
<li>使用一个符号表实现来表示数组中的每个元素(这个方法实现简单但效率偏低).</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/separate-chaining.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPACITY = <span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// the number of key-value pairs in the symbol table</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">// the number of size of separate chaining table</span></div><div class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table; <span class="comment">// array of linked-list symbol tables</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> K key;</div><div class="line">        <span class="keyword">private</span> V value;</div><div class="line">        <span class="keyword">private</span> Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ((key.hashCode()) &amp; <span class="number">0x7fffffff</span>) % m;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="查找、插入、删除"><a href="#查找、插入、删除" class="headerlink" title="查找、插入、删除"></a>查找、插入、删除</h4><p>基于拉链法的<code>散列表</code>的查找、插入、删除算法基本分为两步:</p>
<ol>
<li>首先根据散列值找到对应的链表.</li>
</ol>
<ol>
<li>然后沿着这条链表进行相应的操作.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called get() with key is null."</span>);</div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    Node x = table[i];</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (key.equals(x.key))</div><div class="line">            <span class="keyword">return</span> (V) x.value;</div><div class="line">        x = x.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with key is null."</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        remove(key);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// double table size if average length of list &gt;= 10</span></div><div class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">10</span> * m)</div><div class="line">        resize(<span class="number">2</span> * m);</div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    Node x = table[i];</div><div class="line">    Node p = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">            x.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        p = x;</div><div class="line">        x = x.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">        table[i] = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>);</div><div class="line">        n++;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p.next = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called remove() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called remove() with empty symbol table."</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!contains(key))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    Node x = table[i];</div><div class="line">    Node p = <span class="keyword">null</span>;</div><div class="line">    V oldValue = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">            oldValue = (V) x.value;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                table[i] = x.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                p.next = x.next;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        p = x;</div><div class="line">        x = x.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// halve table size if average length of list &lt;= 2</span></div><div class="line">    <span class="keyword">if</span> (m &gt; INIT_CAPACITY &amp;&amp; n &lt;= <span class="number">2</span> * m)</div><div class="line">        resize(m / <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于线性探测法的散列表"><a href="#基于线性探测法的散列表" class="headerlink" title="基于线性探测法的散列表"></a>基于线性探测法的散列表</h3><hr>
<p>解决<code>碰撞冲突</code>的另一种策略是使用线性探测法.它的核心思想是: 使用大小为<code>M</code>的数组保存<code>N</code>个键值对,其中<code>M&gt;N</code>.这种方法<strong>需要依靠数组中的空位来解决<code>碰撞冲突</code></strong>,基于这种策略的所有方法被统称为<code>开放地址散列表</code>.</p>
<p><code>开放地址散列表</code>中最简单的方法就是线性探测法: 当发生<code>碰撞冲突</code>时,我们直接检查<code>散列表</code>中的下一个位置(将索引值加1).它可能会产生三种结果: </p>
<ol>
<li>命中,该位置的<code>key</code>和被查找的<code>key</code>相同.</li>
</ol>
<ol>
<li>未命中,<code>key</code>为空(该位置没有<code>key</code>).</li>
</ol>
<ol>
<li>继续查找,该位置的<code>key</code>和被查找的<code>key</code>不同.</li>
</ol>
<p>我们使用<code>散列函数</code>找到<code>key</code>在数组中的索引,检查其中的<code>key</code>和被查找的<code>key</code>是否相同.如果不同则继续查找(将索引值加1,到达数组结尾时折回数组的开头),直到找到该<code>key</code>或者遇到一个空元素.</p>
<p><code>开放地址散列表</code>的核心思想是: 与其将内存用作链表,不如将它们作为在<code>散列表</code>的空元素(这些空元素可以作为查找结束的标识).</p>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/linear-probing.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPACITY = <span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// the number of key-value pairs in the symbol table</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">// the number of size of linear probing table</span></div><div class="line">    <span class="keyword">private</span> K[] keys; <span class="comment">// the keys</span></div><div class="line">    <span class="keyword">private</span> V[] vals; <span class="comment">// the values</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initializes an empty symbol table.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(INIT_CAPACITY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initializes an empty symbol table with the specified initial capacity.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> capacity the initial capacity</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        m = capacity;</div><div class="line">        n = <span class="number">0</span>;</div><div class="line">        keys = (K[]) <span class="keyword">new</span> Object[m];</div><div class="line">        vals = (V[]) <span class="keyword">new</span> Object[m];</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called get() with key is null."</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % m) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key))</div><div class="line">                <span class="keyword">return</span> vals[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with key is null."</span>);</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            delete(key);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// double table size if 50% full</span></div><div class="line">        <span class="keyword">if</span> (n &gt;= m / <span class="number">2</span>) resize(<span class="number">2</span> * m);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % m) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key)) &#123;</div><div class="line">                vals[i] = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        keys[i] = key;</div><div class="line">        vals[i] = value;</div><div class="line">        n++;</div><div class="line">    &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>基于线性探测法的<code>散列表</code>的删除操作较为复杂,我们不能直接将<code>key</code>所在的位置设为<code>null</code>,这样会使在此位置之后的元素无法被查找到.</p>
<p>因此,我们需要<strong>将被删除键的右侧的所有键重新插入到<code>散列表</code>中</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called delete() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called delete() with empty symbol table."</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!contains(key))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// find position i of key</span></div><div class="line">    <span class="keyword">int</span> i = hash(key);</div><div class="line">    <span class="keyword">while</span> (!key.equals(keys[i])) &#123;</div><div class="line">        i = (i + <span class="number">1</span>) % m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    V oldValue = vals[i];</div><div class="line">    <span class="comment">// delete key and associated value</span></div><div class="line">    keys[i] = <span class="keyword">null</span>;</div><div class="line">    vals[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// rehash all keys in same cluster</span></div><div class="line">    i = (i + <span class="number">1</span>) % m;</div><div class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// delete keys[i] an vals[i] and reinsert</span></div><div class="line">        K keyToRehash = keys[i];</div><div class="line">        V valToRehash = vals[i];</div><div class="line">        keys[i] = <span class="keyword">null</span>;</div><div class="line">        vals[i] = <span class="keyword">null</span>;</div><div class="line">        n--;</div><div class="line">        put(keyToRehash, valToRehash);</div><div class="line">        i = (i + <span class="number">1</span>) % m;</div><div class="line">    &#125;</div><div class="line">    n--;</div><div class="line"></div><div class="line">    <span class="comment">// halves size of array if it's 12.5% full or less</span></div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= m / <span class="number">8</span>) resize(m / <span class="number">2</span>);</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="键簇"><a href="#键簇" class="headerlink" title="键簇"></a>键簇</h4><p>线性探测法的平均成本取决于元素在插入数组后聚集成的一组连续的条目,也叫作<code>键簇</code>.</p>
<p>显然,短小的<code>键簇</code>才能保证较高的效率.随着插入的<code>key</code>越来越多,这个要求会很难满足,较长的<code>键簇</code>会越来越多.<code>长键簇</code>的可能性要比<code>短键簇</code>更大,因为新键的散列值无论落在<code>键簇</code>的任何位置都会使它的长度加1.</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><hr>
<p><code>散列表</code>使用了适度的空间和时间并在这两个极端之间找到了一种平衡,所以它可以在一般应用中实现拥有(均摊后)常数级别的查找和插入操作的<code>符号表</code>.</p>
<p>但<code>散列表</code>是很难实现有序操作的,这是因为散列最主要的目的在于均匀地将键散布开来,因此在计算散列后键的顺序信息就已经丢失了.</p>
<p>同时,<code>散列表</code>的性能也依赖于<code>α=N/M</code>的比值,其中<code>α</code>称为<code>散列表</code>的使用率.对于<code>拉链法</code>来说,<code>α</code>是每条链表的长度,因此一般大于1.对于<code>线性探测法</code>来说,<code>α</code>是表中已被占用的空间的比例,它是不可能大于1的.</p>
<p><code>散列表</code>的性能虽然高效,但它也有以下的局限性: </p>
<ul>
<li>每种类型的键都需要一个优秀的<code>散列函数</code>.</li>
</ul>
<ul>
<li>性能保证来自于<code>散列函数</code>的质量.</li>
</ul>
<ul>
<li><code>散列函数</code>的计算可能复杂而且昂贵.</li>
</ul>
<ul>
<li>难以支持有序性相关的操作.</li>
</ul>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/6872abd0fad061de28466cb775a84cea" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>文中参考资料引用自<a href="http://algs4.cs.princeton.edu/34hash/" target="_blank" rel="external">&lt;<algorithms,4th edition="">&gt;</algorithms,4th></a> &amp; <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="external">Wikepedia</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;散列表&lt;/code&gt;(&lt;code&gt;Hash Table&lt;/code&gt;,也叫&lt;code&gt;哈希表&lt;/code&gt;),它是根据
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashTable" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashTable/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="HashTable" scheme="https://sylvanassun.github.io/tags/HashTable/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>平衡查找树之AVL树</title>
    <link href="https://sylvanassun.github.io/2017/04/08/2017-4-08-avl_tree/"/>
    <id>https://sylvanassun.github.io/2017/04/08/2017-4-08-avl_tree/</id>
    <published>2017-04-08T10:00:00.000Z</published>
    <updated>2017-07-11T07:04:24.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p><code>AVL树</code>得名于它的发明者G.M. Adelson-Velsky和E.M. Landis,它是最先发明的<code>自平衡二叉查找树</code>.</p>
<p>在<code>AVL树</code>中<strong>任何节点的两个子树的高度最大差别为一</strong>.并且,查找、插入、删除等操作在平均和最坏情况下都是<code>O(log n)</code>.</p>
<p><code>AVL树</code>的基本操作都与<code>二叉查找树</code>的算法一致,只有在插入、删除等这种会<strong>改变树的平衡性的操作需要使用一些<code>旋转操作</code>来修正树的平衡性</strong>.</p>
<h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><hr>
<p>节点的<code>平衡因子</code>一般是它的<code>左子树</code>的高度减去它的<code>右子树</code>的高度(相反也可以).带有<code>平衡因子</code>为1、0或-1的节点被认为是平衡的.带有<code>平衡因子</code>为-2或2的节点被认为是不平衡的.</p>
<p>计算树的高度与平衡因子的代码如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// calculate node x depth</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcDepth</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</div><div class="line">        depth = x.left.depth;</div><div class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span> &amp;&amp; x.right.depth &gt; depth)</div><div class="line">        depth = x.right.depth;</div><div class="line">    <span class="comment">// parent + left or right depth</span></div><div class="line">    depth++;</div><div class="line">    <span class="keyword">return</span> depth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// calculate node x balance(left.depth - right.depth)</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcBalance</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> leftDepth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> rightDepth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</div><div class="line">        leftDepth = x.left.depth;</div><div class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</div><div class="line">        rightDepth = x.right.depth;</div><div class="line">    <span class="keyword">return</span> leftDepth - rightDepth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><hr>
<p><code>旋转操作</code>是用于修复树的平衡性的,它保证了树的有序性与平衡性(旋转操作的具体讲解可以参考<a href="http://sylvanassun.github.io/2017/03/30/red_black_binary_search_tree/">《Algorithms,4th Edition》读书笔记-红黑二叉查找树</a>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    Node t = x.right;</div><div class="line">    x.right = t.left;</div><div class="line">    t.left = x;</div><div class="line">    <span class="keyword">if</span> (x.parent != <span class="keyword">null</span>) &#123;</div><div class="line">        t.parent = x.parent;</div><div class="line">        <span class="keyword">if</span> (x.parent.left == x)</div><div class="line">            x.parent.left = t;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            x.parent.right = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t.parent = <span class="keyword">null</span>;</div><div class="line">        root = t;</div><div class="line">    &#125;</div><div class="line">    x.parent = t;</div><div class="line">    <span class="comment">// calculate depth and balance</span></div><div class="line">    x.depth = calcDepth(x);</div><div class="line">    x.balance = calcBalance(x);</div><div class="line">    t.depth = calcDepth(t);</div><div class="line">    t.balance = calcBalance(t);</div><div class="line">    <span class="comment">// calculate size</span></div><div class="line">    t.size = x.size;</div><div class="line">    x.size = <span class="number">1</span> + size(x.left) + size(x.right);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    Node t = x.left;</div><div class="line">    x.left = t.right;</div><div class="line">    t.right = x;</div><div class="line">    <span class="keyword">if</span> (x.parent != <span class="keyword">null</span>) &#123;</div><div class="line">        t.parent = x.parent;</div><div class="line">        <span class="keyword">if</span> (x.parent.left == x)</div><div class="line">            x.parent.left = t;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            x.parent.right = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t.parent = <span class="keyword">null</span>;</div><div class="line">        root = t;</div><div class="line">    &#125;</div><div class="line">    x.parent = t;</div><div class="line">    <span class="comment">// calculate depth and balance</span></div><div class="line">    x.depth = calcDepth(x);</div><div class="line">    x.balance = calcBalance(x);</div><div class="line">    t.depth = calcDepth(t);</div><div class="line">    t.balance = calcBalance(t);</div><div class="line">    <span class="comment">// calculate size</span></div><div class="line">    t.size = x.size;</div><div class="line">    x.size = <span class="number">1</span> + size(x.left) + size(x.right);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="平衡修正"><a href="#平衡修正" class="headerlink" title="平衡修正"></a>平衡修正</h2><hr>
<p>当一个节点被认为是不平衡的时候,我们需要使用一些<code>旋转操作</code>来修正树的平衡,一般有以下情况需要进行<code>旋转</code>.</p>
<ul>
<li>例如当前节点为<code>x</code>,对<code>x</code>进行平衡修正需要进行以下判断.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>平衡因子</code>大于等于2时(左子树高度偏高),对其进行<code>右旋转</code>.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>左子树</code>的<code>平衡因子</code>等于-1时(左子树的右子节点高度偏高),对<code>x</code>的<code>左子树</code>进行<code>左旋转</code>.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>平衡因子</code>小于等于-2时(右子树高度偏高),对其进行<code>左旋转</code>.</li>
</ul>
<ul>
<li>当<code>x</code>的<code>右子树</code>的<code>平衡因子</code>等于1时(右子树的左子节点高度偏高),对<code>x</code>的<code>右子树</code>进行<code>右旋转</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">balance</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        x.depth = calcDepth(x);</div><div class="line">        x.balance = calcBalance(x);</div><div class="line">        <span class="comment">// if x left subtree high,rotateRight</span></div><div class="line">        <span class="keyword">if</span> (x.balance &gt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">// if x.left.right high,rotateLeft</span></div><div class="line">            <span class="keyword">if</span> (x.left != <span class="keyword">null</span> &amp;&amp; x.left.balance == -<span class="number">1</span>) &#123;</div><div class="line">                x.left = rotateLeft(x.left);</div><div class="line">            &#125;</div><div class="line">            x = rotateRight(x);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// if x right subtree high,rotateLeft</span></div><div class="line">        <span class="keyword">if</span> (x.balance &lt;= -<span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">// if x.right.left high,rotateRight</span></div><div class="line">            <span class="keyword">if</span> (x.right != <span class="keyword">null</span> &amp;&amp; x.right.balance == <span class="number">1</span>) &#123;</div><div class="line">                x.right = rotateRight(x.right);</div><div class="line">            &#125;</div><div class="line">            x = rotateLeft(x);</div><div class="line">        &#125;</div><div class="line">        x.size = <span class="number">1</span> + size(x.left) + size(x.right);</div><div class="line">        x = x.parent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><hr>
<p><code>AVL树</code>的插入和删除与<code>二分查找树</code>的算法一致,只不过在完成插入后需要自底向上的修复平衡性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        remove(key);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    put(root, key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Node x, K key, V value)</span> </span>&#123;</div><div class="line">    Node parent = x;</div><div class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        parent = x;</div><div class="line">        cmp = key.compareTo(x.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</div><div class="line">            x = x.left;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</div><div class="line">            x = x.right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            x.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// if not find key,create new node</span></div><div class="line">    x = <span class="keyword">new</span> Node(key, value, <span class="number">1</span>, parent);</div><div class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            parent.left = x;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            parent.right = x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        root = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// fixup balance</span></div><div class="line">    balance(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/780045c5b8705ef225eb83c58a013949" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>本文参考资料引用自<a href="https://en.wikipedia.org/wiki/AVL_tree" target="_blank" rel="external">Wikipedia</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;AVL树&lt;/code&gt;得名于它的发明者G.M. Adelson-Velsky和E.M. Landis,它是最先发明的&lt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>《Algorithms,4th Edition》读书笔记-红黑二叉查找树</title>
    <link href="https://sylvanassun.github.io/2017/03/30/2017-3-30-red_black_binary_search_tree/"/>
    <id>https://sylvanassun.github.io/2017/03/30/2017-3-30-red_black_binary_search_tree/</id>
    <published>2017-03-30T10:00:00.000Z</published>
    <updated>2017-07-11T07:04:29.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><code>红黑二叉查找树</code>是<code>2-3查找树</code>的简单表示方式,它的代码量并不大,并且保证了平衡性.<br>阅读本文前需先了解 <a href="http://sylvanassun.github.io/2017/03/28/2_3tree/">《Algorithms,4th Edition》读书笔记-2-3查找树</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p><code>红黑树</code>是一种自平衡的<code>二叉查找树</code>,它的基本思想是<strong>用标准的<code>二叉查找树</code>(完全由<code>2-节点</code>构成)和一些额外的信息(替换<code>3-节点</code>)来表示<code>2-3树</code>.</strong> 可以说<code>红黑树</code>是<code>2-3树</code>的一种等同.</p>
<p><code>红黑树</code>中的链接可以分为两种类型: </p>
<ul>
<li><strong>红链接</strong> : 它将两个<code>2-节点</code>连接起来构成一个<code>3-节点</code>(也可以说是将<code>3-节点</code>表示为由一条<strong>红色左链接</strong>(两个<code>2-节点</code>其中之一是另一个的左子节点)相连的两个<code>2-节点</code>).</li>
</ul>
<ul>
<li><strong>黑链接</strong> : 表示<code>2-3树</code>中的普通链接.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-encoding.png" alt=""></p>
<p>这种表示方式带来的优点如下: </p>
<ol>
<li>无需修改就可以直接使用标准的<code>二叉查找树</code>中的查找方法(其他与链接颜色不关联的方法也可以直接使用).</li>
</ol>
<ol>
<li>对于任意的<code>2-3树</code>,只要对节点进行转换,我们都可以立即派生出一棵对应的<code>二叉查找树</code>.</li>
</ol>
<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><hr>
<p><code>红黑树</code>是含有红黑链接并满足下列条件的<code>二叉查找树</code>(满足这些条件的<code>红黑树</code>才是与相应的<code>2-3树</code>一一对应的).</p>
<ul>
<li>红链接均为左链接(这条仅限于偏向左红链接实现的<code>红黑树</code>).</li>
</ul>
<ul>
<li>每个节点不是红色就是黑色的.</li>
</ul>
<ul>
<li>没有任何一个节点同时和两条红链接相连(不可以有两条连续的红链接).</li>
</ul>
<ul>
<li>该树是完美黑色平衡的,即<strong>任意空链接到根节点的路径上的黑链接数量相同.</strong></li>
</ul>
<ul>
<li><code>根节点</code>是黑色的.</li>
</ul>
<ul>
<li>所有<code>叶子节点</code>(即null节点)的颜色是黑色的.</li>
</ul>
<h2 id="与2-3树的对应关系"><a href="#与2-3树的对应关系" class="headerlink" title="与2-3树的对应关系"></a>与2-3树的对应关系</h2><hr>
<p>假如我们将一棵<code>红黑树</code>中的红链接画平,我们会发现所有的空链接到根节点的距离都将是相同的.如果再把由红链接相连的节点合并,得到的就是一棵<code>2-3树</code>.</p>
<p>相对的,如果将一棵<code>2-3树</code>中的<code>3-节点</code>画作由红色左链接相连的两个<code>2-节点</code>,那么不会存在能够和两条红链接相连的节点,且树必然是完美黑色平衡的,因为黑链接就是<code>2-3树</code>中的普通链接,根据定义这些链接必然是完美平衡的.</p>
<p>通过这些结论,我们<strong>可以发现<code>红黑树</code>即是<code>二叉查找树</code>,也是<code>2-3树</code>.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-1-1.png" alt=""></p>
<h2 id="节点的实现"><a href="#节点的实现" class="headerlink" title="节点的实现"></a>节点的实现</h2><hr>
<p>我们使用<code>boolean</code>类型的变量<code>color</code>来表示链接的颜色.如果指向它的链接为红色,则<code>color</code>变量为<code>true</code>,黑色则为<code>false</code>(空链接也为黑色).</p>
<p>并且定义了一个<code>isRed()</code>函数用于判断链接的颜色.</p>
<p>这里节点的<strong>颜色指的是指向该节点的链接的颜色.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-color.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Node root; <span class="comment">// root node</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> K key;</div><div class="line">      <span class="keyword">private</span> V value;</div><div class="line">      <span class="keyword">private</span> Node left, right; <span class="comment">// links to left and right subtress</span></div><div class="line">      <span class="keyword">private</span> <span class="keyword">boolean</span> color; <span class="comment">// color of parent link</span></div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// subtree count</span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, <span class="keyword">boolean</span> color, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.key = key;</div><div class="line">          <span class="keyword">this</span>.value = value;</div><div class="line">          <span class="keyword">this</span>.color = color;</div><div class="line">          <span class="keyword">this</span>.size = size;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">	</div><div class="line"><span class="comment">// node x is red? if x is null return false.</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> x.color == RED;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><hr>
<p>当我们在实现某些操作时,可能会产生一些红色右链接或者两条连续的红色左链接.这时就需要在操作完成前进行旋转操作来修复<code>红黑树</code>的平衡性(<strong>旋转操作会改变红链接的指向</strong>).</p>
<p>旋转操作保证了<code>红黑树</code>的两个重要性质 : <strong>有序性</strong>和<strong>完美平衡性</strong>. </p>
<h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><p>假设当前有一条红色右链接需要被修正旋转为左链接.这个操作叫做<code>左旋转</code>.</p>
<p><code>左旋转</code>函数接受一条指向<code>红黑树</code>中的某个节点的链接作为参数.然后<strong>会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根节点的链接.</strong></p>
<p>也可以认为是<strong>将用两个键中的较小者作为根节点变为将较大者作为根节点</strong>(右旋转中逻辑相反).</p>
<p>旋转操作返回的链接可能是左链接也可能是右链接,这个链接可能是红色也可能是黑色的(在实现中我们使用<code>x.color = h.color</code>保留了它原本的颜色).这<strong>可能会产生两条连续的红链接,但算法会在后续操作中继续使用旋转操作修正这种情况.</strong></p>
<p><strong>旋转操作只影响了根节点</strong>(返回的节点的子树中的所有键和旋转前都相同,只有根节点发生了变化).</p>
<p>具体的实现如下图: </p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-left-rotate.png" alt=""></p>
<h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><p>实现<code>右旋转</code>的逻辑基本与<code>左旋转</code>相同,只需要将<code>left</code>和<code>right</code>互换即可.</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/redblack-right-rotate.png" alt=""></p>
<h2 id="颜色转换"><a href="#颜色转换" class="headerlink" title="颜色转换"></a>颜色转换</h2><hr>
<p>颜色转换操作也是用于保证<code>红黑树</code>的性质的.<strong>它将<code>父节点</code>的颜色由黑变红,将<code>子节点</code>的颜色由红变黑.</strong></p>
<p>这项操作与旋转操作一样是局部变换,<strong>不会影响整棵树的黑色平衡性.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/color-flip.png" alt=""></p>
<h4 id="根节点总是为黑"><a href="#根节点总是为黑" class="headerlink" title="根节点总是为黑"></a>根节点总是为黑</h4><p>颜色转换可能会使<code>根节点</code>变为红色,但红色的<code>根节点</code>说明<code>根节点</code>是一个<code>3-节点</code>的一部分,实际情况并不是这样的.所以我们需要将<code>根节点</code>设为黑色.</p>
<p><strong>每当<code>根节点</code>由红变黑时,树的黑链接高度就会加1.</strong></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><hr>
<p>在<code>红黑树</code>中实现插入操作是比较复杂的,因为需要保持<code>红黑树</code>的平衡性.但只要利用好<code>左旋转</code>、<code>右旋转</code>、<code>颜色转换</code>这三个辅助操作,就能够保证插入操作后树的平衡性.</p>
<h4 id="向单个2-节点中插入新键"><a href="#向单个2-节点中插入新键" class="headerlink" title="向单个2-节点中插入新键"></a>向单个2-节点中插入新键</h4><p>当一棵只含有一个键的<code>红黑树</code>只含有一个<code>2-节点</code>时,插入另一个键后需要马上进行<code>旋转</code>操作修正树的平衡性.</p>
<ul>
<li>如果新键小于老键,只需要新增一个红色的节点即可(这时,新的<code>红黑树</code>等价于一个<code>3-节点</code>).</li>
</ul>
<ul>
<li>如果新键大于老键,那么新增的红色节点将会产生一条红色的右链接,这时就需要使用<code>左旋转</code>修正根节点的链接.</li>
</ul>
<ul>
<li>以上两种情况最终的结果均为一棵等价于单个<code>3-节点</code>的<code>红黑树</code>,它含有两个键,一条红链接,树的黑链接高度为1.</li>
</ul>
<h4 id="向树底部的2-节点插入新键"><a href="#向树底部的2-节点插入新键" class="headerlink" title="向树底部的2-节点插入新键"></a>向树底部的2-节点插入新键</h4><p>和<code>二叉查找树</code>一样,向<code>红黑树</code>中插入一个新键会在树的底部新增一个节点,但<strong>在<code>红黑树</code>中总是用红链接将新节点和它的父节点相连.</strong></p>
<p>如果它的父节点是一个<code>2-节点</code>,那么上一节讨论的方法依然适用.</p>
<ul>
<li>如果指向新节点的是父节点的左链接,那么父节点就直接成为一个<code>3-节点</code>.</li>
</ul>
<ul>
<li>如果指向新节点的是父节点的右链接,那么就需要一次<code>左旋转</code>进行修正.</li>
</ul>
<h4 id="向一棵双键树-一个3-节点-中插入新键"><a href="#向一棵双键树-一个3-节点-中插入新键" class="headerlink" title="向一棵双键树(一个3-节点)中插入新键"></a>向一棵双键树(一个3-节点)中插入新键</h4><p>当向一个<code>3-节点</code>中插入新键时,会发生以下三种情况且每种情况都会产生一个同时连接到两条红链接的节点,我们需要修正这一点.</p>
<ul>
<li>如果<code>新键大于原树中的两个键</code> : 这是最容易处理的一种情况,这个<strong>键会被连接到<code>3-节点</code>的右链接</strong>.此时树是平衡的,<strong>根节点为中间大小的键</strong>,它有<strong>两条红链接分别和较小和较大的节点相连</strong>.只需要<strong>把这两条链接的颜色都由红变黑,那么就可以得到一棵由三个节点组成、高度为2的平衡树</strong>(其他两种情况最终也会转化为这样的树).</li>
</ul>
<ul>
<li>如果<code>新键小于原树中的两个键</code> : 这个<strong>键会被连接到最左边的空链接,这样就产生了两条连续的红链接.</strong>此时<strong>只需要将上层的红链接<code>右旋转</code>即可得到第一种情况</strong>(中值键为根节点并和其他两个节点用红链接相连).</li>
</ul>
<ul>
<li>如果<code>新键介于原树中的两个键之间</code> : 这种情况依然<strong>会产生两条连续的红链接:一条红色左链接接一条红色右链接.</strong>此时<strong>只需要将下层的红链接<code>左旋转</code>即可得到第二种情况</strong>(两条连续的红色左链接).</li>
</ul>
<p>通过以上这三种情况可以总结出 : 我们只需要通过0次、1次、2次旋转以及颜色转换就可以完成对<code>红黑树</code>的修正.</p>
<h4 id="将红链接向上传递"><a href="#将红链接向上传递" class="headerlink" title="将红链接向上传递"></a>将红链接向上传递</h4><p>当每次旋转操作之后都会进行<code>颜色转换</code>,它会使得中间节点变为红色.<strong>从父节点的角度来看,处理这样一个红色节点的方式和处理一个新插入的红色节点完全相同</strong>(继续将红链接转移到中间节点).</p>
<p>这个操作对应于<code>2-3树</code>中向<code>3-节点</code>进行插入的操作 : 即在一个<code>3-节点</code>下插入新键,需要创建一个临时的<code>4-节点</code>,将其分解并将中间键插入父节点(在<code>红黑树</code>中,是将红链接由中间键传递给它的父节点).重复这个过程,直至遇到一个<code>2-节点</code>或者根节点.</p>
<p>当根节点变为红色时需要将根节点的颜色转换为黑色(对应<code>2-3树</code>中的根节点分解).</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>插入操作的实现除了每次递归调用之后的对平衡性修正的操作,其他与<code>二叉查找树</code>中的插入操作没什么不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to put() is null"</span>);</div><div class="line">    <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</div><div class="line">        delete(key);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    root = put(root, key, val);</div><div class="line">    root.color = BLACK;</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// insert the key-value pair in the subtree rooted at h</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, K key, V val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cmp = key.compareTo(h.key);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) h.left = put(h.left, key, val);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right, key, val);</div><div class="line">    <span class="keyword">else</span> h.value = val;</div><div class="line"></div><div class="line">    <span class="comment">// fix-up any right-leaning links</span></div><div class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);</div><div class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</div><div class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);</div><div class="line">    h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>只要在沿着插入点到根节点的路径向上移动时<strong>在所经过的每个节点中顺序完成以下操作</strong>,就能够实现<code>红黑树</code>的插入操作.</p>
<ul>
<li>如果<code>右子节点</code>是红色的而<code>左子节点</code>是黑色的,那么进行<code>左旋转</code>.</li>
</ul>
<ul>
<li>如果<code>左子节点</code>是红色的而且它的<code>左子节点</code>也是红色的,那么进行<code>右旋转</code>.</li>
</ul>
<ul>
<li>如果<code>左右子节点</code>都是红色的,那么进行<code>颜色转换</code>.</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><hr>
<p>删除操作也需要定义一系列<code>局部变换</code>来在<strong>删除一个节点的同时保持树的完美平衡性</strong>.然而,这个过程要比插入操作还要复杂,它<strong>不仅要在(为了删除一个节点而)构造临时<code>4-节点</code>时沿着查找路径向下进行变换,还要在分解遗留的<code>4-节点</code>时沿着查找路径向上进行变换(同插入操作)</strong>.</p>
<h4 id="自顶向下的2-3-4树"><a href="#自顶向下的2-3-4树" class="headerlink" title="自顶向下的2-3-4树"></a>自顶向下的2-3-4树</h4><p><code>2-3-4树</code>是一种允许存在<code>4-节点</code>的树.它的插入算法就是一种沿着查找路径既能向上也能向下进行变换的算法.</p>
<ul>
<li>沿查找路径向下进行变换(向下变换与<code>2-3树</code>中分解<code>4-节点</code>所进行的变换完全相同)是为了保证当前节点不是<code>4-节点</code>(这样树的底部才有足够的空间插入新的键).</li>
</ul>
<ul>
<li>沿查找路径向上进行变换是为了将之前创建的<code>4-节点</code>配平.</li>
</ul>
<ul>
<li>如果<code>根节点</code>是一个<code>4-节点</code>,就将它分解成三个<code>2-节点</code>,树的高度加1.</li>
</ul>
<ul>
<li>如果在向下查找的过程中,遇到了一个<code>父节点</code>为<code>2-节点</code>的<code>4-节点</code>,就将<code>4-节点</code>分解为两个<code>2-节点</code>并将<code>中间键</code>传递给它的<code>父节点</code>(这时<code>父节点</code>变为了一个<code>3-节点</code>).</li>
</ul>
<ul>
<li>如果遇到了一个<code>父节点</code>为<code>3-节点</code>的<code>4-节点</code>,将<code>4-节点</code>分解为两个<code>2-节点</code>并将<code>中间键</code>传递给它的<code>父节点</code>(这时<code>父节点</code>变为了一个<code>4-节点</code>).</li>
</ul>
<ul>
<li>不必担心遇见<code>父节点</code>为<code>4-节点</code>的<code>4-节点</code>,算法本身保证了不会出现这种情况,到达树的底部之后,只会遇到<code>2-节点</code>或者<code>3-节点</code>.</li>
</ul>
<p>如果要使用<code>红黑树</code>来实现这个算法,需要以下步骤 : </p>
<ul>
<li>将<code>4-节点</code>表示为由三个<code>2-节点</code>组成的一棵平衡的子树,<code>根节点</code>和两个子节点都用红链接相连.</li>
</ul>
<ul>
<li>在向下的过程中分解所有<code>4-节点</code>并进行<code>颜色转换</code>.</li>
</ul>
<ul>
<li>在向上的过程中使用<code>旋转</code>将<code>4-节点</code>配平.</li>
</ul>
<p>只需要将插入一节中的<code>put()</code>实现方法里的<code>flipColors</code>语句(及其if语句)移动到递归调用之前(null判断和比较操作之间)就能实现<code>2-3-4树</code>的插入操作.</p>
<h4 id="删除最小键"><a href="#删除最小键" class="headerlink" title="删除最小键"></a>删除最小键</h4><p>从<code>2-节点</code>中删除一个键会留下一个空节点,一般会将它替换为一个空链接,但这样会破坏树的完美平衡性.所以在删除操作中,<strong>为了避免删除一个<code>2-节点</code>,我们沿着<code>左链接</code>向下进行变换时,需要确保当前节点不是<code>2-节点</code></strong>.</p>
<p><code>根节点</code>可能有以下两种情况:</p>
<ol>
<li>如果<code>根节点</code>是一个<code>2-节点</code>且它的两个子节点都是<code>2-节点</code>,可以直接将这三个节点变成一个<code>4-节点</code>.</li>
</ol>
<ol>
<li>否则,需要保证<code>根节点</code>的左子节点不是<code>2-节点</code>,必要时可以从它右侧的兄弟节点借走一个键.</li>
</ol>
<p>在沿着<code>左链接</code>向下的过程中,保证以下情况之一成立: </p>
<ul>
<li>如果当前节点的左子节点不是<code>2-节点</code>.</li>
</ul>
<ul>
<li>如果当前节点的左子节点是<code>2-节点</code>而它的兄弟节点不是<code>2-节点</code>,将左子节点的兄弟节点中的一个键移动到左子节点中</li>
</ul>
<ul>
<li>如果当前节点的左子节点和它的兄弟节点都是<code>2-节点</code>,将左子节点、父节点中的最小键和左子节点最近的兄弟节点合并为一个<code>4-节点</code>,使父节点由<code>3-节点</code>变为<code>2-节点</code>(或是从<code>4-节点</code>变为<code>3-节点</code>).</li>
</ul>
<p>只要保证了以上的条件,我们最终能够得到一个含有最小键的<code>3-节点</code>或<code>4-节点</code>(然后进行删除即可),之后再不断向上分解所有临时的<code>4-节点</code>.</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>在删除操作中,<code>颜色转换</code>的操作与插入操作中的实现略微有些不同(需要将父节点设为黑,而将两个子节点设为红).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       h.color = !h.color;</div><div class="line">       h.left.color = !h.left.color;</div><div class="line">       h.right.color = !h.right.color;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// restore red-black tree invariant</span></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">balance</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isRed(h.right)) h = rotateLeft(h);</div><div class="line">       <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</div><div class="line">       <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);</div><div class="line"></div><div class="line">       h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</div><div class="line">       <span class="keyword">return</span> h;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Assuming that h is red and both h.left and h.left.left</span></div><div class="line">   <span class="comment">// are black, make h.left or one of its children red.</span></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">moveRedLeft</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       flipColors(h);</div><div class="line">       <span class="keyword">if</span> (isRed(h.right.left)) &#123;</div><div class="line">           h.right = rotateRight(h.right);</div><div class="line">           h = rotateLeft(h);</div><div class="line">           flipColors(h);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> h;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"RedBlackBST underflow."</span>);</div><div class="line"></div><div class="line">       <span class="comment">// if both children of root are black, set root to red</span></div><div class="line">       <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</div><div class="line">           root.color = RED;</div><div class="line"></div><div class="line">       root = deleteMin(root);</div><div class="line">       <span class="keyword">if</span> (!isEmpty())</div><div class="line">           root.color = BLACK;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// delete the key-value pair with the minimum key rooted at h</span></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (h.left == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</div><div class="line">           h = moveRedLeft(h);</div><div class="line"></div><div class="line">       h.left = deleteMin(h.left);</div><div class="line">       <span class="keyword">return</span> balance(h);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="删除最大键"><a href="#删除最大键" class="headerlink" title="删除最大键"></a>删除最大键</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Assuming that h is red and both h.right and h.right.left</span></div><div class="line"><span class="comment">// are black, make h.right or one of its children red.</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">moveRedRight</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">    flipColors(h);</div><div class="line">    <span class="keyword">if</span> (isRed(h.left.left)) &#123;</div><div class="line">        h = rotateRight(h);</div><div class="line">        flipColors(h);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"RedBlackBST underflow."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// if both children of root are black, set root to red</span></div><div class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</div><div class="line">        root.color = RED;</div><div class="line"></div><div class="line">    root = deleteMax(root);</div><div class="line">    <span class="keyword">if</span> (!isEmpty())</div><div class="line">        root.color = BLACK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// delete the key-value pair with the maximum key rooted at h</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node h)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isRed(h.left))</div><div class="line">        h = rotateRight(h);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (h.right == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</div><div class="line">        h = moveRedRight(h);</div><div class="line"></div><div class="line">    h.right = deleteMax(h.right);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> balance(h);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>同样也需要像删除最小键那样在查找路径上进行变换来保证查找过程中任意当前节点均不是<code>2-节点</code>.如果目标键在树的底部,可以直接删除它;如果不在,则需要将它和它的后继节点交换.</p>
<p>在删除操作之后需要向上变换分解余下的<code>4-节点</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called delete() with key is null."</span>);</div><div class="line">    <span class="keyword">if</span> (!contains(key)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// if both children of root are black, set root to red</span></div><div class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</div><div class="line">        root.color = RED;</div><div class="line"></div><div class="line">    root = delete(root, key);</div><div class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// delete the key-value pair with the given key rooted at h</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node h, K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key.compareTo(h.key) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</div><div class="line">            h = moveRedLeft(h);</div><div class="line">        h.left = delete(h.left, key);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (isRed(h.left))</div><div class="line">            h = rotateRight(h);</div><div class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span> &amp;&amp; (h.right == <span class="keyword">null</span>))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</div><div class="line">            h = moveRedRight(h);</div><div class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span>) &#123;</div><div class="line">            Node x = min(h.right);</div><div class="line">            h.key = x.key;</div><div class="line">            h.value = x.value;</div><div class="line">            h.right = deleteMin(h.right);</div><div class="line">        &#125; <span class="keyword">else</span> h.right = delete(h.right, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> balance(h);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><hr>
<p>无论键的插入顺序如何,<code>红黑树</code>都几乎是完美平衡的,基于它实现的有序符号表操作的运行时间均为对数级别(除了范围查询).</p>
<p>在<code>红黑树</code>的实现中复杂的代码仅限于<code>put()</code>和<code>delete()</code>方法,像<code>get()</code>这些不会涉及检查颜色的方法与<code>二叉查找树</code>中的实现一致(因为这些操作与平衡性无关).</p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/731a1438c61492628cfaa1e9e618ecfb" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>本文参考资料引用自<a href="http://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="external">《Algorithms,4th Editio》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;红黑二叉查找树&lt;/code&gt;是&lt;code&gt;2-3查找树&lt;/code&gt;的简单表示方式,它的代码量并不大,并且保证了平衡性.&lt;br&gt;阅读本文前需先了解 &lt;a href=&quot;http://sylvanassun.github.io/2017/0
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>《Algorithms,4th Edition》读书笔记-2-3查找树</title>
    <link href="https://sylvanassun.github.io/2017/03/28/2017-3-28-2_3tree/"/>
    <id>https://sylvanassun.github.io/2017/03/28/2017-3-28-2_3tree/</id>
    <published>2017-03-28T10:00:00.000Z</published>
    <updated>2017-07-11T07:04:34.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>由于<code>二叉查找树</code>的性能与树的高度(即根节点到底部节点的深度)相关,因此当高度较大时,<code>二叉查找树</code>的性能就会下降.为了更高效的性能,<code>平衡查找树</code>应运而生,它能保证<strong>无论键的插入顺序如何,树的高度都将是总键数的对数.</strong></p>
<p><code>2-3查找树</code>就是平衡树的一种.</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><hr>
<p><code>2-3查找树</code><strong>允许树中的一个节点保存多个键.</strong>我们可以将<code>二叉查找树</code>中的节点称为<code>2-节点</code>,而在<code>2-3查找树</code>中引入了<code>3-节点</code>,它<strong>含有两个键和三条链接.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-anatomy.png" alt="2-3查找树"></p>
<blockquote>
<p>一棵<code>2-3查找树</code>由以下节点组成: </p>
<ul>
<li><p><code>2-节点</code> : 含有一个键(及其对应的值)和两条链接,左链接指向的<code>2-3查找树</code>中的键都小于该节点,右链接指向的<code>2-3查找树</code>中的键都大于该节点.</p>
</li>
<li><p><code>3-节点</code> : 含有两个键(及其对应的值)和三条链接,左链接指向的<code>2-3查找树</code>中的键都小于该节点,<strong>中链接指向的<code>2-3查找树</code>中的键都位于该节点的两个键之间</strong>,右链接指向的<code>2-3查找树</code>中的键都大于该节点.</p>
</li>
</ul>
</blockquote>
<p>一棵完美平衡的<code>2-3查找树</code>中的<strong>所有空链接到根节点的距离都应该是相同的.</strong></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><hr>
<p><code>2-3查找树</code>的查找算法与<code>二叉查找树</code>基本相似.</p>
<ul>
<li>首先,要判断一个键需要先将它和根节点中的键进行比较.</li>
</ul>
<ul>
<li>如果它和其中任意一个相等,查找命中.</li>
</ul>
<ul>
<li>否则,根据比较的结果找到指向相应区间的链接,并在其指向的子树中递归地继续查找.</li>
</ul>
<ul>
<li>如果最后指向空链接,查找未命中.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-search.png" alt="2-3树查找操作的路径轨迹"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><hr>
<p>由于<code>2-3查找树</code>需要保持完美平衡性,所以它的插入算法并不像<code>二叉查找树</code>那么简单.</p>
<p>它的插入算法基本思想是 : <strong>一直向上不断分解临时的<code>4-节点</code>并将中键插入更高层的父节点中,直至遇到一个<code>2-节点</code>并将它替换为一个不需要继续分解的<code>3-节点</code>,或是到达<code>3-节点</code>的根(分解根节点)</strong></p>
<h4 id="向2-节点中插入新键"><a href="#向2-节点中插入新键" class="headerlink" title="向2-节点中插入新键"></a>向2-节点中插入新键</h4><p>如果未命中的查找结束于一个<code>2-节点</code>,只需要把这个<code>2-</code>节点替换为一个<code>3-节点</code>,将要插入的键保存在其中即可.</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png" alt=""></p>
<h4 id="向一棵只含有一个3-节点的树中插入新键"><a href="#向一棵只含有一个3-节点的树中插入新键" class="headerlink" title="向一棵只含有一个3-节点的树中插入新键"></a>向一棵只含有一个3-节点的树中插入新键</h4><p>如果我们需要向一棵只含有一个<code>3-节点</code>的树中插入一个新键(这棵树中唯一的节点已经没有可插入新键的空间了).</p>
<ol>
<li>先临时将新键存入该节点中,使之成为一个<code>4-节点</code>(它扩展了以前的节点并含有3个键和4条链接).</li>
</ol>
<ol>
<li>将<code>4-节点</code>分解为一棵由3个<code>2-</code>节点组成的<code>2-3查找树</code>,其中一个节点(根)含有中键,一个节点含有3个键中的最小者(和根节点的左链接相连),一个节点含有3个键中的最大者(和根节点的右链接相连).</li>
</ol>
<ol>
<li>这时,这棵树既是一棵含有3个节点的<code>二叉查找树</code>,同时也是一棵完美平衡的<code>2-3查找树</code>.</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png" alt=""></p>
<h4 id="向一个父节点为2-节点的3-节点中插入新键"><a href="#向一个父节点为2-节点的3-节点中插入新键" class="headerlink" title="向一个父节点为2-节点的3-节点中插入新键"></a>向一个父节点为2-节点的3-节点中插入新键</h4><p>如果未命中的查找结束于一个<code>3-节点</code>,而它的父节点是一个<code>2-节点</code>.这种情况下,我们需要在<strong>维持树的完美平衡性的前提下为新键腾出空间.</strong></p>
<ol>
<li>构造一个临时的<code>4-节点</code>并将其分解(此时并不会为中键创建一个新节点).</li>
</ol>
<ol>
<li>将中键移动至父节点中(可以看做将指向<code>3-节点</code>的一条链接替换为新父节点中的原中键左右两边的两条链接,并分别指向两个新的<code>2-节点</code>).</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png" alt=""></p>
<h4 id="向一个父节点为3-节点的3-节点中插入新键"><a href="#向一个父节点为3-节点的3-节点中插入新键" class="headerlink" title="向一个父节点为3-节点的3-节点中插入新键"></a>向一个父节点为3-节点的3-节点中插入新键</h4><p>如果未命中的查找结束于一个父节点为<code>3-节点</code>且它本身也是一个<code>3-节点</code>时.我们可以构造一个临时的<code>4-节点</code>并分解它.将中键插入到它的父节点中.</p>
<p>但由于它的父节点也是一个<code>3-节点</code>,所以需要再用这个中键构造一个新的临时<code>4-节点</code>,然后在这个节点上进行相同的变换,即分解这个父节点并将它的中键插入到它的父节点中.</p>
<p>重复相同的变换直到遇到一个<code>2-节点</code>(将<code>2-节点</code>替换为一个<code>3-节点</code>)或者到达根节点(分解根节点).</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3c.png" alt=""></p>
<h4 id="分解根节点"><a href="#分解根节点" class="headerlink" title="分解根节点"></a>分解根节点</h4><p>如果从<strong>插入节点到根节点的路径上全部都是<code>3-节点</code></strong>.那么根节点最终会变成一个临时的<code>4-节点</code>,这时可以将<code>4-节点</code>分解为3个<code>2-节点</code>,同时树高加1(仍然保持了树的完美平衡性,因为它变换的是根节点).</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-split.png" alt=""></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><hr>
<p>关于如何使用一个简单的数据结构来表达实现<code>2-3查找树</code>可以见此文  <a href="http://sylvanassun.github.io/2017/03/29/red_black_binary_search_tree/">&lt;<algorithms,4th edition="">&gt;读书笔记-红黑二叉查找树</algorithms,4th></a> </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p><code>2-3查找树</code>的根本在于<strong>插入操作中的变换操作都是局部的</strong>,除了相关的节点和链接之外不必修改或者检查树的其他部分.</p>
<p>每次变换都会将<code>4-节点</code>中的一个键移动至它的父节点中,并重构相应的链接而不必涉及树的其他部分.且保持了树的完美平衡性,例如在变换之前根节点到所有空链接的路径长度为<code>h</code>,那么变换之后该长度仍然为<code>h</code>.<strong>只有进行根节点分解时,所有空链接到根节点的路径长度才会加1.</strong></p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-random.png" alt=""></p>
<p>通过这些我们可以总结得出: <strong><code>2-3查找树</code>的生长是由下向上的.</strong> (标准的<code>二叉查找树</code>则是由上向下生长的)</p>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<ul>
<li><p>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></p>
</li>
<li><p>Email : sylvanassun_xtz@163.com</p>
</li>
<li><p>本文参考资料引用自<a href="http://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="external">&lt;<algorithms,4th edition="">&gt;</algorithms,4th></a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;由于&lt;code&gt;二叉查找树&lt;/code&gt;的性能与树的高度(即根节点到底部节点的深度)相关,因此当高度较大时,&lt;code&gt;二叉查找树
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>     《Algorithms,4th Edition》读书笔记-二叉查找树</title>
    <link href="https://sylvanassun.github.io/2017/03/26/2017-3-26-binary_search_tree/"/>
    <id>https://sylvanassun.github.io/2017/03/26/2017-3-26-binary_search_tree/</id>
    <published>2017-03-26T10:00:00.000Z</published>
    <updated>2017-07-11T06:59:44.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>二叉查找树是一颗<strong>有序的二叉树</strong>,它有以下性质:</p>
<ol>
<li>若任意节点的左子树不为空,则<strong>左子树上所有节点的值均小于它的根节点的值</strong>.</li>
</ol>
<ol>
<li>若任意节点的右子树不为空,则<strong>右子树上所有节点的值均大于它的根节点的值</strong>.</li>
</ol>
<ol>
<li>可以将<strong>每个链接看做指向另一颗二叉查找树</strong>,而这棵树的根节点就是被指向的节点.</li>
</ol>
<ol>
<li>没有键值相等的节点.</li>
</ol>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/binary-tree-anatomy.png" alt=""> </p>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-anatomy.png" alt=""></p>
<p>使用二叉查找树实现的符号表结合了<strong>链表插入的灵活性和有序数组查找的高效性</strong>.通常采取二叉链表作为存储结构.</p>
<p>每个节点都含有一个键、一个值、一条左链接、一条右链接和一个节点计数器(用于统计其所有子节点数).<strong>左链接指向一棵由小于该节点的所有键组成的二叉查找树,右链接指向一棵由大于该节点的所有键组成的二叉查找树.</strong></p>
<p>如果将一棵二叉查找树的所有键投影到一条直线上,保证一个节点的<strong>左子树中的键出现在它的左边</strong>,<strong>右子树种的键出现在它的右边</strong>,那么我们一定<strong>可以得到一条有序的键列</strong>.</p>
<p>可以说二叉查找树和快速排序很相似.树的根节点就是快速排序中的第一个<code>基准数(切分元素)</code>,左侧的键都比它小,右侧的键都比它大.</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Node root; <span class="comment">// root node</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> K key;</div><div class="line">        <span class="keyword">private</span> V value;</div><div class="line">        <span class="keyword">private</span> Node left, right; <span class="comment">// left and right subtree</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// number of nodes in subtree</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.size = size;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">     * Returns true if this symbol table is empty.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; is this symbol table is empty, &#123;<span class="doctag">@code</span> false&#125; otherwise.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the number of key-value pairs in this symbol table.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> the number of key-value pairs in this symbol table.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size(root);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// return number of key-value pairs in binary search tree rooted at x</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.size;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中,使用私有嵌套类<code>Node</code>来表示一个二叉链表,每个<code>Node</code>对象都是一棵含有N个节点的子树的根节点.变量<code>root</code>指向二叉查找树的根节点(这棵树包含了符号表中的所有键值对).</p>
<h3 id="查找与插入"><a href="#查找与插入" class="headerlink" title="查找与插入"></a>查找与插入</h3><hr>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Returns the value associated with the given key.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> key the key</div><div class="line">    * <span class="doctag">@return</span> the value associated with the given key if the key is in the symbol table</div><div class="line">    * and &#123;<span class="doctag">@code</span> null&#125; if the key is not in the symbol table.</div><div class="line">    * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called get() with a null key."</span>);</div><div class="line">       <span class="keyword">return</span> get(root, key);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">get</span><span class="params">(Node x, K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line">       <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</div><div class="line">           <span class="comment">// if key &lt; x.key , search left subtree</span></div><div class="line">           <span class="keyword">return</span> get(x.left, key);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</div><div class="line">           <span class="comment">// if key &gt; x.key , search right subtree</span></div><div class="line">           <span class="keyword">return</span> get(x.right, key);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// hit target</span></div><div class="line">           <span class="keyword">return</span> x.value;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在二叉查找树中实现查找操作是很简单而简洁的,这也是二叉查找树的特性之一.-<strong>如果树为空,就返回null,如果被查找的键小于根节点的键,我们就继续在左子树中查找,否则在右子树中查找.</strong></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入操作的逻辑与查找差不多,只不过需要在<strong>判定树为空时,返回一个含有该键值对的新节点,还需要重置搜索路径上每个父节点指向子节点的链接,并增加路径上每个节点中的子节点计数器的值</strong>.</p>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-insert.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Inserts the specified key-value pair into  the symbol table.</div><div class="line">     * overwriting the old value with the new value if the symbol table already contains</div><div class="line">     * the specified key.</div><div class="line">     * Deletes the specified key (and its associated value) from this symbol table</div><div class="line">     * if the specified value is &#123;<span class="doctag">@code</span> null&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> key   the key</div><div class="line">     * <span class="doctag">@param</span> value the value</div><div class="line">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called put() with a null key."</span>);</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            delete(key);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        root = put(root, key, value);</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// if tree is empty, return a new node.</span></div><div class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</div><div class="line">            x.left = put(x.left, key, value);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</div><div class="line">            x.right = put(x.right, key, value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// hit target,overwriting old value with the new value</span></div><div class="line">            x.value = value;</div><div class="line">        &#125;</div><div class="line">        x.size = <span class="number">1</span> + size(x.left) + size(x.right); <span class="comment">// compute subtree node size</span></div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="最大键和最小键"><a href="#最大键和最小键" class="headerlink" title="最大键和最小键"></a>最大键和最小键</h3><hr>
<ul>
<li>如果根节点的<strong>左链接为空</strong>,那么一棵二叉查找树中<strong>最小的键就是根节点</strong>.</li>
</ul>
<ul>
<li>如果<strong>左链接非空</strong>,那么树中的<strong>最小键就是左子树中的最小键</strong>.找出最大键的逻辑也是类似的,只是变为查找右子树而已.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Returns the smallest key in the symbol table.</div><div class="line">  *</div><div class="line">  * <span class="doctag">@return</span> the smallest key in the symbol table.</div><div class="line">  * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> K <span class="title">min</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (isEmpty())</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called min() with empty symbol table."</span>);</div><div class="line">     <span class="keyword">return</span> min(root).key;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x;</div><div class="line">     <span class="keyword">else</span> <span class="keyword">return</span> min(x.left);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line">  * Returns the largest key in the symbol table.</div><div class="line">  *</div><div class="line">  * <span class="doctag">@return</span> the largest key in the symbol table.</div><div class="line">  * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> K <span class="title">max</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (isEmpty())</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called max() with empty symbol table."</span>);</div><div class="line">     <span class="keyword">return</span> max(root).key;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x;</div><div class="line">     <span class="keyword">else</span> <span class="keyword">return</span> max(x.right);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="向上取整和向下取整"><a href="#向上取整和向下取整" class="headerlink" title="向上取整和向下取整"></a>向上取整和向下取整</h3><hr>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-floor.png" alt="向下取整的路径轨迹"></p>
<ul>
<li>如果给定的键<strong>key小于二叉查找树的根节点的键</strong>,那么小于等于key的最大键<code>floor(key)</code><strong>一定在根节点的左子树中</strong>.</li>
</ul>
<ul>
<li>如果给定的键<strong>key大于二叉查找树的根节点</strong>,那么<strong>只有当根节点右子树中存在小于等于key的节点时,小于等于key的最大键才会出现在右子树中,否则根节点就是小于等于key的最大键</strong>.(将左变为右,小于变为大于就是向上取整的实现逻辑)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">floor</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called floor() with a null key."</span>);</div><div class="line">       <span class="keyword">if</span> (isEmpty())</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called floor() with empty symbol table."</span>);</div><div class="line">       Node x = floor(root, key);</div><div class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">else</span> <span class="keyword">return</span> x.key;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line">       <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">       <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, key);</div><div class="line">       Node t = floor(x.right, key);</div><div class="line">       <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</div><div class="line">       <span class="keyword">else</span> <span class="keyword">return</span> x;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">ceiling</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called ceiling() with a null key."</span>);</div><div class="line">       <span class="keyword">if</span> (isEmpty())</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"called ceiling() with empty symbol table."</span>);</div><div class="line">       Node x = ceiling(root, key);</div><div class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">else</span> <span class="keyword">return</span> x.key;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, K key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line">       <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">       <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</div><div class="line">           Node t = ceiling(x.left, key);</div><div class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</div><div class="line">           <span class="keyword">else</span> <span class="keyword">return</span> x;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> ceiling(x.right, key);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="选择和排名"><a href="#选择和排名" class="headerlink" title="选择和排名"></a>选择和排名</h3><hr>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>假设我们想找到排名为<code>k</code>的键(即树中正好有k个小于它的键).</p>
<ul>
<li>如果<strong>左子树中的节点数<code>t</code>大于<code>k</code></strong>,那么我们就继续递归地<strong>在左子树中查找排名为<code>k</code>的键</strong>.</li>
</ul>
<ul>
<li><strong>如果<code>t</code>等于<code>k</code></strong>,我们就<strong>返回根节点中的键</strong>.</li>
</ul>
<ul>
<li><strong>如果<code>t</code>小于<code>k</code></strong>,我们就递归地<strong>在右子树中查找排名为<code>(k-t-1)</code>的键</strong>.</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-select.png" alt="选择操作路径轨迹"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> K <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= size())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called select() with invalid argument: "</span> + k);</div><div class="line">    <span class="keyword">return</span> select(root, k).key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> t = size(x.left);</div><div class="line">    <span class="comment">// if left subtree node size greater than k,in left subtree search</span></div><div class="line">    <span class="keyword">if</span> (t &gt; k) <span class="keyword">return</span> select(x.left, k);</div><div class="line">        <span class="comment">// otherwise,in right subtree search</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) <span class="keyword">return</span> select(x.right, k - t - <span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h4><p><code>rank()</code>函数是<code>select()</code>函数的逆函数,它会返回指定键的排名.</p>
<ul>
<li>如果给定的<strong>键和根节点的键相等</strong>,就<strong>返回左子树中的节点总数t</strong>.</li>
</ul>
<ul>
<li>如果给定的<strong>键小于根节点</strong>,就<strong>返回该键在左子树中的排名</strong>(递归计算).</li>
</ul>
<ul>
<li>如果给定的<strong>键大于根节点</strong>,就<strong>返回<code>t+1(根节点)</code>加上它在右子树中的排名</strong>(递归计算).</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called rank() with a null key."</span>);</div><div class="line">    <span class="keyword">return</span> rank(root, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x, K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> rank(x.left, key);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(x.right, key);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> size(x.left);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除最大键和删除最小键"><a href="#删除最大键和删除最小键" class="headerlink" title="删除最大键和删除最小键"></a>删除最大键和删除最小键</h3><hr>
<p>对于删除最小键,需要不断深入根节点的左子树<strong>直至遇见一个空链接</strong>,然后将指向该节点的链接指向该节点的右子树(只需要在递归调用中返回它的右链接即可).此时已经没有任何链接指向要被删除的节点,因此它会被垃圾回收器gc掉.</p>
<p>删除最大键与其逻辑相似,只是方向相反.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Removes the smallest key and associated value from the symbol table.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Symbol table underflow."</span>);</div><div class="line">    root = deleteMin(root);</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="comment">// if the left link is empty,will link to the node of the right subtree.</span></div><div class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</div><div class="line"></div><div class="line">    x.left = deleteMin(x.left);</div><div class="line">    x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Removes the largest key and associated value from the symbol table.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Symbol table underflow."</span>);</div><div class="line">    root = deleteMax(root);</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">    <span class="comment">// if the right link is empty,will link to the node of the left subtree.</span></div><div class="line">    <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left;</div><div class="line"></div><div class="line">    x.right = deleteMax(x.right);</div><div class="line">    x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><hr>
<p>删除操作是二叉查找树中较为复杂的操作,假设我们要删除节点<code>x</code>(它是一个拥有两个子节点的节点),基本的实现逻辑如下.</p>
<ul>
<li><p>在删除节点<code>x</code>后用它的后继节点填补它的位置.</p>
</li>
<li><p>找出<code>x</code>的<strong>右子树中的最小节点</strong>(这样替换仍能保证树的有序性,因为<code>x.key</code>和它的后继节点的键之间不存在其他的键)做为<code>x</code>的后继节点.</p>
</li>
</ul>
<ul>
<li>将由此节点到根节点的路径上的所有节点的计数器减1(这里计数器的值仍然会被设为其所有子树中的节点总数加1).</li>
</ul>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-delete.png" alt=""></p>
<p>具体的过程如以下例子:</p>
<ol>
<li>将指向即将被删除的节点的链接保存为<code>t</code>.</li>
</ol>
<ol>
<li>将<code>x</code>指向它的后继节点<code>min(t.right)</code>.</li>
</ol>
<ol>
<li>将<code>x</code>的右链接(原本指向一棵所有节点都大于<code>x.key</code>的二叉查找树)指向<code>deleteMin(t.right)</code>,也就是在删除后所有的节点仍然都大于<code>x.key</code>的子二叉查找树.</li>
</ol>
<ol>
<li>将<code>x</code>的左链接(本为空)指向<code>t.left</code>(其下所有的键都小于被删除的节点和它的后继节点).</li>
</ol>
<p>以上的实现逻辑有一个缺点,即是<strong>在某些实际应用场景下会产生性能问题</strong>,主要原因<strong>在于后继节点是一个随意的决定,且没有考虑树的对称性</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called delete() with a null key."</span>);</div><div class="line">    root = delete(root, key);</div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        x.left = delete(x.left, key);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">        x.right = delete(x.right, key);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> x.left;</div><div class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> x.right;</div><div class="line">        Node t = x;</div><div class="line">        x = min(t.right);</div><div class="line">        x.right = deleteMin(t.right);</div><div class="line">        x.left = t.left;</div><div class="line">    &#125;</div><div class="line">    x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h3><hr>
<p>实现一个范围查找的思路可以是:<strong>将所有落在给定范围以内的键放入一个队列<code>Queue</code>并跳过那些不可能含有所查找键的子树</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;K&gt; <span class="title">keys</span><span class="params">(K lo, K hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lo == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called keys(lo,hi) first argument is null."</span>);</div><div class="line">    <span class="keyword">if</span> (hi == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called keys(lo,hi) second argument is null."</span>);</div><div class="line"></div><div class="line">    Queue&lt;K&gt; queue = <span class="keyword">new</span> Queue&lt;K&gt;();</div><div class="line">    keys(root, queue, lo, hi);</div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;K&gt; queue, K lo, K hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> cmp_lo = lo.compareTo(x.key);</div><div class="line">    <span class="keyword">int</span> cmp_hi = hi.compareTo(x.key);</div><div class="line">    <span class="keyword">if</span> (cmp_lo &lt; <span class="number">0</span>)</div><div class="line">        keys(x.left, queue, lo, hi);</div><div class="line">    <span class="keyword">if</span> (cmp_lo &lt;= <span class="number">0</span> &amp;&amp; cmp_hi &gt;= <span class="number">0</span>)</div><div class="line">        queue.enqueue(x.key);</div><div class="line">    <span class="keyword">if</span> (cmp_hi &gt; <span class="number">0</span>)</div><div class="line">        keys(x.right, queue, lo, hi);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>二叉查找树的高度决定了它在最坏情况下的运行效率,但由于键的插入顺序不会是永远随机的,所以树的某一端高度可能会非常深,解决这个问题可以使用平衡二叉查找树,它能保证无论键的插入顺序如何,树的高度都将是总键数的对数.</p>
<p>本文中的实现皆采用递归的方式是为了提高可读性,二叉查找树可以使用非递归的方式实现且效率会更高.</p>
<p>二叉查找树结合了链表插入操作的灵活性和有序数组查找操作的高效性,且还有很多种优化的改进方案(例如平衡二叉查找树),总体来说二叉查找树是一种比较好的动态查找方法.</p>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/c4bddf50d94148470c0836af64449e8b" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>本文参考资料引用自<a href="http://algs4.cs.princeton.edu/32bst/" target="_blank" rel="external">&lt;<algorithms,4th edition="">&gt;</algorithms,4th></a> &amp; <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">WikiPedia</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;二叉查找树是一颗&lt;strong&gt;有序的二叉树&lt;/strong&gt;,它有以下性质:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若任意节点的左子树不为空
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Tree" scheme="https://sylvanassun.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>谈谈几个常用的排序算法</title>
    <link href="https://sylvanassun.github.io/2017/03/20/2017-3-20-sorting_algorithm/"/>
    <id>https://sylvanassun.github.io/2017/03/20/2017-3-20-sorting_algorithm/</id>
    <published>2017-03-20T10:00:00.000Z</published>
    <updated>2017-07-11T06:58:59.158Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在读&lt;<algorithms 4th="">&gt;时,了解到了很多常用的排序算法,故写一篇读书笔记记录下这些排序算法的思路和实现.</algorithms></p>
</blockquote>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p>冒泡排序是一种非常简单的初级排序算法,它每次比较相邻的两个元素,如果顺序错误就进行交换.由于最小的元素是经由不断交换慢慢浮到顶端的,所以叫做冒泡排序.</p>
<p>冒泡排序对n个元素需要<code>O(n^2)</code>次的比较次数,所以它对规模较大的数组进行排序是效率低下的.</p>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt=""></p>
<ol>
<li>比较相邻的两个元素,如果第二个元素小于第一个元素,则进行交换(降序则相反).</li>
</ol>
<ol>
<li>对每一对相邻元素作同样的工作,从开始第一对直到最后一对.完成后,最后的元素将是最大的元素.</li>
</ol>
<ol>
<li>针对所有的元素重复以上步骤,除了最后一个元素.</li>
</ol>
<ol>
<li>持续地对每次越来越少的元素重复以上步骤,直到整个数组有序(即没有任何一对元素需要比较).</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// less与exch函数见完整代码</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (less(a[j + <span class="number">1</span>], a[j])) &#123;</div><div class="line">				exch(a, j, j + <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Bubble Sort</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> SylvanasSun</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// This class should not be instantiated.</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bubble</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Rearranges the array in ascending order, using the natural order.</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> a</div><div class="line">	 *            a the array to be sorted</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (less(a[j + <span class="number">1</span>], a[j])) &#123;</div><div class="line">					exch(a, j, j + <span class="number">1</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Rearranges the array in ascending order, using a comparator.</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> a</div><div class="line">	 *            a the arry to be sorted</div><div class="line">	 * <span class="doctag">@param</span> comparator</div><div class="line">	 *            comparator the comparator specifying the order</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, Comparator comparator)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (less(comparator, a[j + <span class="number">1</span>], a[j])) &#123;</div><div class="line">					exch(a, j, j + <span class="number">1</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// a &lt; b ?</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable a, Comparable b)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> a.compareTo(b) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// a &lt; b ?</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparator comparator, Object a, Object b)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> comparator.compare(a, b) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// exchange a[i] and a[j]</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Object[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		Object temp = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// print array elements to console</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">			System.out.print(a[i] + <span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String[] s = <span class="keyword">new</span> Scanner(System.in).nextLine().split(<span class="string">"\\s+"</span>);</div><div class="line">		Bubble.sort(s);</div><div class="line">		Bubble.print(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><hr>
<p>选择排序也是一种非常简单直观的初级排序算法,它的思想是不断地选择剩余元素之中的最小者.</p>
<p>它有以下两个特点.</p>
<ol>
<li><strong>运行时间与输入模型无关</strong> 在选择排序中,为了找出最小元素而扫描一遍数组并不能为下一轮扫描提供什么信息,即使输入是一个已经有序的数组或者是主键全部相等的数组和一个元素随机排列无序的数组所用的排序时间是一样长的.</li>
</ol>
<ol>
<li><strong>数据移动是最少的</strong> 如果元素处于正确的位置上,则它不会被移动.选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换.</li>
</ol>
<h4 id="运行过程-1"><a href="#运行过程-1" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""></p>
<ol>
<li>首先,找到数组中最小的那个元素</li>
</ol>
<ol>
<li>其次,将它和数组的第一个元素交换位置(如果第一个元素就是最小元素则它就和自己交换)</li>
</ol>
<ol>
<li>再次,在剩下的元素中找到最小的元素,将它与数组第二个元素交换位置.如此往复,直到整个数组有序.</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">			<span class="keyword">int</span> min = i; <span class="comment">// the smallest element index</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (less(a[j], a[min]))</div><div class="line">					min = j;</div><div class="line">				exch(a, i, min);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr>
<p>插入排序与选择排序一样,当前索引左边的所有元素都是有序的,但它们的最终位置并不是确定的.它构建了一个有序序列,对于未排序的元素,在有序序列中从后向前扫描,找到相应的位置并插入.</p>
<p>插入排序所需的时间取决于输入模型中元素的初始顺序.当输入模型是一个部分有序的数组时,插入排序的效率会高很多.</p>
<p>因此插入排序对于<strong>部分有序的数组</strong>十分高效,也很适合小规模的数组.</p>
<h4 id="运行过程-2"><a href="#运行过程-2" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""></p>
<ol>
<li>从第一个元素开始,该元素可以认为已是有序的</li>
</ol>
<ol>
<li>取出下一个元素,在有序序列中从后向前进行扫描</li>
</ol>
<ol>
<li>如果该元素(已排序)大于新元素,则将该元素移到下一位置(右移)</li>
</ol>
<ol>
<li>重复步骤3,直到找到已排序的元素小于或者等于新元素的位置</li>
</ol>
<ol>
<li>将新元素插入到该位置后</li>
</ol>
<ol>
<li>重复步骤2~5</li>
</ol>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">			<span class="comment">// a[i] insert to a[i-1]、a[i-2]、a[i-3]...</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j--) &#123;</div><div class="line">				exch(a, j, j - <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>插入排序还有很多可以优化的地方,这里例举两个案例.</p>
<ul>
<li>采用二分查找法来减少比较操作的次数.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> length = a.length;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">		<span class="comment">// binary search to determine index j at which to insert a[i]</span></div><div class="line">		Comparable v = a[i];</div><div class="line">		<span class="keyword">int</span> lo = <span class="number">0</span>, hi = i;</div><div class="line">		<span class="keyword">while</span> (lo &lt; hi) &#123;</div><div class="line">			<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">			<span class="keyword">if</span> (less(v, a[mid]))</div><div class="line">				hi = mid;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				lo = mid + <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// insertion sort with "half exchanges"</span></div><div class="line">		<span class="comment">// (insert a[i] at index j and shift a[j], ..., a[i-1] to right)</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; lo; --j)</div><div class="line">			a[j] = a[j - <span class="number">1</span>];</div><div class="line">		a[lo] = v;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>在内循环中将较大的元素都向右移动而不总是交换两个元素(访问数组的次数能够减半)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> length = a.length;</div><div class="line"></div><div class="line">	<span class="comment">// put smallest element in position to serve as sentinel</span></div><div class="line">	<span class="keyword">int</span> exchanges = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) &#123;</div><div class="line">			exch(a, i, i - <span class="number">1</span>);</div><div class="line">			exchanges++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (exchanges == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line"></div><div class="line">	<span class="comment">// insertion sort with half-exchanges</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</div><div class="line">		Comparable v = a[i];</div><div class="line">		<span class="keyword">int</span> j = i;</div><div class="line">		<span class="keyword">while</span> (less(v, a[j - <span class="number">1</span>])) &#123;</div><div class="line">			a[j] = a[j - <span class="number">1</span>];</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		a[j] = v;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<p>希尔排序,也称<strong>递减增量排序算法</strong>,它是基于插入排序的一种更高效的改进版本.</p>
<p>由于插入排序对于大规模乱序数组效率并不高,因为它只会交换相邻的元素,因此元素只能一点一点地从数组的一端移动到另一端.</p>
<p>而希尔排序为了加快速度简单地改进了插入排序,<strong>交换不相邻的元素</strong>以对数组的局部进行排序,并最终用插入排序将<strong>局部有序</strong>的数组排序.</p>
<p>希尔排序的思想是<strong>使数组中任意间隔为h的元素都是有序的</strong>,可以说一个h有序的数组就是h个互相独立的有序数组编织在一起组成的一个数组.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt="以23, 10, 4, 1的步长序列进行希尔排序"></p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span> (h &lt; a.length / <span class="number">3</span>) &#123;</div><div class="line">			<span class="comment">// h sequence 1,4,13,40,121,364,1093,...</span></div><div class="line">			h = h * <span class="number">3</span> + <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; a.length; i++) &#123;</div><div class="line">				<span class="comment">// a[i] insert to a[i-h],a[i-2*h],a[i-3*h]...</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</div><div class="line">					exch(a, j, j - h);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			h = h / <span class="number">3</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<p>归并排序是分治算法的典型应用.所谓归并即是<strong>将两个有序的数组归并成一个更大的有序数组</strong>.</p>
<p>它有一个主要的缺点就是它需要额外的空间(辅助数组)并且所需的额外空间和N成正比.</p>
<h4 id="合并过程"><a href="#合并过程" class="headerlink" title="合并过程"></a>合并过程</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt=""></p>
<ol>
<li>申请空间,使其大小为两个已有序序列之和,该空间用于存放合并后的序列</li>
</ol>
<ol>
<li>声明两个指针,最初位置分别为两个有序序列的起始位置</li>
</ol>
<ol>
<li>比较两个指针所指向的元素,选择相对小的元素放入合并空间中,并移动指针到下一个位置</li>
</ol>
<ol>
<li>重复步骤3直到某一指针到达序列尾部</li>
</ol>
<ol>
<li>将另一序列剩下的所有元素直接放入合并序列尾</li>
</ol>
<h4 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h4><p>自顶向下即是从顶部化整为零地递归解决问题.</p>
<p>例如:要对数组a[lo..hi]进行排序,需要先将它切分为a[lo..mid]与a[mid+1..hi]两部分,<strong>分别通过递归调用将它们单独排序</strong>,最后<strong>将有序的子数组归并为最终的排序结果</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi]</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">		<span class="comment">// copy a[] to aux[]</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">			aux[k] = a[k];</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// merge back to a[]</span></div><div class="line">		<span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">			<span class="keyword">if</span> (i &gt; mid) &#123;</div><div class="line">				a[k] = aux[j++];</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</div><div class="line">				a[k] = aux[i++];</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) &#123;</div><div class="line">				a[k] = aux[j++];</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				a[k] = aux[i++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"><span class="comment">// mergesort a[lo..hi] using auxiliary array aux[lo..hi]</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (hi &lt;= lo)</div><div class="line">			<span class="keyword">return</span>;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">		sort(a, aux, lo, mid);</div><div class="line">		sort(a, aux, mid + <span class="number">1</span>, hi);</div><div class="line">		merge(a, aux, lo, mid, hi);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h4><p>自底向上则是循序渐进地解决问题.</p>
<p>实现思路是先归并那些微型数组,然后再成对归并得到的子数组,直到将整个数组归并在一起.</p>
<p>可以先进行两两归并(每个元素想象成一个大小为1的数组),然后进行四四归并(将两个大小为2的数组归并成一个有四个元素的数组),然后是八八归并…..(一直下去)在每一轮归并中,最后一次归并的第二个子数组可能比第一个子数组要小,如果不是的话所有归并中两个数组大小都应该一致.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//merge函数与自顶向下中的一致</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		Comparable[] aux = <span class="keyword">new</span> Comparable[N];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; N; len *= <span class="number">2</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - len; lo += len + len) &#123;</div><div class="line">				<span class="keyword">int</span> mid = lo + len - <span class="number">1</span>;</div><div class="line">				<span class="keyword">int</span> hi = Math.min(lo + len + len - <span class="number">1</span>, N - <span class="number">1</span>);</div><div class="line">				merge(a, aux, lo, mid, hi);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>如果数组很小,那么频繁的递归调用效率会很差,所以可以使用插入排序(或选择排序等)来处理小规模的子数组.</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] src, Comparable[] dst, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">		<span class="keyword">if</span> (i &gt; mid) &#123;</div><div class="line">			dst[k] = src[j++];</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</div><div class="line">			dst[k] = src[i++];</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (less(src[j], src[i])) &#123;</div><div class="line">			dst[k] = src[j++];</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			dst[k] = src[i++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] src, Comparable[] dst, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">	<span class="comment">// if (hi &lt;= lo) return;</span></div><div class="line">	<span class="keyword">if</span> (hi &lt;= lo + CUTOFF) &#123;</div><div class="line">		insertionSort(dst, lo, hi);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">	sort(dst, src, lo, mid);</div><div class="line">	sort(dst, src, mid + <span class="number">1</span>, hi);</div><div class="line"></div><div class="line">	<span class="comment">// using System.arraycopy() is a bit faster than the above loop</span></div><div class="line">	<span class="keyword">if</span> (!less(src[mid + <span class="number">1</span>], src[mid])) &#123;</div><div class="line">		System.arraycopy(src, lo, dst, lo, hi - lo + <span class="number">1</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	merge(src, dst, lo, mid, hi);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// using insertion sort handle small array</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; lo &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j--) &#123;</div><div class="line">			exch(a, j, j - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">	Comparable[] aux = a.clone();</div><div class="line">	sort(aux, a, <span class="number">0</span>, a.length - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<p>快速排序又称<code>划分交换排序</code>,它也是一种分治的排序算法.</p>
<p>快速排序有一个潜在的缺点,在<strong>切分不平衡时</strong>这个程序可能会极为低效,所以需要<strong>在快速排序前将数组随机排序</strong>来避免这种情况.</p>
<p>它将一个数组切分成两个子数组,将两部分独立地排序.它与归并排序不同的地方在于:</p>
<ul>
<li>归并排序将数组分成两个子数组分别排序,最终将有序的子数组归并以致整个数组排序.</li>
</ul>
<ul>
<li>快速排序将数组排序的方式则是当<strong>两个子数组都有序时,整个数组也就是有序的</strong>了.</li>
</ul>
<ul>
<li>在归并排序中,递归调用发生在处理整个数组<strong>之前</strong>;而在快速排序中,递归调用发生在处理整个数组<strong>之后</strong>.</li>
</ul>
<ul>
<li>在归并排序中,一个数组会被<strong>等分为两半</strong>,而在快速排序中,<strong>切分的位置取决于数组的内容</strong>.</li>
</ul>
<h4 id="运行过程-3"><a href="#运行过程-3" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Partition_example.svg/302px-Partition_example.svg.png" alt=""></p>
<ol>
<li>先从数列中挑选出一个<code>基准</code>,可以为a[lo],它是被确认为排定的元素.</li>
</ol>
<ol>
<li>从数组的左端(左指针)开始向右扫描直到找到一个大于等于<code>基准</code>的元素.</li>
</ol>
<ol>
<li>从数组的右端(右指针)开始向左扫描直到找到一个小于等于<code>基准</code>的元素.</li>
</ol>
<ol>
<li>这两个元素即是没有排定的,交换它们的位置(保证了左指针i的左侧元素都不大于<code>基准</code>,右指针j的右侧元素都不小于<code>基准</code>).</li>
</ol>
<ol>
<li>.当两个指针相遇时,将<code>基准</code>和左子数组最右侧的元素(a[j])交换然后返回j即可.</li>
</ol>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]</span></div><div class="line">	<span class="comment">// and return the index j.</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i = lo; <span class="comment">// left point</span></div><div class="line">		<span class="keyword">int</span> j = hi + <span class="number">1</span>; <span class="comment">// right point</span></div><div class="line">		Comparable v = a[lo]; <span class="comment">// partition element</span></div><div class="line"></div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			<span class="comment">// scan left point</span></div><div class="line">			<span class="keyword">while</span> (less(a[++i], v)) &#123;</div><div class="line">				<span class="keyword">if</span> (i == hi)</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// scan right point</span></div><div class="line">			<span class="keyword">while</span> (less(v, a[--j])) &#123;</div><div class="line">				<span class="keyword">if</span> (j == lo)</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// check if point cross</span></div><div class="line">			<span class="keyword">if</span> (i &gt;= j)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			exch(a, i, j);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// put partition element v to a[j]</span></div><div class="line">		exch(a, lo, j);</div><div class="line">		<span class="comment">// now a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]</span></div><div class="line">		<span class="keyword">return</span> j;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (hi &lt;= lo)</div><div class="line">			<span class="keyword">return</span>;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> j = partition(a, lo, hi);</div><div class="line">		sort(a, lo, j - <span class="number">1</span>);</div><div class="line">		sort(a, j + <span class="number">1</span>, hi);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		shuffle(a);</div><div class="line">		sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// random sort an array</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(Object[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"array is null."</span>);</div><div class="line">		Random random = <span class="keyword">new</span> Random();</div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">			<span class="keyword">int</span> j = i + random.nextInt(N - i);</div><div class="line">			Object temp = a[i];</div><div class="line">			a[i] = a[j];</div><div class="line">			a[j] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="三向切分的快速排序"><a href="#三向切分的快速排序" class="headerlink" title="三向切分的快速排序"></a>三向切分的快速排序</h4><p>当存在大量重复元素的情况下,快速排序的递归性会使元素全部重复的子数组经常出现,这就有很大的改进潜力,将当前快速排序从线性对数级别的性能提升至线性级别.</p>
<p>一个简单的思路是<strong>将数组切分为三部分</strong>,分别对应小于、等于、大于切分元素的数组元素.</p>
<p>在实现中,维护一个左指针<code>lt</code>使得<code>a[lo..lt-1]</code>的元素都小于<code>基准</code>,右指针<code>gt</code>使得<code>a[gt+1..hi]</code>中的元素都大于<code>基准</code>,一个指针<code>i</code>使得<code>a[lt..i-1]</code>中的元素都等于<code>基准</code>,<code>a[i..gt]</code>中的元素都还未确定.</p>
<ol>
<li><code>a[i]</code>小于<code>基准</code>,将<code>a[lt]</code>和<code>a[i]</code>交换,lt++&amp;i++.</li>
</ol>
<ol>
<li><code>a[i]</code>大于<code>基准</code>,将<code>a[gt]</code>和<code>a[i]</code>交换,gt–.</li>
</ol>
<ol>
<li><code>a[i]</code>等于<code>基准</code>,i++.</li>
</ol>
<p>以上操作都会保证数组元素不变且缩小<code>gt-i</code>的值(这样循环才会结束).除非和切分元素相等,其他元素都会被交换.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// quicksort the subarray a[lo .. hi] using 3-way partitioning</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (hi &lt;= lo)</div><div class="line">			<span class="keyword">return</span>;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</div><div class="line">		Comparable v = a[lo]; <span class="comment">// partition element</span></div><div class="line"></div><div class="line">		<span class="comment">// a[lo..lt-1] &lt; a[lt..gt] &lt; a[gt+1..hi]</span></div><div class="line">		<span class="keyword">while</span> (i &lt;= gt) &#123;</div><div class="line">			<span class="keyword">int</span> cmp = a[i].compareTo(v);</div><div class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</div><div class="line">				exch(a, i++, lt++);</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</div><div class="line">				exch(a, i, gt--);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sort(a, lo, lt - <span class="number">1</span>);</div><div class="line">		sort(a, gt + <span class="number">1</span>, hi);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p>堆排序是基于堆的优先队列实现的一种排序算法.</p>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>优先队列是一种支持<strong>删除最大(最小)元素</strong>和<strong>插入元素</strong>的数据结构,它的内部是有序的,任意优先队列都可以变成一种排序方法.</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是一种数据结构,它通常可以被看作为一棵树的<strong>数组</strong>对象.将根节点作为最大数的叫做<strong>最大堆</strong>,反之,将根节点作为最小数的叫做<strong>最小堆</strong>.</p>
<p>堆是一个<strong>近似完全二叉树</strong>的结构,同时又满足了堆的性质:<strong>每个元素都要保证大于(小于)等于它的子节点的元素</strong>.</p>
<p>在一个堆中,根据根节点的索引位置不同,计算父节点与子节点位置的算法也不同.</p>
<ul>
<li>当数组起始位置为0时,位置k的节点的父节点为<code>(k - 1)/2</code>,它的两个子节点为<code>2k+1</code>,<code>2k+2</code>.</li>
</ul>
<ul>
<li>当数组起始位置为1时(即不使用索引0),位置k的节点的父节点为<code>k/2</code>,它的两个子节点为<code>2k</code>,<code>2k+1</code>.</li>
</ul>
<p>为了保证<strong>堆有序</strong>,需要支持两个操作用于<strong>打破堆的状态,然后再遍历堆并按照要求将堆的状态恢复</strong>,这个过程叫做<strong>堆的有序化</strong>.</p>
<ul>
<li><p><strong>由下至上的堆有序化(上浮)</strong> : 如果堆的有序状态因为某个节点变得比它的父节点更大而被打破时,那么就需要通过交换它和它的父节点来修复堆,将这个节点不断向上移动直到遇到了一个更大的父节点.(如果是最小堆,比较的逻辑相反).</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在本文中,均不使用数组的0索引</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">     <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k)) &#123;</div><div class="line">         exch(a,k, k/<span class="number">2</span>);</div><div class="line">         k = k/<span class="number">2</span>;</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>由上至下的堆有序化(下沉)</strong> : 如果堆的有序状态因为某个节点变得比它的两个子节点或是其中之一更小了而被打破时,需要通过将它和它的两个子节点中的较大者交换来修复堆,将这个节点向下移动直到它的子节点都比它更小或是到达了堆的底部.(如果是最小堆,比较的逻辑想法)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n为数组长度</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">     <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= n) &#123;</div><div class="line">         <span class="keyword">int</span> j = <span class="number">2</span>*k;</div><div class="line">         <span class="keyword">if</span> (j &lt; n &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</div><div class="line">         <span class="keyword">if</span> (!less(a[k],a[j])) <span class="keyword">break</span>;</div><div class="line">         exch(a,k, j);</div><div class="line">         k = j;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="运行过程-4"><a href="#运行过程-4" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt=""></p>
<p>堆排序可以分为两个阶段.</p>
<ol>
<li><strong>堆的构造阶段,将原始数组重新组织安排进一个堆中</strong>.从右至左用sink()函数,构造子堆,数组的每个位置都已经是一个子堆的根节点.只需要扫描数组中的一半元素,因为我们可以跳过大小为1的子堆.最后在位置1上调用sink()函数,结束扫描.</li>
</ol>
<ol>
<li><strong>下沉排序阶段,从堆中按递减顺序取出所有元素并得到排序结果</strong>.将堆中的最大元素删除,然后放入堆缩小后数组中空出的位置.</li>
</ol>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		<span class="comment">// construction max heap</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</div><div class="line">			sink(a, k, N);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// sink sort</span></div><div class="line">		<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">			<span class="comment">// the biggest element (root) swap smallest element then heap shrink</span></div><div class="line">			exch(a, <span class="number">1</span>, N--);</div><div class="line">			<span class="comment">// new root element sink</span></div><div class="line">			sink(a, <span class="number">1</span>, N);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</div><div class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">			<span class="keyword">if</span> (j &lt; n &amp;&amp; less(pq, j, j + <span class="number">1</span>))</div><div class="line">				j++;</div><div class="line">			<span class="keyword">if</span> (!less(pq, k, j))</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			exch(pq, k, j);</div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Object[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		Object swap = pq[i - <span class="number">1</span>];</div><div class="line">		pq[i - <span class="number">1</span>] = pq[j - <span class="number">1</span>];</div><div class="line">		pq[j - <span class="number">1</span>] = swap;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<table>
<thead>
<tr>
<th>名称</th>
<th>是否稳定</th>
<th>是否为原地排序</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>是</td>
<td>是</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</td>
</tr>
<tr>
<td>选择排序</td>
<td>否</td>
<td>是</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</td>
</tr>
<tr>
<td>插入排序</td>
<td>是</td>
<td>是</td>
<td>介入N和N^2之间</td>
<td>O(1)</td>
<td>（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</td>
</tr>
<tr>
<td>希尔排序</td>
<td>否</td>
<td>是</td>
<td>O(N log^2 N)</td>
<td>O(1)</td>
<td>每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</td>
</tr>
<tr>
<td>快速排序</td>
<td>否</td>
<td>是</td>
<td>O(N log N)</td>
<td>O(logN)</td>
<td>（小数，基准元素，大数）。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</td>
</tr>
<tr>
<td>三向快速排序</td>
<td>否</td>
<td>是</td>
<td>介于N和NlogN之间</td>
<td>O(logN)</td>
<td>对含有大量重复元素的输入数据效率较高。</td>
</tr>
<tr>
<td>归并排序</td>
<td>是</td>
<td>否</td>
<td>O(N log N)</td>
<td>O(N)</td>
<td>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。</td>
</tr>
<tr>
<td>堆排序</td>
<td>否</td>
<td>是</td>
<td>O(N log N)</td>
<td>O(1)</td>
<td>（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。</td>
</tr>
</tbody>
</table>
<p>在大多数实际情况中,快速排序是最佳选择.如果稳定性很重要而空间又不是问题的情况下,归并排序可能是最好的.但是在运行时间至关重要的任何排序应用中应该认真地考虑使用快速排序.</p>
<p>在JDK中,Arrays.sort()选择了根据不同的参数类型,来使用不同的排序算法.如果是原始数据类型则使用三向切分的快速排序,对引用类型则使用归并排序.</p>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<ul>
<li>Author : <a href="https://github.com/SylvanasSun" target="_blank" rel="external">SylvanasSun</a></li>
</ul>
<ul>
<li>Email : sylvanassun_xtz@163.com</li>
</ul>
<ul>
<li>文中的完整实现代码见我的<a href="https://github.com/SylvanasSun/algs4-study" target="_blank" rel="external">GitHub</a> &amp; <a href="https://gist.github.com/SylvanasSun/6706d008e735778c49659883f23f1eff" target="_blank" rel="external">Gist</a></li>
</ul>
<ul>
<li>本文参考资料引用自<a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">&lt;<algorithms,4th>&gt;</algorithms,4th></a> &amp; <a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">WikiPedia</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在读&amp;lt;&lt;algorithms 4th=&quot;&quot;&gt;&amp;gt;时,了解到了很多常用的排序算法,故写一篇读书笔记记录下这些排序算法的思路和实现.&lt;/algorithms&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/tags/Algorithms/"/>
    
      <category term="排序算法" scheme="https://sylvanassun.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用链表做为Stack、Queue中的数据表示结构的基本思路</title>
    <link href="https://sylvanassun.github.io/2017/03/06/2017-3-06-LinkedStack&amp;Queue/"/>
    <id>https://sylvanassun.github.io/2017/03/06/2017-3-06-LinkedStack&amp;Queue/</id>
    <published>2017-03-06T10:00:00.000Z</published>
    <updated>2017-07-11T06:58:27.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表?"></a>什么是链表?</h3><hr>
<p>链表是一种常见的基础数据结构(数组也是基础数据结构),它是一种递归的数据结构,由一系列节点(Node)组成,节点含有一个存储数据的数据域和一个指向下一个节点地址位置的引用.</p>
<p>链表是线性表的一种,但是它的物理存储结构是非连续、 非顺序的,元素的逻辑顺序是通过节点之间的链接确定的.</p>
<h3 id="数据结构与数据类型的区别"><a href="#数据结构与数据类型的区别" class="headerlink" title="数据结构与数据类型的区别"></a>数据结构与数据类型的区别</h3><hr>
<ul>
<li><p><font color="red">数据类型</font>是一组数据和一组对这些值进行操作的集合.</p>
</li>
<li><p><font color="red">数据结构</font>强调的是数据的存储和组织方式.</p>
</li>
</ul>
<p>常见的数据结构有:数组、栈、队列、链表、树、图、堆、散列表.</p>
<h3 id="链表是否可以替代数组"><a href="#链表是否可以替代数组" class="headerlink" title="链表是否可以替代数组?"></a>链表是否可以替代数组?</h3><hr>
<p>由于创建数组需要预先知道数组的大小,所以想要动态的扩容需要不断地创建新数组,而链表则可以充分利用内存空间,实现较为灵活的动态扩展.</p>
<p>使用链表替代数组有优点也有缺点:</p>
<p><strong>优点</strong></p>
<ol>
<li>在链表中进行插入操作或是删除操作都更加方便快速.</li>
</ol>
<ol>
<li>链表所需的空间总是和集合的大小成正比.</li>
</ol>
<ol>
<li>链表操作所需的时间总是和集合的大小无关.</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>无法像数组一样可以通过索引来进行随机访问.</li>
</ol>
<ol>
<li>由于每一个元素节点都是一个对象,所以需要的空间开销比较大.</li>
</ol>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><hr>
<p><img src="/img/note-img/2017-3-06-LinkedStack&amp;Queue/LinkedStack.png" alt=""></p>
<p>栈是一种基于后进先出(LIFO)的数据结构,其中的元素除了头尾之外,每个元素都有一个前驱和一个后继.</p>
<p>使用链表来表示栈内部的数据时,栈顶就是链表的头部,当push元素时将元素添加在表头,当pop元素时将元素从表头删除.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用链表实现的可迭代的下压栈(后进先出)</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by SylvanasSun on 2017/3/6.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Node first; <span class="comment">//栈顶(链表头部)</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">//元素个数</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于表示链表中的节点</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        T item;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断Stack是否为空</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> true代表Stack为空, false为未空</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>; <span class="comment">//也可以用N==0来判断</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回Stack中的元素数量</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 元素数量</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 将元素t添加到栈顶</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t 添加的元素</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        Node oldFirst = first;</div><div class="line">        first = <span class="keyword">new</span> Node();</div><div class="line">        first.item = t;</div><div class="line">        first.next = oldFirst;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 将栈顶的元素弹出</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 栈顶节点的item</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        T item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        N--;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 迭代器,维护了一个实例变量current来记录链表的当前结点.</div><div class="line">     * 这段代码可以在Stack和Queue之间复用,因为它们内部数据的数据结构是相同的,</div><div class="line">     * 只是访问顺序分别为后进先出和先进先出而已.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> Node current = first;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            T item = current.item;</div><div class="line">            current = current.next;</div><div class="line">            <span class="keyword">return</span> item;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><hr>
<p><img src="/img/note-img/2017-3-06-LinkedStack&amp;Queue/LinkedQueue.png" alt=""></p>
<p>队列是一种基于先进先出(FIFO)的数据结构,元素的处理顺序就是它们被添加到队列中的顺序.</p>
<p>可以使用实例变量first指向队列的队头,实例变量last指向队列的队尾,当将一个元素入列时,就将这个元素添加到队尾,当要将一个元素出列时,就删除队头的节点.</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用链表实现的Queue,它与Stack的区别在于链表的访问顺序.</div><div class="line"> * Queue的访问顺序是先进先出的.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by SylvanasSun on 2017/3/6.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Node first; <span class="comment">//链表头部,即队头</span></div><div class="line">    <span class="keyword">private</span> Node last; <span class="comment">//链表尾部,即队尾</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">//size</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于表示链表中的节点</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        T item;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断Queue是否为空</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> true代表Stack为空, false为未空</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回Queue中的元素数量</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 元素数量</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 入队,向队尾添加新的元素</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> item 添加的元素</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T item)</span> </span>&#123;</div><div class="line">        Node oldLast = last;</div><div class="line">        last = <span class="keyword">new</span> Node();</div><div class="line">        last.item = item;</div><div class="line">        last.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果队列为空,队头指向队尾(队列中只有一个元素),</div><div class="line">         * 否则将旧的队尾的next指向新的队尾</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (isEmpty()) first = last;</div><div class="line">        <span class="keyword">else</span> oldLast.next = last;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 出队,将队头节点弹出队列</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 队头节点的item</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">        T item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        N--;</div><div class="line">        <span class="comment">//如果队列为空,队尾则为null</span></div><div class="line">        <span class="keyword">if</span> (isEmpty()) last = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 迭代器,与Stack中的实现一致</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> Node current = first;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            T item = current.item;</div><div class="line">            current = current.next;</div><div class="line">            <span class="keyword">return</span> item;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><hr>
<ul>
<li>Author: SylvanasSun</li>
<li>GitHub: <a href="https://github.com/SylvanasSun" target="_blank" rel="external">https://github.com/SylvanasSun</a></li>
<li>Email: sylvanassun_xtz@163.com</li>
<li>Reference: 《Algorithms 4th edition》&amp; <a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" target="_blank" rel="external">wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是链表&quot;&gt;&lt;a href=&quot;#什么是链表&quot; class=&quot;headerlink&quot; title=&quot;什么是链表?&quot;&gt;&lt;/a&gt;什么是链表?&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;链表是一种常见的基础数据结构(数组也是基础数据结构),它是一种递归的数据结构,由一系列节点(Node)
    
    </summary>
    
      <category term="Algorithms" scheme="https://sylvanassun.github.io/categories/Algorithms/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedTable" scheme="https://sylvanassun.github.io/categories/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LinkedTable/"/>
    
    
      <category term="2017" scheme="https://sylvanassun.github.io/tags/2017/"/>
    
      <category term="数据结构" scheme="https://sylvanassun.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedTable" scheme="https://sylvanassun.github.io/tags/LinkedTable/"/>
    
  </entry>
  
</feed>
